{"meta":{"title":"Andy Yin","subtitle":"","description":"想法设法偷懒并不是一件坏事","author":"Andy Yin","url":"http://yinzhm.gitee.io","root":"/"},"pages":[{"title":"关于","date":"2023-04-01T02:54:51.000Z","updated":"2023-04-01T02:55:19.978Z","comments":false,"path":"about/index.html","permalink":"http://yinzhm.gitee.io/about/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2018-01-04T16:00:00.000Z","updated":"2020-01-09T05:40:29.323Z","comments":false,"path":"categories/index.html","permalink":"http://yinzhm.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"即刻短文","date":"2022-12-20T14:06:17.000Z","updated":"2023-03-31T15:35:54.065Z","comments":true,"path":"essay/index.html","permalink":"http://yinzhm.gitee.io/essay/index.html","excerpt":"","text":""},{"title":"所有相册","date":"2020-01-09T01:58:54.000Z","updated":"2023-03-30T15:12:08.399Z","comments":true,"path":"gallery/index.html","permalink":"http://yinzhm.gitee.io/gallery/index.html","excerpt":"","text":"2016 2016全年照片 2017 2017全年照片 2018 2018全年照片 2019 2019全年照片"},{"title":"所有标签","date":"2018-01-04T16:00:00.000Z","updated":"2020-01-09T05:40:48.586Z","comments":false,"path":"tags/index.html","permalink":"http://yinzhm.gitee.io/tags/index.html","excerpt":"","text":""},{"title":"常用网址","date":"2023-04-01T02:37:39.000Z","updated":"2023-04-01T02:38:24.005Z","comments":true,"path":"link/index.html","permalink":"http://yinzhm.gitee.io/link/index.html","excerpt":"","text":""},{"title":"相册集","date":"2023-04-01T14:42:04.000Z","updated":"2023-04-01T14:42:46.915Z","comments":true,"path":"album/index.html","permalink":"http://yinzhm.gitee.io/album/index.html","excerpt":"","text":""}],"posts":[{"title":"MySQL题库","slug":"MySQL题库","date":"2023-03-27T12:50:47.000Z","updated":"2023-03-29T11:38:27.510Z","comments":true,"path":"2023/03/27/MySQL题库/","link":"","permalink":"http://yinzhm.gitee.io/2023/03/27/MySQL%E9%A2%98%E5%BA%93/","excerpt":"","text":"VQ1 统计自然周平均登录次数题目描述 现有用户登录日志表user_login_tb(id 自增主键, uid 用户ID, login_date 登录日期)。 示例数据如下： 计算每个自然周内（周一到周日算一个自然周）所有用户的平均登录次数，用户可能在一天内登录多次。结果按每一周的周一升序排序，平均次数保留两位小数。 示例数据对应输出为： 思路解析用库函数WEEKDAY得到每个日期是星期几，然后使用DATE_SUB转换到当周周一的日期，再按周一日期分组，计算每个每组内用户登录总数（count(id)）和用户数（count(distinct uid)），总次数除以总人数就是平均登录次数。保留小数位数用round()。 123456789101112131415SELECT DATE_SUB( login_date, INTERVAL WEEKDAY(login_date) DAY ) AS week_begin, ROUND( COUNT(id) / COUNT(DISTINCT(uid)), 2 ) AS avg_timesFROM user_login_tbGROUP BY week_beginORDER BY week_begin 关键知识点 WEEKDAY(date): 返回周几，周1返回0，周2返回1。。。周日返回6 DATE_SUB(date, INTERVAL expr type): 从日期减去指定的时间间隔 COUNT(DISTINCT(列名)): 记录去重后计数 ROUND(x, y): 对参数x进行四舍五入的操作，返回值保留小数点后面指定的y位。","categories":[{"name":"数据分析","slug":"数据分析","permalink":"http://yinzhm.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}],"tags":[{"name":"数据分析","slug":"数据分析","permalink":"http://yinzhm.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yinzhm.gitee.io/tags/MySQL/"}]},{"title":"海盗指标","slug":"海盗指标","date":"2023-03-27T12:47:47.000Z","updated":"2023-03-29T07:54:06.000Z","comments":true,"path":"2023/03/27/海盗指标/","link":"","permalink":"http://yinzhm.gitee.io/2023/03/27/%E6%B5%B7%E7%9B%97%E6%8C%87%E6%A0%87/","excerpt":"","text":"AARRR模型 - 海盗指标基本内容海盗指标（Pirate Metrics）由美国著名的风险投资机构500 Startups的创始人戴夫·麦克卢尔（Dave McClure）提出，包含用户获取（Acquisition）、用户激活（Activation）、用户留存（Retention）、用户推荐（Referral）、盈利收入（Revenue），很多团队还会加入挽回流失用户（Resurrection）。 AARRR模型因其掠夺式的增长方式也被称为海盗模型，核心就是AARRR漏斗模型，对应广义的用户生命周期，帮助大家更好地理解获客和维护客户的原理。可以看出，和传统市场部门仅仅侧重于获取用户不同，增长团队的关注点几乎涵盖了一个用户生命周期的各个环节。 海盗指标驱动的是工作，对象是单一的产品。AARRR其实针对的不是单体用户，而是对一个产品的广义的所有用户。AARRR只是一个广义的用户生命周期的模型，分别也只是对应了其中的5个重要环节。而真正的用户生命周期则是：引入、成长、成熟、休眠、流失。引入时我们也要拉新,引入到成长是要注意留存，成长促活跃了会变为成熟，可以进一步产生转化和传播，到最后，用户还是会有可能休眠和流失的。这才是一个用户的生命周期。 关于AARRR的误解： 它不是五个指标，每个方面下边都有一堆指标可以看； 它不代表一个用户必须要走完五个流程。而是说作为一个整体，关注的五个方面。 不同的业务，AARRR模型形态不同。有的业务就是靠大量转发裂变；有的就是靠大量不付费用户撑起台面；有的就是流失很严重，但是沙里淘金服务几个大客户。 1、用户获取 用户从不同的渠道进入产品。获取用户是指在定位目标用户的前提下，通过线上线下的各种渠道让用户了解到产品信息，最终由潜在用户转化为实际用户的过程，衡量指标为点击数、安装量、打开率等。 2、提高用户活跃度 用户在产品内部使用核心功能（完成某个特定任务)。提高活跃度是指获取用户后通过引导用户完成某些”指定动作”，在消费产品过程中强化体验，使之成为长期的忠实用户。而’指定动作”则取决于产品的类型，有的产品只需用户在指定时间内登录就算用户活跃，而有的产品则还须完成指定的操作才算用户活跃，其衡量指标为设备激活量、订阅量、日活跃率等。 3、提高留存率 用户连续性的使用产品。提高留存率是指减少用户流失，提高持续消费用户人数。 4、获取收入 用户对产品产生了付费行为。产品的本质是商业，没有商业利益的产品很难维持平衡，产品运营最关心的就是收入。即使是互联网时代的免费产品也应该有其盈利模式。获取收入是指通过产品让用户买单的过程，并最终将留存用户转化为付费用户。在实际消费中，企业有一定的业务延展，比如通过广告展示、业务分成等方式向其他利益方收取费用，获得利益。衡量指标为付费率、付费频次、生命周期价值等。 5、传播 用户推荐他人来使用你的产品。病毒式传播又称自传播，是指用户自发进行产品传播，即在线上线下社交中的分享、互动等口碑推广，病毒式人传人实现用户爆发式增长。 用户激活 获取流量很容易，但留存和变现则显得比较困难。在获客成本日益增长的背景之下，将资源投入到激活存量用户上的性价比远高于投入到获客阶段。 提高新用户激活率的核心在于让新用户更快地体验到产品的“啊哈时刻”（Aha moment）。所谓“啊哈时刻”，其实就是产品核心功能带给用户的需求满足感。如果用户能在首次体验产品时即可感受到“啊哈时刻”，留下良好的第一印象，则用户将大概率成为产品的留存用户。一个用户是否经历了这一时刻，决定了他/她会成为你产品的留存用户还是流失用户。 同时除了引导用户感受到产品的核心功能，最好还能通过内容创造、社交关系等手段增加用户离开的沉没成本，在此之后，用户将更有可能成为产品的忠实用户。 根据肖恩·埃利斯在《增长黑客》中提出的用户转化公式：转化=欲望-摩擦，为了让更多刚被拉来的用户转化为留存用户，你既可以增加用户的欲望，即让产品变得更加完美；也可以减小摩擦，即消除用户顺利体会产品核心功能的障碍点。但让产品更完美往往比降低用户摩擦更为困难，而面对新用户，各大app降低新用户摩擦的发力点自然就落在了优化新用户体验。 优化着陆页着陆页是新用户下载app并打开后第一眼看到的页面，这一系列页面是产品和用户的第一次正式见面，一定要清晰明了地传达产品相关性，展示产品价值，提供明确的行为召唤。这即为转化率优化教父布莱恩·埃森伯格提出的“转化三位一体”。 产品相关性是指产品与访客目的和欲望之间的匹配度：“这是他们想要的吗？”。 展示产品价值是指迅速并且简洁地回答访客的疑惑：“我可以从中得到什么？”“这个产品的亮点在哪？”。 行为召唤为访客提供一个极富吸引力的下一步行动，可以在特定的用户操作的节点，用手势给用户提供必要的操作说明，减少用户操作成本。 创造学习流要利用好用户刚刚接触到产品的时刻，因为人们初次接触产品时也是他们最想弄明白如何使用产品的时候。要把握好这个时机告诉用户产品的核心价值，创造“学习流”。 举个例子，推特设计出一个学习流让用户更充分地体验到产品的核心价值，推特向用户推荐可关注的话题类别（例如时尚、体育和新闻），鼓励他们关注名人，最后完善他们的个人资料。 学习流结束时，用户不仅完成了注册并创建了自己的个性化档案，而且在他们首页显示的都是他们感兴趣的内容。如此一来，推特成功让用户第一次访问就决定使用这个产品、体验到它的“啊哈时刻”并且建立储存价值，一石数鸟。（注：Josh Elman，《三个增长黑客策略》） 如果有的用户对上述的“学习流”不买账，不配合，我们还可以用新用户游戏化或新手任务的方式完成学习流的功能。游戏化利用的底层策略是心理学概念——承诺和一致性。 一旦人们采取行动，无论是多小的行动，只要不是太难，人们就会更倾向于未来继续采取行动。与其给用户提供产品说明，不如让用户先通过一些简单的小步骤开始体验，在通过一步步的引导让用户逐渐体验到产品的核心功能。 此外还可以利用一些心理学上的其他原则——心流，当人们面临的挑战难度刚刚好——没有困难到想放弃，也没有简单到令人无聊，这时人们就处在心流状态，对产品的体验欲望也更加强烈，更愿意沉浸其中。 此外还可以使用心理学上的另一原则——互惠，人们更有可能因为礼尚往来而去做一些事情，说的其实就是产品的奖励机制，通过提供奖励可以训练人们条件反射式地做出某种行为。 当用户完成每一步任务时，用户就可以获得一定的奖励，当用户在产品上花费越多的时间，放入越多的个人信息，他们对产品的忠诚度就会越高，这就是心理学上常说的储值。这类方法适用于单用户型产品，如工具类产品，如印象笔记、幕布等。 触发物有些用户下载了产品后，由于各种各样的原因可能并没有完成新用户体验的所有流程就退出了app，又或是用户体验完成但并不决定在当下就使用产品的核心价值。 这时如果不做些什么，用户可能会再也不打开你的产品，最终等待产品的就只剩下用户的流失。触发物的出现很好地防止了这种情况的发生。 触发物是指任何刺激人们采取行动的提示，比如邮件通知（EDM），注册手机短信推送（MMS），产品移动推送（push）等。前两种方式都需要用户已经向我们提供了相关的联系方式，因此在用户激活阶段，我们主要通过push来实现用户的重新激活。 根据用户行为公式，行为 =（欲望-摩擦）* 助推 + 奖励，欲望、摩擦和奖励我们在前面都已经有所提及了，这里的push其实就是助推。 行为公式不仅可以用于用户的激活，在AARRR模型的全阶段都可以使用，这里为了把触发物讲解得更加深刻，举的例子也不全是激活阶段的例子。 在用户激活的阶段，产品接触用户的动机应该是提醒用户存在一个对他们明显有价值的机会，并且这个机会还需要契合App的核心价值。触发物可以分为以下几种类型： （1）刺激型触发物 刺激那些能力很强但动机不足的用户采取行动。如购买通知——鼓励用户利用短期折扣购买商品；状态改变——如购物车中某件商品降价了。 （2）信号型触发物 帮助那些动机和能力都很强的用户沿着正确方向前进并鼓励他们重复行动。如新功能通知——分享产品升级的消息；好友行为改变——朋友采取了一个行动，如蚂蚁森林的好友偷了你的水。 （3）协助型触发物 帮助那些动机很强但能力很低的用户采取行动。如创建账户——鼓励下载产品的用户注册，创建账户；用户唤回——提醒那些有一段时间没有访问网站或App的用户再次回来。 （4）内驱型触发物 触发物是人们的核心习惯，而且能够激发长期使用。如顶级用户奖励——让那些大量使用产品的用户知道他们很特别，鼓励他们更多地使用产品，和产品建立更加紧密的联系。 需要关注的核心指标 用户激活率：用户体验到核心功能的占比，各个产品体验到核心功能的定义不同，用户激活的定义也就不同，每个产品都会有适合自己的激活定义，激活定义的设定要清晰合理； 用户激活花费时长：指用户从进入产品到被激活所花费的时间，时间越短，说明激活流程的设计越成功，用户感受的摩擦越小； DAU(Daily Active User) / MAU(Monthly Active User)：用户日活跃与月活跃的比值，不同类型的产品存在不同的基准线，而且这个指标并不是对每种产品都合理有效。比值越大，固然说明用户对于产品的粘性越强，激活效果越明显，但如果产品的自然节奏本来就不是很高，如携程这类的旅游产品，领英这类的求职产品等，就应该更换产品指标，本性是无法对抗的； DAOT(Daily Average Online Time)：用户日均在线时长。使用时长越长，用户粘性越强，但同时需要防止由于产品使用流程过长而导致的DAOT增加。 用户留存 Fred Reichheld的研究表明：用户留存率每提高5个百分点，产品的利润就会提高25~95个百分点（Fred Reichheld, “Prescription for Cutting Costs,” Bain &amp; Company report (n.d.)）。留住用户的时间越长，从他们身上获得更多收益的机会也就越大，即使产品本身无法依靠出售商品或服务获利，也可以通过大量的流量吸引广告商的投资。 另一方面，留存曲线也是衡量产品PMF（Product-Market Fit，产品-市场匹配）是否平衡的最好标准，如果无论团队怎样努力，产品的留存曲线依然持续走低。那么产品所解决的需求很可能是一个伪需求，需要改变产品方向甚至及时止损，趁早放弃这个产品，投入新的方向。 留下用户的根本在于提供可以持续满足用户需求或者令他们感到愉悦的优质产品或服务，让产品或服务对他们而言不可或缺。 相对而言，具有储值价值的公司在提升留存率方面有着天生的优势，因为储值本身就增加了用户的沉没成本，产品的实用性也会随着时间的推移而逐渐增强。这也就是为什么微信这类社交产品有如此之高的护城河，社交关系的沉淀就是用户在产品内的重要储值，在设计产品时也应该尝试结合产品核心价值增加用户在储值方面的功能。 初期留存初期留存对产品而言非常关键，它决定了用户是继续使用，购买产品或服务还是使用一两次之后就“沉睡”。 留存初期在本质上其实是激活阶段的延伸，其核心就在于让新用户更快地体验到产品的“啊哈时刻”（&gt;Aha moment&gt;）。 中期留存一旦跨过留存初期，用户就进入留存中期，此时产品带来的新鲜感开始褪去。 留住用户的核心就在于让使用产品成为一种习惯，让用户逐渐从产品或服务中获得满足感，巩固用户对产品的忠诚度。接下来我们剖析一下中期留存的关键点 产品内容保持更新这一点相信不用多说大家也能想到，大家使用产品的目的是为了解决自己的需求，而用户需求的解决途径当然就是产品的内容，没有新内容产出的产品很容易就会被竞品挤掉，这点对于工具类产品尤为明显。 因此工具类产品往往都在发掘产品的社区功能，现在看来往往当UGC和PGC相结合时效果更好，引导用户生产内容，增加用户在app内的储值；音乐类产品和视频类产品利用自身大量播放明星音视频，距离明星更近的特性甚至有向着微博发展的趋势，比如明星入驻、饭圈和打榜等功能板块的出现。 游戏化的本质是通过明确的指引让用户在自愿的行为中获取乐趣，在设计游戏时可以暂时先弱化甚至抛开关于质量、服务、解决需求等理性评判的硬杠杆指标，洞悉用户在不同环境刺激下的认知行为模式，让用户自己养成习惯甚至是对此上瘾，以达到增强用户黏性的目的。 游戏化的玩法除了可以用于用户激活，还能用于用户留存，实际上，它在用户留存上发挥的效果更大。除了能在一些短期活动中大显身手，比如每年双十一都被淘宝支配的恐惧——叠猫猫、盖楼、喵铺，其更重要的点在于能够在一些长期的产品运营活动中培养用户的习惯。比如支付宝的蚂蚁森林、京东的种豆得豆还有拼多多的多多果园等。 在设计这些活动时可以利用用户的得失心理，即利用用户收获追求与损失厌恶的心理来设计。 在收获追求方面，主要通过不断优化产品体验实现，比如使用瀑布流替代翻页的UI设计让用户能持续不断地刷到内容，通过跳过片头片尾让用户模糊集与集之间的界限，让用户在不知不觉中就看了一集又一集。不仅增加了用户的使用时长，还给予了用户更好的观剧体验。 但人们对于失去的情感往往比得到更加强烈，因此利用用户损失厌恶的心理能更好地激发用户的参与，比如年年双十一都有的定金膨胀，交了定金的买家即使在双十一开始时不想买了，也很少能下决心放弃这些定金不买。甚至是各大电商平台推出的七天无理由退换，通过给买家留以退路降低买家的决策难度，最终促进交易的达成。而商品到手后，买家除非有明显的心理落差，对于一些并非必须要退的商品往往选择不退货，据此提升ARUP（Average Revenue Per User，平均单用户收入）。 又如小米擅长的饥饿营销，早年间的抢F码本身在一定程度上就区别了米粉和群众，抢到资格的购买者往往不会放弃这一机会，他们会认为放弃购买不仅失去了一部手机，还放弃了时间成本、稀缺性等超预期的溢价因素。因而一款手机在销售时不仅成功率高，不占用库存，又能在社会上形成口碑营销，一次次破圈。 社交关系关于熟人社交在促活上的玩法我们以微信读书为例，引导微信登录后，微信读书便申请共享微信好友，引入熟人社交关系。之后利用好友正在读以及免费赠书引导用户开始读书，利用用户的攀比心理及贪婪心理设计了读书排行榜及读书时长赠书币/免费阅读时长的活动增强用户黏性。还通过好友的想法将用户喜欢在书上做批注的习惯放大，增加了与好友甚至是陌生人互动的机制，鼓励用户生产内容，在产品内储值，增加用户离开时的沉没成本。 微信上各种各样的微信群，甚至是很多所谓由于各种原因加上的微信好友，很多情况下大家也都彼此不熟但仍可以一起social，这也是微信的陌生人社交。微博里的饭圈群组，抖音、小红书里的KOL，虽然这些陌生人社交都是弱关系，但如果我们的产品定位并不是社交产品，这种弱关系能够达到增加用户的沉没成本，维持用户粘性的目的就足够了。 惯性依赖让用户形成对产品的惯性依赖是用户中期留存阶段的核心。培养用户忠诚度的最经典方法即为形成品牌力，让用户一有需求就立即联想到你的产品，这一点在早期的电商产品中体现的较为明显。 譬如一想到买3C产品，就想到京东上看看，因为不容易买到3C产品的假货；一想到买书，第一个想到的电商平台就是当当，因为这里的书又多又全；一想买买买却又不知道买什么好，想被种个草，就想打开小红书，因为好像大家都曾在小红书上被种过草…… 品牌力固然强大，但也有弊端，首先是品牌力一旦形成也可能会对产品后续的转型形成阻力，另一方面，品牌力的形成需要长时间高投入的营销成本。在产品市场愈加饱和的今天，主赛道早已被头部玩家塞满，只能在一些小赛道上发力，品牌力形成的成本也水涨船高，ROI怎么算也高不到哪去。 根据用户行为公式：行为&gt;=&gt;（欲望&gt;-&gt;摩擦）&gt;*&gt;助推&gt;+&gt;奖励，我们可以通过助推培养用户对产品的惯性依赖。 这里说的助推就是产品的定时推送，有些定时推送是提前告知用户明确时间的，比如36氪每天早上8:15的8点1氪和每天晚上11:00的今日值得看；罗胖每天曾经早上6:30的罗辑思维（现在改为每天0:00），再如keep登录时就让用户根据自身情况设置每日提醒时间……这些都是给用户提前且明确的定时助推，培养用户的行为习惯。 还有一些不固定时间的提醒，通过微小的用户激励刺激用户每天都进入app，最终养成习惯。大家最熟悉的就是各类app都有的每日签到；再比如淘宝的淘金币，京东的京豆，拼多多的签到领红包；再升级一点还有习惯打卡活动，比如京东金融上每天6:00~8:30的早起打卡分钱活动…… 相对而言，固定时间的提醒可能比不明确时间的提醒更不易遭到用户反感，告知用户就像是和用户提前签订了一个契约，尤其当这个契约还是由用户自己设计的。keep之前的每日运动提醒默认在晚上7:55，经过不断的迭代更新，现在也改为了在用户登录时自行设置。 长期留存对于长期留存，运营的关键在于确保产品能继续为用户带来更大价值，让用户不断认识到产品的不可或缺性。当引导用户形成习惯后，如果没有给用户新的刺激，再加上竞争对手的不断涌现，用户很容易流失到其他产品，可以通过不断优化产品功能，改变UI设计，给用户带来新鲜感的同时也减少了竞品的替代风险。 有研究表明每次更新版本都可以刺激用户活跃一段时间，但要特别注意认真写更新说明，提高用户更新完随便打开的兴趣。 另一方面，当用户对产品有了一定的熟悉程度，掌握了产品的核心功能，有了一定的产品忠诚度，就可以引导用户开始关注以前从未使用过的功能或是新推出的功能。关于新功能的学习可以借鉴我们在用户激活中说过的“学习流”，引导用户沿着学习曲线前行，感受产品为自己带来的更深的价值。 如果能对新功能的上市进行预告，告诉用户马上会有新功能或者新产品以及这能给他们带来什么好处，可以有效地诱导用户一直使用产品。这一点在视频软件中已经获得了广泛的运用，比如各类视频app都会将平台即将上线的电影以时间线的方式清晰地展现给用户，我们又会因为某个平台网综的即将上线而重新下载了曾卸载过的app，因为某个番剧的即将上映而每天都在期待。 但这里需要注意的是要控制更新的节奏，当人们习惯了产品的外观和功能后，过快或者突然改变产品可能得不偿失。另外太多功能的添加又是对产品而言是一种挑战，尤其当你的产品架构不足以承受那么多功能时，新增功能很可能会伤害用户对产品原有核心价值的体验，譬如越来越臃肿的58同城。 好的产品应该既留出了足够的空位保证后续功能的拓展，又能在拓展功能时保证不对产品的核心功能造成损失，微信这种超级app就是这类产品的代表。 流失用户的召回最后，随着产品使用寿命的延长必然会伴随着用户的流失，因此，产品长期留存的另一问题就是流失用户的召回，而且还应该付出足够的精力去做用户召回。毕竟对流失用户的召回成本和ROI都比拉取新用户更有优势，流失用户的召回首先要对流失用户进行定义，比如半年未在平台内下单，3个月未登陆过app等，需要视产品的特性而定。 用户召回的第二步即为调查用户当初消失的原因，弄清楚离开的原因是否是可控或可以解决的。对于那些用户认为产品“不符合需求、对产品不感兴趣” 的用户就无需再花过多成本去召回了；重点应放在那些因为“产品功能不好用，竞品打击”等原因而离开的用户。 调查流失用户有三种方法，首先我们可以直接通过邮件或短信对他们进行问卷调查，可以包装成对对全体用户进行的问卷调查以防用户反感。但对流失用户而言，因为他们很可能已经对产品失去了兴趣，对填写调查问卷自然也没什么动力，除非有让用户感到有足够价值的奖励可以撬动他的欲望，否则他们很可能会对其置之不理。 网易严选的问卷以抽取50元话费红包为杠杆撬动用户填写问卷的欲望，这对于用户第一次填写可能有较大的吸引力，但当用户填写后却未被抽中，相似的问卷在下一次就很难再次引发用户的点击，如果又无合适的结果反馈，甚至会让用户对产品产生消极感受。 第二种方法则是通过对流失用户在产品内的行为数据以及问卷的反馈对用户进行聚类，甚至画出这类用户的用户画像，再结合用户本身在产品内的标签或画像，对不同类型的用户设计个性化的召回策略，最大化地提升召回率。 如果产品内的用户数据不充足，比如用户在注册时没有提供完善的身份信息或无法获得流失用户的去向。第三种方法则是通过其他第三方数据平台购买这些用户数据，完善用户画像，以确保自己能更有效地召回，是否决定购买则需要负责人事先评估好购买的ROI，先进行小规模的测试，根据测试结果决定是否对信息量进行扩大。 用户召回的第三步为根据先前制定的召回策略进行个性化召回，常见的策略有邮件通知（EDM），短信推送（MMS），产品移动推送（push），广告以及产品联动。在文案中鲜明直接地提醒他们产品的“啊哈时刻”或者当初吸引他们的产品核心价值，有时还需要提供一些用户奖励，切勿长篇大论。 在英曼，摩根找出那些曾经在网站上看过文章但已经三周没有访问的用户。鉴于许多用户都是按月订阅，所以他推测那些每月访问次数不足一次的用户更有可能注销账号。因此团队向这些用户发送邮件告知他们过去几周发生的重大新闻，并且通过行为召唤鼓励他们回来重新使用网站。收到邮件通知的用户中重回网站的比例比没有收到邮件的对照组高出了29.4%。（肖恩·埃利斯 摩根·布朗《增长黑客》）。 文案的设计需要注意信息传达的措辞、频率以及持续时间来确保你请求他们“回来”的信息不会惹烦或进一步疏远用户，甚至还需要根据不同用户对召回信息的接受度对用户进行分组个性化召回。这点对于日益更新的技术可能已不是难题，关键在于是否能够有这样的意识，否则你只会让他们对你的评价更差，从而彻底击碎挽回他们的希望。 有时，公司也应该接受事实，承认用户不会再回来了，停止对他们的召回，可能用户后面会因为一些你意想不到的原因就回来了。比如有的人因为自己追的星糊了，发誓再不追星，于是卸载了微博，一段时间内任凭你如何召回ta也无动于衷，可不知道哪一天ta就被自己的朋友安利了新爱豆，再一次下载了微博，重新开始了真香的追星之旅。 留存率在提升用户留存时，留存率是我们必须要关注的指标，尤其是在留存初期，它体现了产品的粘性和用户对产品的忠诚度。 但是不同产品对留存初期的衡量方式不同，对移动app来说留存初期可能是一天；对社交网络来说可能是一周或者两周；对SaaS（software as a service，要是to B端的产品）来说可能长达一个月甚至一个季度；对电子商务公司来说留存初期则通常是90天。应根据产品的行业标准以及你对用户行为的分析，来决定产品的留存初期应该多长。 关于留存率的算法，可以推荐下面的一种算法：统计日新增用户N天内仍然使用产品的用户数量占总新增用户数量的比例。 例如7日留存：第N+7天内再次使用产品的用户数量/第N天新增用户的总数量，其他每一天都类似，为了更好体现某次运营活动每个渠道带来的用户质量，可以将用户留存绘制成如下的表格辅助分析： 我们常说“生于拉新，死于留存”，随着流量红利的消失，用户日渐难以取悦，做好用户留存无疑是互联网企业能否稳定存在的关键。虽然文章讨论了很多产品留存的案例，但这一切的前提都是你的产品对于用户是有价值的，真切地解决了用户的需求，但又非市场里的唯一选择或必须长期使用，同时需要用户的坚持投入。要想让用户愿意长期留下来，形成使用习惯，除了确保产品内容的价值外，还需要在用户心理的各个节点上进行适当的引导与刺激。 就是说随着行业的发展，行业竞争越来越充分，用户的各种刚性需求基本已经被满足，移动用户的人口红利慢慢消失，中国互联网已经从低成本获客时代进入到了精细化运营和变现的时代，变现效率的高低直接决定了企业的生存质量。 这里，我们将要讨论的就是如何提高企业的变现效率，即如何在用户身上实现更大收益，首先看一下这篇文章的思维导图。 产品变现产品变现的七大模式获取、激活和留存客户的终极目标就是从他们身上获取收益，并且逐渐提高每位用户带来的收益，也就是提高用户的终身价值。 互联网商业模式的本质，无外乎两步：先通过低成本规模化获客，然后高效率持续变现。 在这里我们先讨论一下互联网产品商业变现的七大模式，每种变现模式都有值得展开的细节。 广告变现从钱的来源区分，变现的方式可以分为广告主付费和用户付费，广告变现无疑是前者，也是所有变现模式中普适性最强的一种变现模式。 一般而言工具类产品和流量类产品最直接的变现模式就是广告，常见的形式有Banner广告、插屏广告、信息流广告、开屏广告、激励视频广告等。 有些工具类产品虽然没有广告，但他们利用免费产品带来的流量为自己的其他广告产品引流，从而实现商业变现，比如搜狗和360，都是利用搜狗输入法或360安全卫士向自家浏览器等有足够变现能力的产品上引流。 还有一种新型的广告变现模式就是单纯鼓励用户看广告，每看一条广告就对广告收益进行小比例分成，平台方获取大部分的广告抽成。 这类产品主要针对三四线城市用户，通过占用他们的时间观看广告进行变现，产品的广告主也多为面向下沉用户的产品，比如趣头条，抖音极速版，今日头条极速版等，在下沉用户群众也是风靡一时。 还有一种广告变现模式在下沉用户市场中风靡，这种广告app以游戏的方式呈现，让用户通过玩游戏看广告赚钱，以游戏化方式刺激用户使用，比如网赚手游恐龙有钱，全民养猪，闲来斗地主赚金版等。 对于广告这种变现方式而言，企业关注的核心要放在创造更多广告位并且说服更多广告主出更高价钱来购买你的广告位，但要防止广告侵入性太强令用户反感，或者广告内容或设计不够醒目、不够有吸引力。 随着信息的渗透，人们对各种手段逐渐了解，从而变得敏感，更容易产生反感的情绪。 增值服务变现增值服务最早从运营商演变而来，比如早年的手机报、彩铃等，现在增值服务中最常见的是会员，虚拟货币，付费版软件等。 这类变现模式也被运用的较为普遍，比如工具类软件的付费版，付费功能等，各种平台的VIP会员，还有早年间风行一时的Q币Q钻演变到现在变成了为爱豆应援的各类应援物等。 提升这种变现方式变现效率的核心在于让更多订购者续订、延长订购年限和升级到价格更贵的服务。 引导用户升级到更贵服务难免会损害用户体验，因此更需要注意方式方法，让用户接受企业的恰饭需求，付费后也能切实戳中用户的需求，让用户获得更好的体验。 说明好各种服务的功能、价格以及计划档位的页面，显示计划档位和价格的页面不够合理常常会损害购买率，甚至导致用户的流失。 电商变现电商变现顾名思义，其变现方式分为售卖自己的商品或是收取其他供应商的平台使用费和营销推广费。 但并不是电商app才可以通过电商实现变现，比如抖音快手纷纷在2018年开通了电商功能，实现了直播和短视频+网购的变现闭环。 越来越多的垂直领域app也纷纷引入电商元素获取收入，如小红书从2013年PC端的PDF版攻略，再到推出专注于海外购物信息分享的UGC移动端社区app，到2014年完成了向跨境电商、综合电商的商业转化。 健身类产品keep，女性产品美柚，手账类产品时光手账……各类工具类产品也纷纷推出电商功能完成工具+社区+电商模式的商业闭环，有些平台甚至还会在平台内引入直播功能，带货的同时还提升了产品的活跃度。 电商涉及仓储、物流、配送等等，这种变现模式的风险就在于对于中小型非专业电商平台，全产业链难以实现全覆盖，对商家的监管经验不足，一开始需要小步前进，避免引入电商后对平台形象产生的不利影响甚至法律问题。 直播变现直播的形态虽出现较晚，但也已经有了多年的发展，目前趋于稳定。 目前主要变现方式为平台对主播礼物打赏的抽成、知识付费直播抽成和带货直播的抽成，关于带货抽成的部分我已经放在了电商中讨论。 除了在一些传统的直播产品，各类视频社区和社交类产品、工具类产品也逐渐发展了直播的形式，知识付费直播则发展得较晚，但在知乎、得到等知识社区类app内也已经十分普遍，平台主要依靠每节课付费的抽成变现。 数据变现说到数据变现，可能很多人想到的是企业通过用户数据和活动信息牟取盈利。 但更加主流的数据变现模式还是通过技术手段获取信息，再按照企业需求对数据进行建模可视化分析，为企业决策做数据支持，提供解决方案。 比如大数据征信评估、大数据支撑的咨询研究报告、数据精准营销等，这些数据公司主要偏向于B端，对C端用户而言相对陌生，他们主要通过数据交易市场进行交易，如中关村数海大数据交易平台，湖北华中大数据交易所，上海数据交易中心等。 游戏变现游戏变现大家都很熟悉，历史悠久，亘古不衰。 鉴于其变现能力的强大，早年间的很多网游玩家也纷纷向手游市场进军，腾讯、网易、B站等互联网企业的最大利润来源就是游戏。 游戏的一种变现方式是通过游戏的一次性购买盈利，以单机游戏为主，但更为流行，变现效率更高的模式是免费玩的在线游戏，其本质还是通过增值服务变现，从购买游戏时间——点卡到购买游戏道具、皮肤等。 在游戏的发展过程中发现早期以购买道具为主要盈利模式的游戏容易造成氪金玩家的过于强大，伤害普通玩家的游戏体验，造成恶意竞争，不利于用户的留存。 后面很多游戏纷纷转向通过卖皮肤、装饰等满足氪金玩家的独特性、虚荣心，而不对普通玩家的游戏体验造成本质上的伤害，最典型的游戏即为王者荣耀。 此外，广告当然也仍然是游戏的一种变现方式，只不过这里的广告更多的是激励视频，即看一次广告就可以免费获取一次复活的机会或领取一个道具。 金融变现金融变现是一种需要资质，门槛较高的变现方式，比如网贷、理财、基金、股票、数字货币等，以金融变现为主要变现方式的产品特点鲜明，基本上从产品名就能一眼看出，如宜人贷，悟空理财，任性贷等等，但由于此前频繁的P2P暴雷，中小型企业的市场已基本被大企业吞并。 除了销售金融产品外，支付通道也是一种金融变现模式，如支付宝和微信支付，作为支付通道，其盈利模式有以下几种： 1）余额投资 即使交易频繁，但支付通道中依然能够稳定沉淀大量的用户余额，淘宝商家也需要交纳一定量的保证金，这时支付通道就像一个网上银行，平台可以利用这笔钱投资、贷款等，即使是存在银行，每日也可收取高额的利息。 2）服务费 在对个人用户进行转账时，平台不会收取用户的手续费，但如果是对大型连锁超市这种企业账户进行转账消费，支付通道便会向商家收取一定的手续费用，另外，余额宝等理财相关业务以及缴纳水电费等功能的服务费也由支付宝收取。 3）广告收入 这点不用多提大家也可以理解，作为高流量，高日活的支付平台，其广告位也可为企业提供大量收入 如何优化定价增加营收的核心在于向用户提供让他们觉得很有吸引力而且最能满足他们需求的产品和服务。 在找到自己产品的变现模式后，下一步要做的就是绘制基本线路图，找到最重要的增收环节，分析哪些环节带来的收益最高，需要以这些环节为杠杆最大化撬动变现效率，哪些环节是夹点，即损失潜在收益的地方，需要反复测试优化，找出填补收益漏洞的方法。之后便要开始优化产品或服务的定价，提高变现效率。 定价策略威廉·庞德斯通曾在在他的书《无价：洞悉大众心理玩转价格游戏》中提到过“心动价格”（charm price），即相对于整数价格，那些故意以9、99、98或者95结尾的价格对消费者来说更具吸引力。作者研究了1987—2004年发表的8份研究表明，心动价格相比数值接近的整数价格可以将销售额提高24个百分点。其他使用心理战术的策略包括强调正价商品比降价商品贵的价值所在，在价格前印出美元符号，这些都可以影响用户行为。 问卷调查定价的另一种方式被称为菱形定价法，下图中四条曲线围成的菱形部分就是定价的合理区间，企业可以对区间内的价格进行测试，得出最优的价格。 其中四条线按照颜色由深到浅依次代表了用户觉得价格过低以至于令人怀疑产品质量的定价曲线，价格合理并让人觉得划算的定价曲线，价格合理但让人觉得稍贵的定价曲线，价格过高让人觉得价格与价值不匹配，不值得购买的定价曲线。 可以尝试通过问卷调查得到用户对于上述四个问题的答案。当然最终价格的确定还要参照产品或服务的研发、维护成本及对竞品的市场调研，最好由财务团队协同制定并经过领导层的同意，经过不断的试验得到最佳定价。 不同用户需求不同，能接受的产品及其定价也就不同，因此在问卷中还应该对用户所看重的功能进行调研，结合定价调研，即可创建一个由用户最看重的功能和愿意支付的价格点所组成的矩阵，对不同需求的群组提供不同价值的服务，使得价格与用户是相匹配的，即价格是与需求相匹配的。 如此，确保用户能够轻松对比各个方案包含的功能，判断某些方案是否值得更贵的价格就显得尤其重要。团队应该在每种计划的功能列表中一目了然地列出该计划包含的所有基本功能以及额外好处。印象笔记中面向不同需求制定的丰富套餐类型就是很好的例子。 定价相对论所谓定价相对论是说人们对于价格高低的判断往往会受到其他价格选项的影响，有时在定价是可以考虑增加一个产品选项，利用该选项帮助用户更好地了解你向他们出售的产品和计划的相对价值，这一选项被称为烟幕弹套餐，用以降低用户的价格敏感度，驱动用户购买价位更高的产品，最好的例子即为百度网盘的会员和超级会员。 百度网盘刚推出超级会员时，其价格在市场上其实相对较贵，因此团队在套餐选择上增加了烟幕弹套餐——会员，因而大大增加了超级会员的购买转化率。 定价相对论阐明的另一问题是：少并不总是多，即降低价格并不总是意味着销量的增加，有时降价甚至会损害销售。 这是因为人们将价格看作是质量的信号，这在技术和专业服务市场特别常见，降价是否能增加销售取决于目标用户对于价格的敏感度，在面向所有用户调低价格前需要先进行降价试验。 比如对于在结算途中放弃购买的用户提供25%的限时折扣，再不断降低折扣幅度，观察用户购买行为的变化，找到下单用户增长率的变化拐点，该点折扣即可作为挽回用户的最佳折扣点。 注意事项优化定价往往伴随着价格的变动，这是用户普遍不愿意看到的，不断改变价格和功能只会赶跑潜在用户，因此在优化定价的过程中，团队务必尽量保证用户体验的前后一致，考虑周详并协调好各方面。 对中国互联网用户而言，用户早已习惯免费使用产品，缺少互联网付费习惯，建议不要通过软件付费进行变现，不如利用广告或者付费使用的附加功能来变现免费用户实现营收的改善，比如在免费用户使用产品时向他们展示只有付费用户才能使用的功能，虚拟货币等。 消费心理学消费者行为并非总是理性或可预测的，在优化定价的过程中，消费者行为心理学的相关知识能使变现用户，增加营收更有效率，这里以罗伯特▪西奥迪尼在《影响力》中提到的影响用户行为的六原则介绍其在用户变现中起到的作用，实际上，这六大原则在整个AARRR模型的环节中都有着重要的价值，其实我们在用户激活和用户留存中都有涉及，这里首次较为系统地介绍了这六大原则。 互惠原则互惠原则是说人们更有可能因为礼尚往来而去做一些事情，在对用户进行变现时，不妨先对用户进行给予。 比如线下宜家的体验购物，线上各类电商的社区分享，工具类产品的免费-付费增值模式以及各类平台的VIP免费试用。 本质都是让用户获得美好使用体验后对产品产生了新的需求，进而进行了功能的升级/商品或服务的购买。 承诺和一致原则承诺和一致性原则是说已经采取过行动的人更可能再次采取行动，无论行动的大小或者内容发生了什么变化。 比如在用户激活中提过的“学习流”，游戏化等概念，都是让用户先从一些简单易上手的功能开始做起，之后再逐渐加大难度，能够有效提升用户完成整个任务的比例。 再比如电商中添加到购物车，添加到收藏等功能都是让用户先对购买表示出承诺以提高变现概率的方法。 社会认同原则社会认同原则是指当用户感到不确定时，人们会先看别人怎么做，然后自己才做决定，也就是我们常说的从众心理。 比如在用户留存中我们曾提过的微信读书利用好友正在读，XX人正在读的功能为用户提供阅读的参考。 在用户变现方面，淘宝的搜索展示页显示的成交量和好评率，拼多多推出的拼小圈功能以及在直播平台不停滚动的某某用户为某某主播打赏了某某礼物以及打赏榜等，这些都是利用社会认同原则提升用户的变现效率。 但用户不是傻子，社会认同原则的使用前提是让用户相信，对此，书中提到了有效评论和有效证言的7个核心要素CEAVENS，即可信（credible）、相关（relevant）、有吸引力（attractive）、可视（visual）、可量化（enumerated）以及具体（specific）。 增加证词、知名客户的企业标志、客户使用产品的结果、当前在你的网站上购物或者订购的人数等，最好以照片或截图的可视化方式呈现，让潜在客户相信他们的决定是对的。 权威原则权威原则是说人们会参考权威人士的做法来决定自己采取什么行动。 这也是为什么越来越多的电视广告开始使用科学专家站台，退而求其次也要使用领域内的KOL（关键意见领袖）在微博上发文宣传。 喜好原则好感原则是说相比自己不喜欢或者无感的公司或人，人们更愿意和自己喜欢的公司或人做生意。 深受我们喜欢的人推荐了一款产品或者服务的话，我们会买得更多，这也是为什么在广告领域约1/4的广告都是由明星进行代言。 除了明星代言，喜好原则也说明了只有服务好用户，提升好用户的满意度，才能让用户愿意为产品的核心价值买单。 稀缺原则稀缺原则是说当人们担心自己会错失良机时，采取行动的概率就会增加。 比如各类电商平台限时限量抢购的倒计时和销售进度条，淘抢购中的每几秒即会换一次产品，当商品只有几件库存时显示剩余数量，商品页内及购物车内品牌特价的倒计时，唯品会商品加入购物车后20分钟之内即会失效等，都是利用稀缺原则增加商品的销售概率。 需要关注的指标由于收入=DAU*PUR*ARPPU，因此在用户变现时我们主要关注的指标即为产品DAU（Daily Active User，日活跃用户数量）、PUR（Pay Users Rate，付费渗透率）以及ARPPU（Average Revenue Per Paying User 每付费用户平均收益）。 DAU：日活跃用户我们在用户激活中曾讨论过这一指标。 不同类型的产品存在不同的基准线，指标高说明用户粘性高，但如果产品的自然节奏本来就不是很高，如携程这类的旅游产品，领英这类的求职产品等，对DAU也不用过分苛求，产品本性是无法对抗的。 PUR：付费渗透率付费渗透率即为付费用户占全体活跃用户的比例，即付费渗透率=付费用户数/活跃用户数*100%，付费渗透率代表了用户群体的付费意愿、消费观念和目前的消费能力。 可以通过用户分层对付费渗透率进行更进一步细化，便于我们对于核心用户的针对性管理。 可以将付费用户分为： 鲸鱼用户，即ARPPU较高的用户，可以设定他们的平均每月花费占总用户消费额的50%； 海豚用户，即ARPPU中等数额的用户，可以设定他们的平均每月花费占总用户消费额的30%； 小鱼用户，即ARPPU较少的用户，可以设定他们的平均每月花费占总用户消费额的20%。 W-PUR：鲸鱼用户的付费渗透率=鲸鱼用户/活跃用户数量； D-PUR：海豚用户的付费渗透率=海豚用户/活跃用户数量； F-PUR：小鱼用户的付费渗透率=小鱼用户/活跃用户数量。 ARPPU：每付费用户平均收益计算公式为ARPPU（每付费用户收益）=付费总额/付费用户数。 个人认为这一指标是三个指标中最容易提升的指标，也是我们在全文中一直都在提的指标。 DAU受制于产品本身的天性，PUR需要培养用户的付费习惯，ARPPU针对的是已付费用户，也即他们的付费习惯已经被建立，想办法让他们多付点钱自然比培养习惯和克服产品天性更容易一些。 用户获取和传播 一个优质的获客活动往往与用户自传播密不可分，在增长黑客——AARRR模型的最后一章，我们将同时讨论模型中的最后两个模块——自传播和获客，让整个用户增长模型形成闭环。 产品冷启动时种子用户的寻找一个产品的从0到1，满足上架应用市场的条件只是它的第一步，更重要的是如何保证有用户愿意下载和使用，其中最关键的一步就是早期种子用户的寻找。 对成熟公司而言，种子用户自然可以从已有用户群中引流，但对于创业公司而言，没有用户基础，寻找种子用户的难度成比例升高。 种子用户的选取原则种子用户的选择不是越多越好，黄有璨在《运营之光》中曾说过一个好的运营需要能够把握产品节奏，知道不同阶段运营的重点。 对早期产品而言，产品功能仍不齐全，无数bug等待排除，产品价值有待验证，用户体验差强人意。如果在这时就大量拉新，很有可能会伤害用户，失去用户对产品的信任，造成用户不可挽回的流失。 对于早期产品，种子用户的规模不建议很大，1000~5000人即可，具体要视产品性质、团队维护精力、服务器承载规模等情况而定，甚至可以采取bilibili答题，知乎邀请码的措施提高入驻门槛，限制用户的过度增长。 但对种子用户的质量要求较高，他们最好是互联网行业从业人员、互联网爱好者或者是领域KOL（Key Opinion Leader，关键意见领袖）。这些人要么关注互联网，了解互联网，对产品接受度高，能够对产品体验提出有价值的意见；要么专业度高，在领域内有一定话语权，能够为产品产出有价值的内容，为产品的口碑传播奠定基础。 比如新浪微博在成立初期主要拉取了大量的娱乐圈明星，领域KOL等开通微博，甚至不惜开出高价稿酬，微博女王姚晨就是这批用户中的一员。他们为微博创造了大量内容，也为微博拉来了大批的用户。 另一方面，运营人员需要维护好与种子用户的关系，不断收集他们的反馈，解决产品使用过程中的bug，不断迭代，一步步优化用户体验。另外还需要与他们形成良好互动，在产品内流量不大时及时回复其生产的内容，定期送一些小礼品，维护在他们心中的良好形象，尽量能让他们愿意自发地帮你宣传你的产品。 从竞品粉丝中挖对于初创型公司，获取用户是一个从0到1的过程，难度不言而喻。 要找到符合种子用户要求的用户，最直接的方法当然是挖竞品的墙角，他们的粉丝必然是产品的爱好者，甚至是领域内“网红”，他们是最好的种子用户候选人，只要有足够的物质激励和精神激励，搞定一部分绝对不成问题。 这样虽说看起来有点不道德，但对于一个自由竞争的市场环境，用户凭其意愿自由流动，你方用户被我方犒赏吸引，自主做出投靠我方的选择，这对于市场经济而言自然无可厚非。 小米在最初做MIUI时，种子用户就是初创团队从各大手机论坛中一个个挖来的，经过精心的联系和筛选，最终有100人成为了MIUI的首批内测用户，为小米提供了很宝贵的建议，之后这个数字不断增长，形成了广泛的米粉。 KOL推荐如果说从竞品粉丝中挖掘种子用户是为了获取对改善用户体验的专业意见，那么获得KOL的推荐就是为了在后期扩大用户规模时获得巨大流量，产品领域内的KOL甚至可以为产品提供专业的背书。 以知乎为例，知乎在2011年1月26日开始邀请公测，只有获得邀请码的用户才能够入驻知乎，查看其中的内容。 邀请码初期由知乎内部人员在线下定向发放给互联网/创业圈的知名人士，像李开复、雷军等知乎曾经的投资人都曾是知乎的早期用户，为知乎做过背书，这也吸引了互联网圈人士的争相涌入，甚至形成了一码难求的状况。 这种做法对于社区产品而言不仅筛选出了大量优质用户，保证UGC内容的质量，也使知乎在社会上形成了巨大的市场声量，使得知乎在2013年初向公众开放注册后不到一年内就是用户量从40万迅速膨胀至400万。 早期产品的拉新就像在做一场局，为了日后能让更多人参与到这场局中，需要找到关键的破局点并倾尽全力使之成立与实现，日后再以此为杠杆撬动更多资源。 KOL对于拉新而言就是一个关键的破局点，虽然可能需要花费大量的精力，但做好了就一定能撬动更多资源的参与，因此这些经历也是完全值得的，这点无论对初创型公司还是成熟型公司的新产品都是一样的。 从现有成熟平台引流领域内的KOL数量不多，而且对于没有背书的创业公司而言难以撬动；有时产品目标领域较小，没有成熟论坛，或者难以找到粉丝群体混入；用完上面两种方法，种子用户的数量仍然较少，产品无法启动，怎么办？这时可以从微信、微博这种成熟的流量池中寻找种子用户，可以在微博上手动寻找，发私信，也可以在垂直领域公众号上投广告，发软文……以蚂蜂窝为例，他们的种子用户就是从微博上喜欢分享旅行心得，旅游体验的用户邀请而来的。 从现有产品导流这一招适用于已经有成熟产品的互联网公司，无需多讲，很好理解，但需要注意的问题仍然是不能随意导流，要控制种子用户的数量和质量，否则即使导流也是没有太大意义的，甚至会使一个好产品就此毁掉。 平台方使用马甲号发布内容用户来到一个新的平台，往往是茫然不知所措的，这时就需要平台方先提供内容范例，引导用户按照平台调性生产内容。 但如果仅以官方平台的账号发布内容，容易让用户感受到距离感，无法很好调动用户的积极性。 而且设想一下当你刚进入知乎、微博时，满屏都是知乎官方平台，微博官方平台发布的消息，会不会觉得很恐怖，想马上退出。 这时就需要产品的内容运营多申请几个账号发布内容，俗称马甲号，迅速引导用户了解产品的核心价值，开始使用。 设计产品自传播传统的外部拉新方式有付费广告、SEO（Search Engine Optimization，搜索引擎优化）/SEM （Search Engine Marketing，搜索引擎营销）、ASO（App Store Optimization，应用市场优化）、线下地推……其中的每一个方式都可以用一个专门的章节细谈，但这些方式在现如今获客难度日益增加的今天ROI差强人意。 当然，即使ROI低，这些手段仍具有提升产品品牌力的价值，在用户拉新的过程依然是必要的，但在这篇文章中，我主要想讨论的是另一种拉新方式——产品的自传播拉新。 我们在前面的文章中不止一次地提到过现如今获客难度的提升，好的获客方式往往与用户自传播紧密相连，通过产品的自传播拉新不仅效率更高，耗费的资源也更少。 需要说在前面的是：在设计自传播时需要确保产品能够为用户提供真正的价值，病毒传播是在好的包装和好的内容之间取得平衡。 Social currencys 社交货币所谓社交货币，其实指在人际交往中用以评价对方的因素，比如名包和豪车，这些都是社交货币，是一种用户对外可以炫耀的一种资本、格调。 社交货币是整个STEEPPS的核心，是在设计自传播活动中第一个要考虑的点，它告诉我们的是要让用户感觉到自己进入了他们渴望的世界中，迎合他们向身边朋友炫耀身份的需要，构建他们渴望的形象，通过有效调动用户向他人炫耀的欲望，用户就会愿意为你做任何事。 游戏的本质就是让我们挣得比别人更优越的社交货币，比如排位段位，大区排名等，为此，玩家愿意乐此不疲地为自己的账号氪金，以获得更昂贵的社交货币。 再比如支付宝的年度账单上超过全国XX%人，在XX区排名XX位，QQ音乐年度歌单上的我听了XX首歌，打败了XXX人，以及网易哒哒的睡姿大比拼等等刷屏级营销活动。 通过帮助用户建立“我很厉害”“不愧是我”的形象，让用户产生自传播欲望，甚至能与朋友圈好友产生共鸣，也自愿地参与进来。 Triggers 诱因所谓诱因，顾名思义，就是提醒用户想到产品的抓手。 一旦用户碰到这一抓手，便立即能够想到我们的产品，并且会向身边的人宣传和安利。这其实就是品牌力，也侧面解释了把用户自传播放在用户留存之后的原因，只有当产品获得用户的认可后，他们才更愿意自发地进行传播，只用利益撬动的病毒营销很有可能会变成高获客高流失的用户薅羊毛大赛，对企业而言是巨大的损失。 比如一谈到支付我们就会想到微信、支付宝，一谈到种草我们就会想到小红书，一想到什么问题我们就会想百度一下……虽然在书中，“诱因”这一点非常强大，但它其实已经超出了用户自传播的范围，它讲的更多的是创造一种社会风尚，需要市场营销人员的专业营销和长时间宣传。自传播活动的设计需要理由，自传播活动需要与场景相结合，不然会让用户的分享过于苍白，找不到理由。 这在电商领域已经玩得炉火纯青，各大头部电商没有场景创造场景也要上，我们喜闻乐道的“双十一”、“618”就是很好的例子。 常见的场景有时间节点类：比如女神节、男神节、暖春节等等；品牌、品类、商品本身的策划活动：比如超级品类日，超级品牌日，新品上市日等；时事热点类：比如新冠病毒期间消毒用品的活动，世界杯期间啤酒节、烧烤节活动；还有一种内嵌产品之中的自传播设计，如拼多多抢好友红包页越多好友参与则可抢红包越多，各大音乐app的自制歌词海报功能等。 Emotion 情绪当我们关注某件事，我们的情绪被某件事所触动时，我们往往会有很强的意愿去和大家分享这些事情。 对于情绪的分类，我们可以使用下图的情绪四象限对其进行阐述。 我们可以利用情绪四象限将自传播活动的情绪分为高唤醒的积极情绪、高唤醒的消极情绪、低唤醒的积极情绪以及低唤醒的消极情绪。 自传播活动的设计需要尽量从第一象限出发，比如丁香医生等平台在疫情爆发的第一时间就推出了发布疫情实时动态的功能，腾讯新闻推出的以及腾讯看点推出的周边小区肺炎疫情查询都得到了很好的传播。 第二象限的事件也许也能够引发大量传播，但这类事件风险较高，有损害平台形象，甚至有可能在违法边缘游走的倾向，不是特别建议，但每件事情的发生都有其两面性，即使一件消极事件发生，我们也可从唤醒群众积极心理着手策划活动，比如这次疫情的爆发是一件消极事件，但为湖北人民募捐就是一件积极营销。 低唤醒的积极情绪可能在垂直领域内能够形成较大范围的传播，但形成的影响力有限，视产品定位选择是否要进行设计，至于第四象限的事件，最好直接pass，对产品的自传播往往百害一利。 Public 公共性公共性本质上讲的就是人的从众性。尤其是当自传播的设计可视性强时，社会影响会更加促进我们的行动，比如我们在网购时，一件商品的销量、评价量和好评度一定是我们决定是否购买的重要参考。 在自传播活动的设计上，我们可以看到产品在宣传时甚至会同一时间段发文案，这就是为了形成一种刷屏效果，让用户产生从众心理，但有时也需要设计错峰刷屏，这样能让用户反复看到这些消息，产生好奇，一步步产生行动。 有时权威带来的从众效应能够事半功倍，比如微信刚开始是高端人士使用的聊天工具，后面由高端人士带来的从众效应让广大消费者都开始使用，上面说的冷启动时撬动KOL成为种子用户也是同样的道理。 Practical value 实用性实用性顾名思义，就是自传播带来的奖励设置，比如最常见的就是拉新用户返现金，拼多多拉取足够数量新用户后甚至可以获得200元的返现。奖励设置要符合产品的核心价值，用户更愿意传递对他人有价值的信息，这也是社交货币的一种体现，可以给分享双方更好的产品核心价值体验，而且可以使用户不方便比较奖励的实际价值。比如百度网盘拉新用户送存储空间，双十一叠猫猫时如果拉到的是新人猫，则战队获得的战力会大大提升等。 Story 故事对于一个自传播活动，相比于广告，人们可能更愿意传递故事，人们很少会思考那些直接获得的信息，但对那些跌宕起伏的故事往往会乐此不疲地讨论，比如2019年初为贺岁电影《小猪佩奇过大年》而做的爆款营销宣传片：《啥是佩奇》。 当人们津津有味地谈论这些故事的同时，也传播了我们的产品和思想。我们的目的绝不仅仅是为了讲述一个有趣的故事，而是要让故事的传播对我们而言更有意义。为此，我们需要将一些产品的重要信息注入到情节之中，让大家在谈论故事时也能够谈到我们需要宣传的信息情节。 在这里有三个讲好故事的基本公式： 悬念公式：悬念 – 行动 – 认知升级 通过悬念，让用户产生好奇心，在行动中设置冲突让用户渐渐代入，最后抛出和大家认知不同的结论产生认知升级的效果。 努力人公式：目标 – 阻碍 – 努力 – 结局 让用户怀着“哇，他到底是怎么打怪的？他最后怎么样了？”的心情跟着笔者一起经历主人公的故事，最后为主人公的成功而感到高兴。 意外人公式：目标 – 意外 – 转弯 – 结局 让你的故事拥有一个出人意料结局的公式，这样的故事能让用户不断怀着好奇心看到结尾，在最后产生：“哇，竟然是这样！”的意外感。 一些零散但很重要的小点产品的自传播能力任何产品的自传播能力都是由三个因素决定的：有效载荷（payload）、转化率（conversionrate）和频率（frequency）。 它们之间的关系如下：自传播能力=有效载荷×转化率×频率 有效载荷是指每位用户每次会向多少人发送拉新物料（如链接，带二维码的图片，邀请码等）；转化率是指转化用户数/收到拉新物料的总用户数；频率就是用户收到邀请的频率。 在设计产品自传播时的目标就是要优化这三个变量，以创造增长。 挖掘产品的网络效应最好的自循环能够激励用户主动帮助产品吸引更多新用户，因为这样可以改善用户自己的体验，社交产品、协作办公产品就是很好的例子。 因此，产品经理要挖掘产品的网络效应，即使用产品的人数越多，产品的体验就越好。 这也是为什么所有产品都在设计之初或迭代之后开始加入社交基因，比如平台生态下的UCG、拼团、社群、直播等等。 以电商平台为例，据极光大数据2017年12月份移动互联网电商app渗透率排行榜及同比变化显示：自2017年各大电商平台纷纷引入社交因素后，那些在产品的核心、主线功能融入社交基因的产品实现了快速的增长。 设计自循环时的考虑要素在设计自循环方式时，首先需要选择发送邀请的方式，这种方式最好是用户使用产品的自然结果。 比如使用网易邮箱大师发送邮件时都会自动在邮件末尾加上：签名由网易邮箱大师定制；网易云音乐制作歌词海报时也会在海报上加上网易云音乐的logo和二维码；前段时间朋友圈疯传的网易哒哒做的“人生必做的100件事”H5页面中自带的二维码一扫即可参加……对于海报型自传播活动，要注意提示语不能太强势也不能低调到用户难以发现，如果用户对活动感兴趣，他们自然会愿意参与进来，过度宣传不仅影响美观，甚至会让用户反感，不愿分享。 但也别指望用户勤快到满屏找入口，甚至回到应用商店专门下载，活动入口的设置要简约明了自然。 其次，你要考虑给予分享人和被分享人双向的奖励，刺激分享人的分享欲望及被分享人的接收欲望。 如果你的有效载荷本来就高，比如网易邮箱大师，你可能就无须使用有吸引力的激励措施来达到目的，因为即使发出邀请的比例很小，叠加效果也会非常显著。 但如果你的有效载荷低，可能你就需要一个更具吸引力的双向奖励来提高你的转化率和频率，关于激励的设置我们在用户激活（插入链接）中有详细的讨论，在此不做赘述。 最后，邀请计划也要嵌入到用户访问频率更高的地方，比如新用户体验页、用户个人页或活动首页等。 大多数获得口碑式病毒增长的公司都曾费尽周折努力使它们的原生病毒循环既显而易见又充满吸引力，使用户愿意自发地发出邀请。 注意事项有些自传播活动是用户自发进行的口碑传播，而有些自传播活动则是企业在战略上设计的病毒营销活动。 既然是营销活动，自然需要资金的投入，这时就需要注意做好效果成本的审核，即预估好每位新用户的获客成本范围。 这里介绍一种估算方法： 用户平均价值**=产品总估值/**产品用户数 在产品需求被验证的情况下，如果平均获客成本远小于平均用户价值，就可以烧钱推广。 注意这里的关键词：远小于。 钱不一定能融到，估值也可能会被砍，新用户很可能流失，而且你不可能把钱全部用于补贴用户，因此平均获客成本至起码要低于用户平均价值的一半，具体比例则需要参考行业内的标准。 当年拉手网不惜花费大笔成本营销获客，资金链风险急剧攀升，最后倒在了上市的路上，市场份额最终被成长速度略慢但精于控制成本的美团吞掉。 另外还有一种卑劣的拉新手段，比如在用户不知情或无意的情况下向用户好友发送下载链接或是在用户进入页面后不知如何关闭，即使点击叉号也仍然会自动下载app等等，这种拉新伎俩被称为黑暗模式，短期可能得到数据上的虚假繁荣，但长期来看用户之后产生的抵制情绪会将其最终拖垮，这些伎俩带来的负面评价和负面情绪足以摧毁任何一款产品。 笔者曾遇到过一种线下营销，莫名被忽悠着扫码关注后开始向微信列表里的好友一一发送推广链接，断网关机都完全无效，最后结果，不解释。 应关注的指标无论在产品冷启动阶段还是举办自传播活动的阶段，我们的目标都不会仅仅是找来新用户注册而已，我们的目标应该是让用户留下来，成为产品的活跃用户，甚至付费用户。 因此，像点击量、PV、UV 、网站访问时长、总注册数、新增注册数等单调的数字增长指标不应该是我们的核心关注目标。 这些指标随着活动力度的增强能呈现出短期的升高，他们告诉了我们活动有多大的影响范围，但并不意味着我们的产品受到了用户的喜爱，留住了用户。 因此我们在获客和自传播过程中应该结合新用户转化，留存，参与度等情况，关注具有比较性的指标，比如新用户留存率、产品DAU、用户分享率、付费转化率等关键指标，这些指标在我们前面的分享中也都有所涉及，在此不做赘述。","categories":[],"tags":[{"name":"数据分析","slug":"数据分析","permalink":"http://yinzhm.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}]},{"title":"Excel知识点大全","slug":"Excel","date":"2023-03-17T12:48:47.000Z","updated":"2023-03-28T12:49:25.171Z","comments":true,"path":"2023/03/17/Excel/","link":"","permalink":"http://yinzhm.gitee.io/2023/03/17/Excel/","excerpt":"","text":"Excel函数查找引用函数LOOKUP函数当需要查询一行或一列并查找另一行或列中的相同位置的值时，会使用其中一个查找和引用函数 LOOKUP。 基本语法 = LOOKUP(lookup_value, lookup_vector, [result_vector]) lookup_value：查找的值。 Lookup_value可以是数字、文本、逻辑值、名称或对值的引用。 lookup_vector：查找的值所在区域。lookup_vector中的值可以是文本、数字或逻辑值。 result_vector（可选）：返回值的所在列。 result_vector参数必须与 lookup_vector参数大小相同。 二分原理 LOOKUP是遵循二分法原理的查找函数。二分法则是从查询区域的二分之一处开始查询，如果没有查询到结果，就通过判断选择下一个二分之一处查询，直到查询到结果。如果没有找到查询值，就将查找区域中小于或等于查找值的最大值进行匹配。如果查找的值小于查找区域中的最小值，则 LOOKUP 会返回 #N/A 错误值。 LOOKUP的二分法查找，是跳跃式的查找。它默认被查找的那组值是从小到大排列的。如果遇到小的就向下找更大的，如果遇到大的就向上找更小的。 当二分值等于查找的值时，向下逐个查，如果向下的值也等于查找的值时，以最后一个相邻且相等的值作为符合条件的结果。 由于二分法的查询方向的判断，所以查询值需要按照升序排列。如果顺序错误，二分法就查询的结果就会与正确值背道而驰。 特殊公式 =LOOKUP(1,0/(条件判断),返回结果范围） =LOOKUP(1,0/((条件判断1) * (条件判断2）* … *（条件判断n)),返回结果范围） 如果有重复值，则返回最后一个符合条件的结果。 举例说明 1、查询成绩| | A | B || :–: | :–: | :—————————–: || 1 | 姓名 | 成绩 || 2 | 张三 | 75 || 3 | 李四 | 80 || 4 | | || 5 | 张三 | =LOOKUP(A5,A1:A3,B1:B3) （75） |2、根据不同的分值，给出相应的评语 =LOOKUP(B2,{0,50,60,75,86,96;”很差”,”差”,”一般”,”较好”,”优秀”,”能手”}) =LOOKUP(B2,{0,50,60,75,86,96},{“很差”,”差”,”一般”,”较好”,”优秀”,”能手”}) VLOOKUP函数用于搜索用户查找范围中的首列中满足条件的数据，并根据指定的列号，返回对应的值。 基本语法 = VLOOKUP(lookup_value, table_array, col_index_num, [range_lookup]) lookup_value：查找的值。 table_array：查找范围。必须包含查找值和返回值，且第一列必须是查找值。 col_index_num：用户指定返回值在数据查找范围中的第几列。 [range_lookup]（可选）查找方式 ─ 默认采用模糊匹配。如果需要返回值的模糊匹配，可以指定TRUE、非0的数值或省略；如果需要返回值的精确匹配，则指定FALSE或0。 注意事项 如果按模糊匹配的方式查找，VLOOKUP函数将把小于或等于查找值的最大值作为自己的查询结果。 如果第四参数为TRUE、非0的数值或省略，则为模糊匹配 123=VLOOKUP(A2,$E$2:$F$15,2,TRUE)=VLOOKUP(A2,$E$2:$F$15,2,1)=VLOOKUP(A2,$E$2:$F$15,2) 如果第四参数设置为FALSE、0或者缺省参数（不写任何内容，参数位置空出来），则为精确匹配 123=VLOOKUP(A2,$E$2:$F$15,2,FALSE)=VLOOKUP(A2,$E$2:$F$15,2,0)=VLOOKUP(A2,$E$2:$F$15,2,) 如果按模糊匹配的方式查找，必须将第二参数的数据表，按首列数据进行升序排序，否则不一定返回正确的结果。 举例说明 A B C 1 货品 单价 数量 2 笔记本 6750 500 3 手机 4800 300 4 5 货品 数量 6 手机 =VLOOKUP(A6, A1:C3, 3, 0) （300） 统计求和函数SUMIF函数使用 SUMIF 函数可以对表范围中符合指定条件的值求和。 基本语法 = SUMIF(range, criteria, [sum_range]) range：条件区域，用于条件判断的单元格区域。每个范围内的单元格必须是数字或名称、数组或包含数字的引用。空白和文本值将被忽略。选定的范围可以包含标准Excel格式的日期。 criteria：求和条件，由数字、表达式、单元格参考、文本或函数的形式来定义将添加哪些单元格。*任何文本条件或任何含有逻辑或数学符号的条件都必须写在双引号中间 (“) *。如果条件为数字，则无需使用双引号。 sum_range(可选)：求和区域，需要求和的单元格、区域或引用。 sum_range的行、列数应该与第一参数的相同。如果不这样做，求和结果可能会受到影响。 注意事项 忽略求和区域中的错误值：SUM不会忽略参数中的错误值，但如果使用SUMIF函数，就能通过设置参数避免他们。 = SUMIF(A2:A10, “&lt;=9E+307“) 9E+307相当于9×10^307，是EXCEL单元格中可以输入的最大数值，因为错误值比所有值大，只对小于或等于9E+307的数据求和就能规避错误值。 如果只设置两个参数，第1参数将同时扮演条件区域和求和区域两个角色。 第1参数和第3参数中的数据是一一对应的关系，只有当条件区域中的数据满足第2参数的求和条件时，才将对应的求和数据相加。 如果第3参数的求和区域不等于第1参数的条件区域，计算时，SUMIF会对求和区域进行扩展或收缩，使其行列数与条件区域相同。因此，除非必须需要，不建议第3参数和第1参数尺寸设置不同。 SUMIF函数允许你替它设置多行多列的条件和求和区域。面对多行多列的条件区域，在计算时，SUMIF函数会依次判断这个区域中的各个数据是否满足求和的条件，如果满足则将第3参数中对应位置的数据相加，再输出最后的求和结果。 举例说明 SUMIFS函数用于解决多条件求和问题的函数。 基本语法： = SUMIFS(sum_range, criteria_range1, criteria1, [criteria_range2, criteria2], …) sum_range：求和区域。 criteria_range1：条件区域。 criteria1：求和条件。 注意事项 =SUMIFS(求和区域，条件1区域，条件1，条件2区域，条件2，……条件n区域，条件n)，最多可以给函数设置255个参数，所以在使用SUMIFS函数时，最多可以为其指定127个求和条件。 与SUMIF函数不同的是：当求和区域与条件区域行列数不等时，SUMIFS函数并不会重新确定一个适合的求和区域。所以，在替函数设置参数时，应保证每个条件区域的行列数都与求和区域的行列数相同，否则公式将返回错误值。 举例说明 AVERAGEIF函数求满足某个条件的数据的平均值，语法类似SUMIF函数。 基本语法 = AVERAGEIF(range, criteria, [average_range]) range：条件区域 。要计算平均值的一个或多个单元格，其中包括数字或包含数字的名称、数组或引用。 criteria：求值条件。数字、表达式、单元格引用或文本形式的条件，用于定义要对哪些单元格计算平均值。如条件可以表示为 41、”&gt;41”、D3、”香蕉” 或 “41”。 average_range(可选)：求值区域。要计算平均值的实际单元格集。若忽略，则使用 range。 注意事项 第3参数可以省略，如果省略，函数会将第1参数同时当做条件区域和求值区域。如果你设置了一个与第1参数尺寸不同的第3参数，函数计算时也会重新确定求值区域的大小。 举例说明 AVERAGEIFS函数AVERAGEIFS函数用来解决按多条件求平均值的问题，其计算规则和使用方法，与SUMIFS函数完全相同。 基本语法 = AVERAGEIFS(average_range, criteria_range1, criteria1, [criteria_range2,criteria2],…) average_range：求平均区域。 criteria_range1：条件区域。 criteria1：求平均条件。 举例说明 COUNTIF函数COUNTIF函数用来解决条件计数的问题。 基本语法 = COUNTIF(range，criteria) range: 单元格区域。 criteria: 计数条件。 举例说明 COUNTIFS函数COUNTIFS函数用来解决多条件计数的问题。 基本语法 = COUNTIFS(criteria_range1, criteria1, criteria_range2, criteria2,…) criteria_range: 条件区域。 criteria: 计数条件。 举例说明 数据处理函数数值取舍ROUND函数ROUND函数用来按指定的小数位数，对数值进行四舍五入。 基本语法 = ROUND(number, num_digits) number: 取舍的数值。 num_digits: 保留的小数位数。 举例说明 ROUNDUP函数ROUNDUP函数和ROUND函数功能相似，不同之处在于ROUNDUP函数总是向下舍入数字（朝着远离0的方向）。 基本语法 = ROUNDUP(number, num_digits) number: 需要向下舍入的数值。 num_digits: 保留的小数位数。 举例说明 ROUNDDOWN函数ROUNDUP函数和ROUND函数功能相似，不同之处在于ROUNDUP函数总是向上舍入数字。（朝着靠近0的方向） 基本语法 = ROUNDUP(number, num_digits) number: 需要向上舍入的数值。 num_digits: 保留的小数位数。 举例说明 TRUNC函数TRUNC函数可以截断数值的小数部分，只保留整数部分，而不管这个数的小数部分是什么。 基本语法 = TRUNC(number, [num_digits]) number: 需要保留整数部分的数值。 num_digits(可选，默认为0): 指定取整精度。 举例说明 INT函数INT函数可以舍去数值的小数部分，只保留整数部分，向下取整。 INT函数保留小于或等于参数中数值的最大整数。 基本语法 = INT(number) 举例说明 ROUND、ROUNDUP、ROUNDDOWN、INT、TRUNC函数区别 TRUNC函数和ROUNDDOWN函数功能一样。但ROUNDDOWN函数第二参数是必需的。 INT函数只有一个参数；TRUNC、ROUND、ROUNDUP 和 ROUNDDOWN 有两个参数，第一个参数是要取舍的数，第二个参数是保留的小数位。 INT函数向下取整；TRUNC函数截断；ROUND函数四舍五入；ROUNDUP函数朝远离0的方向向上取舍；ROUNDDOWN函数朝靠近0的方向向下取舍。 文本处理CONCATENATE函数CONCATENATE函数可将最多 255 个文本字符串联接成一个文本字符串。联接项可以是文本、数字、单元格引用或这些项的组合，且必须将希望在结果中显示的任意空格或标点符号指定为使用双引号括起来的参数。 基本语法 = CONCATENATE(text1, [text2], …) 举例说明 PHONETIC函数PHONETIC函数用来提取文本字符串中的拼音字符，是为日文版EXCEL设计的函数，但在中文版可以用来连接单元格中文本类型的数据。 基本语法 = PHONETIC(reference) 注意事项 PHONETIC函数只能有一个参数，且必须为单元格引用。 在计算时，PHONETIC函数会对单元格中的公式、逻辑值、数值和错误值视而不见。 举例说明 LEN函数返回文本字符串中的字符数。 基本语法 = Len(text) 举例说明 LENB函数返回文本字符串中用于代表字符的字节数。区别于LEN函数，LEN函数的功能为返回文本字符串中的字符数。 基本语法 = LenB(text) 举例说明 EXACT函数比较两个文本字符串，如果它们完全相同，则返回 TRUE，否则返回 FALSE。 函数 EXACT 区分大小写，但忽略格式上的差异。 使用 EXACT 可以检验在文档中输入的文本。 基本语法 = EXACT(text1, text2) 举例说明 查找字符FIND函数Find函数用来对原始数据中某个字符串进行定位，以确定其位置。Find函数进行定位时，总是从指定位置开始，返回找到的第一个匹配字符串的位置，而不管其后是否还有相匹配的字符串。 基本语法 = FIND(find_text,within_text,[start_num]) find_text: 要查找的字符串。 within_text : 包含要查找关键字的单元格。就是说要在这个单元格内查找关键字。 [start_num]（可选）: 指定开始进行查找的字符数。比如start_num为1，则从单元格内第一个字符开始查找关键字。如果忽略 start_num，则假设其为 1。 举例说明 SEARCH函数用来返回一个指定字符或文本字符串在字符串中第一次出现的位置。从左到右查找，忽略英文字母的大小写。 基本语法 SEARCH(find_text,within_text,[start_num]) find_text：要查找的文本字符串。 within_text：要在哪一个字符串查找。 [start_num]（可选）：从within_text的第几个字符开始查找。当从第一个字符开始查找时可省略。但实际上，不管你输入多少，它都是从第一个字符开始查找，只是会跳过从开始到你输入数字中间的字符。 举例说明 FIND函数和SEARCH函数的区别 只有FIND函数能区分大小写字母 只能在SEARCH函数中使用通配符，如果要在公式中查找字符“?”或”*“的位置，需要在作为普通字符的”?”或”*“加上波形符”~”以作区别 截取字符快捷方式Ctrl+D、Ctrl+Enter、Ctrl+E 如果要对多处数据批量录入，只需选中多重数据（区域不连续时按住ctrl再选择），然后输入内容，再按下Ctrl+Enter即可。 如果需要在空白处填充数值或者文字，Ctrl+A全选区域——Ctrl+G定位——定位到空值——输入需要填充的文字或者数值——Ctrl+Enter。这里也可以填充公式，比如输入=A1*A2，就可以填充A1和A2单元格乘积的结果。Ctrl+F、Ctrl+H 查找和替换Shift+F3 显示插入的函数的参数提示框Alt+= 选中需要求和的数据区域以及求和值所处的单元格，然后按Alt+=,一键求和 格式转换文本转数字乘以数字1 在其他单元格输入数字1，并复制。 选择要转换为数字的文本区域，点击“选择性粘贴”，选择“乘”。分列 选择要转换为数字的文本所在列，点击分列- - 在单元格加“–”，即让文本变为负数再变成正数。 数据处理批量合并相同内容单元格 将光标定位在需要合并相同内容单元格的列，点击【数据】选项卡【分级显示】组中的【分类汇总】按钮，打开【分类汇总】对话框，点确认。 在生成的分类列中打开定位功能，选择空值，点击合并后居中。 用格式刷把分类列格式刷给原数据列。 点击【数据】选项卡【分级显示】组中的【分类汇总】按钮，打开【分类汇总】对话框，点击【全部删除】按钮，删除分类汇总。 最后删除空白列。复制筛选后的数据 Ctrl+A 全选 Alt+; （选定当前选定区域中的可视单元格）或者Ctrl+G，定位条件选可见单元格 Ctrl+C 复制 Ctrl+V 粘贴改变某一列的顺序 按住那一列，鼠标移动到绿色边框上，Shift+拖动即可。超过15位的数字文本如何标记重复值 文本型数字在参与公式运算的时候，Excel会默认将它作为数字进行运算，但由于Excel处理数字精度只有15位，因此如果使用默认的重复值设置格式规则会出错。 因此，解决问题的方法，可以在文本型数字的任意地方添加些文本，使文本型数字变成一个真正的文本(将文本连接一个”*”，Excel会把数字当作文字)，就可以利用条件格式或者函数来标记重复项。 例如：=countif($A$2:$A$10,A2&amp;”*”)插入图片技巧在移动时，按住ALT进行拖拽，图片会自动吸附单元格。 批量创建工作表 1、选中需要创建的工作表名称区域(要在最前面额外加一个单元格作为工作表名称)，点击Excel表格菜单区域插入中的数据透视表 2、在弹出“数据透视表”设置对话框，设置相应属性，下方选择放置数据透视图的位置，可以新建工作表，也可以在原有工作表创建，设置完成点击“确定”。 3、Excel表格右侧区域弹出设置面板，这时将数据透视图字段中的“工作表名称”拖拽至下方“筛选”框内 4、在数据图示表下拉菜单点击“选项”，点击“显示报表筛选页”即可，弹出“显示报表筛选页”对话框，鼠标单击选中“工作表名称”，点击“确定”完成。 批量创建Excel文件 1、右键任意一个工作表标签，在弹出的下拉列表中选择“查看代码”。即弹出代码窗口。 2、输入以下代码,点击运行 1234567891011Sub SaveSeparately() Dim sht As Worksheet Application.ScreenUpdating = False ipath = ThisWorkbook.Path &amp; &quot;\\&quot; For Each sht In Sheets sht.Copy ActiveWorkbook.SaveAs ipath &amp; sht.Name &amp; &quot;.xls&quot; ActiveWorkbook.Close Next Application.ScreenUpdating = True End Sub 注意事项不添加标题行 在EXCEL中，一个连续数据区域的首行就是这个区域的标题行，标题行标明了每列数据的属性和类别，是对数据进行筛选、排序等操作的依据。 数据表只用来保存有用的信息，作为数据表，不需要为其设置表格标题。 不合并单元格 在数据表中，应该杜绝使用合并单元格。因为合并单元格对数据表的破坏性非常大，严重影响后期的数据统计。不让多条记录或多个字段共用一个信息，是建立数据表应该遵循的一个原则。 一个字段只记录一类数据 如果将多种类别的数据保存在同一列中，会给汇总数据带来麻烦。 在数据表中，不能使用一列（字段）来保存多种数据，也不能使用多列（字段）来保存同一属性的数据。 字符之间不输入空格或其他字符 添加空格后的数据，会给查询和汇总数据带来麻烦。 不要在字符首尾或中间添加空格或其他字符，不要使用&lt;Alt+Enter&gt;组合键对数据换行等。 不同位置的同一数据必须完全一致 杜绝使用同音异形字，禁止混合使用全称或简称，要使用统一的标点符号、括号等。 为每条记录设置一个唯一的标识 数据表中的某些关键信息可能存在重复，而表中保存的信息不足以让EXCEL区分它们，从而为查询数据信息造成障碍。 在建立数据表时，为不同的记录设置一个唯一的标识信息是必须的。 不要在数据表中对数据进行分类汇总 在数据表中添加了汇总的行，虽然得到了汇总结果，但同时也改变了数据表本身的结构，在数据表中增加了多余的数据信息。如果在这张表的基础上进行其他统计分析，还得剔除这些多余的数据信息，增加不必要的工作量。","categories":[{"name":"数据分析","slug":"数据分析","permalink":"http://yinzhm.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}],"tags":[{"name":"数据分析","slug":"数据分析","permalink":"http://yinzhm.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"EXCEL","slug":"EXCEL","permalink":"http://yinzhm.gitee.io/tags/EXCEL/"}]},{"title":"MySQL知识点大全","slug":"MySQL学习笔记","date":"2023-03-12T12:47:47.000Z","updated":"2023-03-28T13:05:16.953Z","comments":true,"path":"2023/03/12/MySQL学习笔记/","link":"","permalink":"http://yinzhm.gitee.io/2023/03/12/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"数据操作语言 - DMLDML（Data Manipulation Language）： 数据操纵语句，用于添加、删除、更新和查询数据库记录，并检查数据完整性。 常用的语句关键字主要包括INSERT、DELET、UPDATE 和SELECT 等。 非符号类型的运算符 在 SQL 中所有的逻辑运算符： 运算符 描述 ALL ALL运算符用于将值与另一个值集中的所有值进行比较。 AND AND运算符允许在SQL语句的WHERE子句中指定多个条件。 ANY ANY运算符用于根据条件将值与列表中的任何适用值进行比较。 BETWEEN BETWEEN运算符用于搜索在给定最小值和最大值内的值。 EXISTS EXISTS运算符用于搜索指定表中是否存在满足特定条件的行。 IN IN运算符用于将值与已指定的文字值列表进行比较。 LIKE LIKE运算符用于使用通配符运算符将值与类似值进行比较。 NOT NOT运算符反转使用它的逻辑运算符的含义。 例如：NOT EXISTS, NOT BETWEEN, NOT IN等等，这是一个否定运算符。 OR OR运算符用于组合SQL语句的WHERE子句中的多个条件。 IS NULL IS NULL运算符用于将值与NULL值进行比较。 UNIQUE UNIQUE运算符搜索指定表的每一行的唯一性(无重复项)。 IS NULL运算符NULL 空值代表丢失的未知数据。 空运算符（IS NULL或者ISNULL(expression)）判断一个值是否为NULL，如果为NULL则返回1，否则返回0。SQL语句示例如下： 1234567mysql&gt; SELECT NULL IS NULL, ISNULL(NULL), ISNULL(&#x27;a&#x27;), 1 IS NULL;+--------------+--------------+-------------+-----------+| NULL IS NULL | ISNULL(NULL) | ISNULL(&#x27;a&#x27;) | 1 IS NULL |+--------------+--------------+-------------+-----------+| 1 | 1 | 0 | 0 |+--------------+--------------+-------------+-----------+1 row in set (0.00 sec) 12345#查询commission_pct等于NULL。比较如下的四种写法SELECT employee_id,commission_pct FROM employees WHERE commission_pct IS NULL;SELECT employee_id,commission_pct FROM employees WHERE commission_pct &lt;=&gt; NULL;SELECT employee_id,commission_pct FROM employees WHERE ISNULL(commission_pct);SELECT employee_id,commission_pct FROM employees WHERE commission_pct = NULL; 123SELECT last_name, manager_idFROM employeesWHERE manager_id IS NULL; IS NOT NULL运算符非空运算符（IS NOT NULL）判断一个值是否不为NULL，如果不为NULL则返回1，否则返回0。SQL语句示例如下： 1234567mysql&gt; SELECT NULL IS NOT NULL, &#x27;a&#x27; IS NOT NULL, 1 IS NOT NULL; +------------------+-----------------+---------------+| NULL IS NOT NULL | &#x27;a&#x27; IS NOT NULL | 1 IS NOT NULL |+------------------+-----------------+---------------+| 0 | 1 | 1 |+------------------+-----------------+---------------+1 row in set (0.01 sec) 1234#查询commission_pct不等于NULLSELECT employee_id,commission_pct FROM employees WHERE commission_pct IS NOT NULL;SELECT employee_id,commission_pct FROM employees WHERE NOT commission_pct &lt;=&gt; NULL;SELECT employee_id,commission_pct FROM employees WHERE NOT ISNULL(commission_pct); LEAST运算符语法格式为：LEAST(值1，值2，…，值n)。其中，“值n”表示参数列表中有n个值。在有两个或多个参数的情况下，返回最小值。 1234567mysql&gt; SELECT LEAST (1,0,2), LEAST(&#x27;b&#x27;,&#x27;a&#x27;,&#x27;c&#x27;), LEAST(1,NULL,2);+---------------+--------------------+-----------------+| LEAST (1,0,2) | LEAST(&#x27;b&#x27;,&#x27;a&#x27;,&#x27;c&#x27;) | LEAST(1,NULL,2) |+---------------+--------------------+-----------------+| 0 | a | NULL |+---------------+--------------------+-----------------+1 row in set (0.00 sec) 由结果可以看到，当参数是整数或者浮点数时，LEAST将返回其中最小的值；当参数为字符串时，返回字母表中顺序最靠前的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。 GREATEST运算符语法格式为：GREATEST(值1，值2，…，值n)。其中，n表示参数列表中有n个值。当有两个或多个参数时，返回值为最大值。假如任意一个自变量为NULL，则GREATEST()的返回值为NULL。 1234567mysql&gt; SELECT GREATEST(1,0,2), GREATEST(&#x27;b&#x27;,&#x27;a&#x27;,&#x27;c&#x27;), GREATEST(1,NULL,2);+-----------------+-----------------------+--------------------+| GREATEST(1,0,2) | GREATEST(&#x27;b&#x27;,&#x27;a&#x27;,&#x27;c&#x27;) | GREATEST(1,NULL,2) |+-----------------+-----------------------+--------------------+| 2 | c | NULL |+-----------------+-----------------------+--------------------+1 row in set (0.00 sec) 由结果可以看到，当参数中是整数或者浮点数时，GREATEST将返回其中最大的值；当参数为字符串时，返回字母表中顺序最靠后的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。 BETWEEN AND运算符BETWEEN运算符使用的格式通常为SELECT D FROM TABLE WHERE C BETWEEN A AND B，此时，当C大于或等于A，并且C小于或等于B时，结果为1，否则结果为0。 1234567mysql&gt; SELECT 1 BETWEEN 0 AND 1, 10 BETWEEN 11 AND 12, &#x27;b&#x27; BETWEEN &#x27;a&#x27; AND &#x27;c&#x27;;+-------------------+----------------------+-------------------------+| 1 BETWEEN 0 AND 1 | 10 BETWEEN 11 AND 12 | &#x27;b&#x27; BETWEEN &#x27;a&#x27; AND &#x27;c&#x27; |+-------------------+----------------------+-------------------------+| 1 | 0 | 1 |+-------------------+----------------------+-------------------------+1 row in set (0.00 sec) 123SELECT last_name, salaryFROM employeesWHERE salary BETWEEN 2500 AND 3500; IN运算符IN运算符用于判断给定的值是否是IN列表中的一个值，如果是则返回1，否则返回0。如果给定的值为NULL，或者IN列表中存在NULL，则结果为NULL。 1234567mysql&gt; SELECT &#x27;a&#x27; IN (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;), 1 IN (2,3), NULL IN (&#x27;a&#x27;,&#x27;b&#x27;), &#x27;a&#x27; IN (&#x27;a&#x27;, NULL);+----------------------+------------+-------------------+--------------------+| &#x27;a&#x27; IN (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;) | 1 IN (2,3) | NULL IN (&#x27;a&#x27;,&#x27;b&#x27;) | &#x27;a&#x27; IN (&#x27;a&#x27;, NULL) |+----------------------+------------+-------------------+--------------------+| 1 | 0 | NULL | 1 |+----------------------+------------+-------------------+--------------------+1 row in set (0.00 sec) 123SELECT employee_id, last_name, salary, manager_idFROM employeesWHERE manager_id IN (100, 101, 201); NOT IN运算符NOT IN运算符用于判断给定的值是否不是IN列表中的一个值，如果不是IN列表中的一个值，则返回1，否则返回0。 1234567mysql&gt; SELECT &#x27;a&#x27; NOT IN (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;), 1 NOT IN (2,3);+--------------------------+----------------+| &#x27;a&#x27; NOT IN (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;) | 1 NOT IN (2,3) |+--------------------------+----------------+| 0 | 1 |+--------------------------+----------------+1 row in set (0.00 sec) LIKE运算符LIKE运算符主要用来匹配字符串，通常用于模糊匹配，如果满足条件则返回1，否则返回0。如果给定的值或者匹配条件为NULL，则返回结果为NULL。 LIKE运算符通常使用如下通配符： 12“%”：匹配0个或多个字符。“_”：只能匹配一个字符。 SQL语句示例如下： 1234567mysql&gt; SELECT NULL LIKE &#x27;abc&#x27;, &#x27;abc&#x27; LIKE NULL; +-----------------+-----------------+| NULL LIKE &#x27;abc&#x27; | &#x27;abc&#x27; LIKE NULL |+-----------------+-----------------+| NULL | NULL |+-----------------+-----------------+1 row in set (0.00 sec) 123SELECT first_nameFROM employeesWHERE first_name LIKE &#x27;S%&#x27;; 123SELECT last_nameFROM employeesWHERE last_name LIKE &#x27;_o%&#x27;; 示例： 语句 描述 WHERE SALARY LIKE ‘200%’ 找出任何以 200 开头的值。 WHERE SALARY LIKE ‘%200%’ 找出任何存在 200 的值。 WHERE SALARY LIKE ‘_00%’ 找出任何第二个位置和第三个位置为 0 的值。 WHERE SALARY LIKE ‘2_%_%’ 找出任何以 2 开始，并且长度至少为 3 的值。 WHERE SALARY LIKE ‘%2’ 找出任何以 2 结尾的值。 WHERE SALARY LIKE ‘_2%3’ 找出任何第二个位置为 2，并且以 3 结束的值。 WHERE SALARY LIKE ‘2___3’ 找出任何以 2 开始，以 3 结束的五位数。 ESCAPE运算符回避特殊符号的：使用转义符。例如，escape指定字符$，$字符后面的第一个字符_被认为是普通字符 使用转义字符 123SELECT job_idFROM jobsWHERE job_id LIKE ‘IT\\_%‘; 使用ESCAPE运算符 123SELECT job_idFROM jobsWHERE job_id LIKE ‘IT$_%‘ escape ‘$‘; REGEXP运算符REGEXP运算符用来匹配字符串，语法格式为：expr REGEXP 匹配条件。如果expr满足匹配条件，返回1；如果不满足，则返回0。若expr或匹配条件任意一个为NULL，则结果为NULL。 REGEXP运算符在进行匹配时，常用的有下面几种通配符： 12345（1）‘^’匹配以该字符后面的字符开头的字符串。（2）‘$’匹配以该字符前面的字符结尾的字符串。（3）‘.’匹配任何一个单字符。（4）“[...]”匹配在方括号内的任何字符。例如，“[abc]”匹配“a”或“b”或“c”。为了命名字符的范围，使用一个‘-’。“[a-z]”匹配任何字母，而“[0-9]”匹配任何数字。（5）‘*’匹配零个或多个在它前面的字符。例如，“x*”匹配任何数量的‘x’字符，“[0-9]*”匹配任何数量的数字，而“*”匹配任何数量的任何字符。 SQL语句示例如下： 1234567mysql&gt; SELECT &#x27;shkstart&#x27; REGEXP &#x27;^s&#x27;, &#x27;shkstart&#x27; REGEXP &#x27;t$&#x27;, &#x27;shkstart&#x27; REGEXP &#x27;hk&#x27;;+------------------------+------------------------+-------------------------+| &#x27;shkstart&#x27; REGEXP &#x27;^s&#x27; | &#x27;shkstart&#x27; REGEXP &#x27;t$&#x27; | &#x27;shkstart&#x27; REGEXP &#x27;hk&#x27; |+------------------------+------------------------+-------------------------+| 1 | 1 | 1 |+------------------------+------------------------+-------------------------+1 row in set (0.01 sec) 1234567mysql&gt; SELECT &#x27;atguigu&#x27; REGEXP &#x27;gu.gu&#x27;, &#x27;atguigu&#x27; REGEXP &#x27;[ab]&#x27;;+--------------------------+-------------------------+| &#x27;atguigu&#x27; REGEXP &#x27;gu.gu&#x27; | &#x27;atguigu&#x27; REGEXP &#x27;[ab]&#x27; |+--------------------------+-------------------------+| 1 | 1 |+--------------------------+-------------------------+1 row in set (0.00 sec) DESCRIBE - 显示表结构信息使用DESCRIBE 或 DESC 命令，显示表结构。 123DESCRIBE employees;或DESC employees; 1234567891011121314151617mysql&gt; desc employees;+----------------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------------+-------------+------+-----+---------+-------+| employee_id | int(6) | NO | PRI | 0 | || first_name | varchar(20) | YES | | NULL | || last_name | varchar(25) | NO | | NULL | || email | varchar(25) | NO | UNI | NULL | || phone_number | varchar(20) | YES | | NULL | || hire_date | date | NO | | NULL | || job_id | varchar(10) | NO | MUL | NULL | || salary | double(8,2) | YES | | NULL | || commission_pct | double(2,2) | YES | | NULL | || manager_id | int(6) | YES | MUL | NULL | || department_id | int(4) | YES | MUL | NULL | |+----------------+-------------+------+-----+---------+-------+11 rows in set (0.00 sec) 其中，各个字段的含义分别解释如下： Field：表示字段名称。 Type：表示字段类型，这里 barcode、goodsname 是文本型的，price 是整数类型的。 Null：表示该列是否可以存储NULL值。 Key：表示该列是否已编制索引。PRI表示该列是表主键的一部分；UNI表示该列是UNIQUE索引的一部分；MUL表示在列中某个给定值允许出现多次。 Default：表示该列是否有默认值，如果有，那么值是多少。 Extra：表示可以获取的与给定列有关的附加信息，例如AUTO_INCREMENT等。 SELECT - 选取数据基本语法 语法12SELECT 列名称（标识选择哪些列）FROM 表名称（标识从哪个表中选择） 以及 12SELECT *FROM 表名称; 一般情况下，除非需要使用表中所有的字段数据，最好不要使用通配符‘*’。使用通配符虽然可以节省输入查询语句的时间，但是获取不需要的列数据通常会降低查询和所使用的应用程序的效率。通配符的优势是，当不知道所需要的列的名称时，可以通过它获取它们。 在生产环境下，不推荐直接使用SELECT *进行查询。 举例： 12SELECT department_id, location_idFROM departments; DISTINCT - 去除重复行默认情况下，查询会返回全部行，包括重复行。 12SELECT department_idFROM employees; 在SELECT语句中使用关键字DISTINCT去除重复行 12SELECT DISTINCT department_idFROM employees; 注意： DISTINCT 需要放到所有列名的前面，如果写成SELECT salary, DISTINCT department_id FROM employees会报错。 DISTINCT 其实是对后面所有列名的组合进行去重，你能看到最后的结果是 74 条，因为这 74 个部门id不同，都有 salary 这个属性值。如果你想要看都有哪些不同的部门（department_id），只需要写DISTINCT department_id即可，后面不需要再加其他的列名了。 空值参与运算 所有运算符或列值遇到null值，运算的结果都为null 123SELECT employee_id,salary,commission_pct,12 * salary * (1 + commission_pct) &quot;annual_sal&quot;FROM employees; 这里一定要注意，在 MySQL 里面， 空值不等于空字符串。一个空字符串的长度是 0，而一个空值的长度是空。而且，在 MySQL 里面，空值是占用空间的。 查询常数SELECT 查询还可以对常数进行查询。对的，就是在 SELECT 查询结果中增加一列固定的常数列。这列的取值是我们指定的，而不是从数据表中动态取出的。 你可能会问为什么我们还要对常数进行查询呢？ SQL 中的 SELECT 语法的确提供了这个功能，一般来说我们只从一个表中查询数据，通常不需要增加一个固定的常数列，但如果我们想整合不同的数据源，用常数列作为这个表的标记，就需要查询常数。 比如说，我们想对 employees 数据表中的员工姓名进行查询，同时增加一列字段corporation，这个字段固定值为“阿里巴巴”，可以这样写： 1SELECT &#x27;阿里巴巴&#x27; as corporation, last_name FROM employees; 着重号 - 字段名与保留字段冲突 错误的 12mysql&gt; SELECT * FROM ORDER;ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;ORDER&#x27; at line 1 正确的 123456789mysql&gt; SELECT * FROM `ORDER`;+----------+------------+| order_id | order_name |+----------+------------+| 1 | shkstart || 2 | tomcat || 3 | dubbo |+----------+------------+3 rows in set (0.00 sec) 结论 我们需要保证表中的字段、表名等没有和保留字、数据库系统或常用方法冲突。如果真的相同，请在SQL语句中使用一对``（着重号）引起来。 AS - 列/表的别名（ALIAS） 重命名一个列或表 便于计算 紧跟列/表名，也可以在列/表名和别名之间加入关键字AS，别名使用双引号，以便在别名中包含空格或特殊的字符并区分大小写。 AS 可以省略，最好别省略 建议别名简短，见名知意 举例： 12SELECT last_name AS name, commission_pct commFROM employees; 12SELECT last_name &quot;Name&quot;, salary*12 &quot;Annual Salary&quot;FROM employees; 123SELECT column_name(s)FROM table_nameAS alias_name WHERE - 过滤数据使用WHERE 子句，将不满足条件的行过滤掉 WHERE子句紧随 FROM子句 语法： 123SELECT 列名称1,列名称2FROM 表名称WHERE 过滤条件 举例：123SELECT employee_id, last_name, job_id, department_idFROM employeesWHERE department_id = 90 ; WHERE 子句中的运算符 运算符 描述 = 等于 &lt;&gt; 不等于。 注意：在某些版本的SQL中，这个操作符可能写成!= &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 BETWEEN 在某个范围内 LIKE 搜索某种模式 ORDER BY - 按关键词排序 ORDER BY 关键字用于按升序或降序对结果集进行排序。 ORDER BY 关键字默认情况下按升序排序记录。 使用 ORDER BY 子句排序 ASC（ascend）: 升序（默认） DESC（descend）: 降序 ORDER BY 子句在SELECT语句的结尾。 可以使用不在SELECT列表中的列排序。 在对多列进行排序的时候，首先排序的第一列必须有相同的列值，才会对第二列进行排序。如果第一列数据中所有值都是唯一的，将不再对第二列进行排序。 单列排序： 123SELECT last_name, job_id, department_id, hire_dateFROM employeesORDER BY hire_date ; 123SELECT last_name, job_id, department_id, hire_dateFROM employeesORDER BY hire_date DESC ; 123SELECT employee_id, last_name, salary*12 annsalFROM employeesORDER BY annsal; 多列排序： 先按部门ID降序排列，再按工资升序排列。 123SELECT last_name, department_id, salaryFROM employeesORDER BY department_id DESC, salary ASC; LIMIT - 分页显示所谓分页显示，就是将数据库中的结果集，一段一段显示出来需要的条件。 MySQL中使用 LIMIT 实现分页 格式： 1LIMIT [位置偏移量,] 行数 第一个“位置偏移量”参数指示MySQL从哪一行开始显示，是一个可选参数，如果不指定“位置偏移量”，将会从表中的第一条记录开始（第一条记录的位置偏移量是0，第二条记录的位置偏移量是1，以此类推）； 第二个参数“行数”指示返回的记录条数。 举例 12345678910--前10条记录：SELECT * FROM 表名 LIMIT 0,10;或者SELECT * FROM 表名 LIMIT 10;--第11至20条记录：SELECT * FROM 表名 LIMIT 10,10;--第21至30条记录： SELECT * FROM 表名 LIMIT 20,10; MySQL 8.0中可以使用“LIMIT 3 OFFSET 4”，意思是获取从第5条记录开始后面的3条记录，和“LIMIT 4,3;”返回的结果相同。 分页显式公式：（当前页数-1）*每页条数，每页条数 12SELECT * FROM table LIMIT(PageNo - 1)*PageSize,PageSize; 注意：LIMIT 子句必须放在整个SELECT语句的最后！ 使用 LIMIT 的好处 约束返回结果的数量可以减少数据表的网络传输量，也可以提升查询效率。如果我们知道返回结果只有 1 条，就可以使用LIMIT 1，告诉 SELECT 语句只需要返回一条记录即可。这样的好处就是 SELECT 不需要扫描完整的表，只需要检索到一条符合条件的记录即可返回。 2.3 拓展在不同的 DBMS 中使用的关键字可能不同。在 MySQL、PostgreSQL、MariaDB 和 SQLite 中使用 LIMIT 关键字，而且需要放到 SELECT 语句的最后面。 如果是 SQL Server 和 Access，需要使用 TOP 关键字，比如： 1SELECT TOP 5 name, hp_max FROM heros ORDER BY hp_max DESC 如果是 DB2，使用FETCH FIRST 5 ROWS ONLY这样的关键字： 1SELECT name, hp_max FROM heros ORDER BY hp_max DESC FETCH FIRST 5 ROWS ONLY 如果是 Oracle，你需要基于 ROWNUM 来统计行数： 1SELECT rownum,last_name,salary FROM employees WHERE rownum &lt; 5 ORDER BY salary DESC; 需要说明的是，这条语句是先取出来前 5 条数据行，然后再按照 hp_max 从高到低的顺序进行排序。但这样产生的结果和上述方法的并不一样。我会在后面讲到子查询，你可以使用 123456SELECT rownum, last_name,salaryFROM ( SELECT last_name,salary FROM employees ORDER BY salary DESC)WHERE rownum &lt; 10; 得到与上述方法一致的结果。 多表连接分类等值连接 vs 非等值连接等值连接 12345SELECT employees.employee_id, employees.last_name, employees.department_id, departments.department_id, departments.location_idFROM employees, departmentsWHERE employees.department_id = departments.department_id; 区分重复的列名 多个表中有相同列时，必须在列名之前加上表名前缀。 在不同表中具有相同列名的列可以用表名加以区分。 123SELECT employees.last_name, departments.department_name,employees.department_idFROM employees, departmentsWHERE employees.department_id = departments.department_id; 表的别名 使用别名可以简化查询。 列名前使用表名前缀可以提高查询效率。 1234SELECT e.employee_id, e.last_name, e.department_id, d.department_id, d.location_idFROM employees e , departments dWHERE e.department_id = d.department_id; 需要注意的是，如果我们使用了表的别名，在查询字段中、过滤条件中就只能使用别名进行代替，不能使用原有的表名，否则就会报错。 阿里开发规范： 【强制】对于数据库中表记录的查询和变更，只要涉及多个表，都需要在列名前加表的别名（或 表名）进行限定。 说明：对多表进行查询记录、更新记录、删除记录时，如果对操作列没有限定表的别名（或表名），并且操作列在多个表中存在时，就会抛异常。 正例：select t1.name from table_first as t1 , table_second as t2 where t1.id=t2.id; 反例：在某业务中，由于多表关联查询语句没有加表的别名（或表名）的限制，正常运行两年后，最近在 某个表中增加一个同名字段，在预发布环境做数据库变更后，线上查询语句出现出 1052 异常：Column ‘name’ in field list is ambiguous。 非等值连接 123SELECT e.last_name, e.salary, j.grade_levelFROM employees e, job_grades jWHERE e.salary BETWEEN j.lowest_sal AND j.highest_sal; 自连接 vs 非自连接 自连接：当table1和table2本质上是同一张表，只是用取别名的方式虚拟成两张表以代表不同的意义。然后两个表再进行内连接，外连接等查询。 示例：查询employees表，返回“Xxx works for Xxx” 123456SELECT CONCAT( worker.last_name , &#x27; works for &#x27; , manager.last_name)FROM employees AS worker, employees AS managerWHERE worker.manager_id = manager.employee_id ; 内连接 vs 外连接除了查询满足条件的记录以外，外连接还可以查询某一方不满足条件的记录。 内连接: 合并具有同一列的两个以上的表的行, 结果集中不包含一个表与另一个表不匹配的行。 外连接: 两个表在连接过程中除了返回满足连接条件的行以外还返回左（或右）表中不满足条件的行 ，这种连接称为左（或右） 外连接。没有匹配的行时, 结果表中相应的列为空(NULL)。 如果是左外连接，则连接条件中左边的表也称为主表，右边的表称为从表。 如果是右外连接，则连接条件中右边的表也称为主表，左边的表称为从表。 SQL92：使用(+)创建连接 在 SQL92 中采用（+）代表从表所在的位置。即左或右外连接中，(+) 表示哪个是从表。 Oracle 对 SQL92 支持较好，而 MySQL 则不支持 SQL92 的外连接。 在 SQL92 中，只有左外连接和右外连接，没有满（或全）外连接。 123456789#左外连接SELECT last_name,department_nameFROM employees ,departmentsWHERE employees.department_id = departments.department_id(+);#右外连接SELECT last_name,department_nameFROM employees ,departmentsWHERE employees.department_id(+) = departments.department_id; 多表连接查询基本语法 使用JOIN…ON子句创建连接的语法结构： 1234SELECT table1.column, table2.column,table3.columnFROM table1 JOIN table2 ON table1 和 table2 的连接条件 JOIN table3 ON table2 和 table3 的连接条件 它的嵌套逻辑类似我们使用的 FOR 循环： 123456for t1 in table1: for t2 in table2: if condition1: for t3 in table3: if condition2: output t1 + t2 + t3 语法说明： 可以使用 ON 子句指定额外的连接条件。 这个连接条件是与其它条件分开的。 ON 子句使语句具有更高的易读性。 关键字 JOIN、INNER JOIN、CROSS JOIN 的含义是一样的，都表示内连接 INNER JOIN - 内连接 语法： 1234SELECT 列名FROM 表名1 INNER JOIN 表名2ON 关联条件WHERE 等其他子句; 示例： 1234SELECT e.employee_id, e.last_name, e.department_id, d.department_id, d.location_idFROM employees e JOIN departments dON (e.department_id = d.department_id); 题目2： 123456SELECT employee_id, city, department_nameFROM employees e JOIN departments dON d.department_id = e.department_id JOIN locations lON d.location_id = l.location_id; OUTER JOIN - 外连接LEFT OUTER JOIN - 左外连接 语法： 12345#实现查询结果是ASELECT 字段列表FROM A表 LEFT JOIN B表ON 关联条件WHERE 等其他子句; 举例： 1234SELECT e.last_name, e.department_id, d.department_nameFROM employees eLEFT OUTER JOIN departments dON (e.department_id = d.department_id) ; RIGHT OUTER JOIN - 右外连接 语法： 12345#实现查询结果是BSELECT 字段列表FROM A表 RIGHT JOIN B表ON 关联条件WHERE 等其他子句; 举例： 1234SELECT e.last_name, e.department_id, d.department_nameFROM employees eRIGHT OUTER JOIN departments dON (e.department_id = d.department_id) ; 需要注意的是，LEFT JOIN 和 RIGHT JOIN 只存在于 SQL99 及以后的标准中，在 SQL92 中不存在，只能用 (+) 表示。 FULL OUTER JOIN - 完全外连接 完全外连接的结果 = 左右表匹配的数据 + 左表没有匹配到的数据 + 右表没有匹配到的数据。 SQL99是支持完全外连接的。使用FULL JOIN 或 FULL OUTER JOIN来实现。 MySQL不支持FULL JOIN，但是可以用 LEFT JOIN UNION RIGHT join代替。 UNION - 合并结果集合并查询结果 利用UNION关键字，可以给出多条SELECT语句，并将它们的结果组合成单个结果集。 合并时，两个表对应的列数和数据类型必须相同，并且相互对应。各个SELECT语句之间使用UNION或UNION ALL关键字分隔。 语法格式： 123SELECT column,... FROM table1UNION [ALL]SELECT column,... FROM table2 UNION操作符 UNION 操作符返回两个查询的结果集的并集，去除重复记录。 UNION ALL操作符 UNION ALL操作符返回两个查询的结果集的并集。对于两个结果集的重复部分，不去重。 注意：执行UNION ALL语句时所需要的资源比UNION语句少。如果明确知道合并数据后的结果数据不存在重复数据，或者不需要去除重复的数据，则尽量使用UNION ALL语句，以提高数据查询的效率。 举例：查询部门编号&gt;90或邮箱包含a的员工信息 123#方式1SELECT * FROM employees WHERE email LIKE &#x27;%a%&#x27; OR department_id&gt;90; 123456#方式2SELECT * FROM employees WHERE email LIKE &#x27;%a%&#x27;UNIONSELECT * FROM employees WHERE department_id&gt;90; 举例：查询中国用户中男性的信息以及美国用户中年男性的用户信息 12345SELECT id,cname FROM t_chinamale WHERE csex=&#x27;男&#x27;UNION ALLSELECT id,tname FROM t_usmale WHERE tGender=&#x27;male&#x27;; 7种SQL连接的实现 代码实现1234#中图：内连接 A∩BSELECT employee_id,last_name,department_nameFROM employees e JOIN departments dON e.`department_id` = d.`department_id`; 1234#左上图：左外连接SELECT employee_id,last_name,department_nameFROM employees e LEFT JOIN departments dON e.`department_id` = d.`department_id`; 1234#右上图：右外连接SELECT employee_id,last_name,department_nameFROM employees e RIGHT JOIN departments dON e.`department_id` = d.`department_id`; 12345#左中图：A - A∩BSELECT employee_id,last_name,department_nameFROM employees e LEFT JOIN departments dON e.`department_id` = d.`department_id`WHERE d.`department_id` IS NULL 12345#右中图：B-A∩BSELECT employee_id,last_name,department_nameFROM employees e RIGHT JOIN departments dON e.`department_id` = d.`department_id`WHERE e.`department_id` IS NULL 12345678910#左下图：满外连接# 左中图 + 右上图 A∪BSELECT employee_id,last_name,department_nameFROM employees e LEFT JOIN departments dON e.`department_id` = d.`department_id`WHERE d.`department_id` IS NULLUNION ALL #没有去重操作，效率高SELECT employee_id,last_name,department_nameFROM employees e RIGHT JOIN departments dON e.`department_id` = d.`department_id`; 1234567891011#右下图#左中图 + 右中图 A ∪B- A∩B 或者 (A - A∩B) ∪ （B - A∩B）SELECT employee_id,last_name,department_nameFROM employees e LEFT JOIN departments dON e.`department_id` = d.`department_id`WHERE d.`department_id` IS NULLUNION ALLSELECT employee_id,last_name,department_nameFROM employees e RIGHT JOIN departments dON e.`department_id` = d.`department_id`WHERE e.`department_id` IS NULL 自然连接SQL99 在 SQL92 的基础上提供了一些特殊语法，比如 NATURAL JOIN 用来表示自然连接。我们可以把自然连接理解为 SQL92 中的等值连接。它会帮你自动查询两张连接表中所有相同的字段，然后进行等值连接。 在SQL92中： 1234SELECT employee_id,last_name,department_nameFROM employees e JOIN departments dON e.`department_id` = d.`department_id`AND e.`manager_id` = d.`manager_id`; 在 SQL99 中： 12SELECT employee_id,last_name,department_nameFROM employees e NATURAL JOIN departments d; USING - 等值连接当我们进行连接的时候，SQL99支持使用 USING 指定数据表里的同名字段进行等值连接。但是只能配合JOIN一起使用。 举例： 与自然连接 NATURAL JOIN 不同的是，USING 指定了具体的相同的字段名称，需要在 USING 的括号 () 中填入要指定的同名字段。 同时使用 JOIN...USING 可以简化 JOIN ON 的等值连接。它与下面的 SQL 查询结果是相同的： 123SELECT employee_id,last_name,department_nameFROM employees e JOIN departments dUSING (department_id); 123SELECT employee_id,last_name,department_nameFROM employees e ,departments dWHERE e.department_id = d.department_id; 表连接的约束条件可以有三种方式：WHERE, ON, USING WHERE：适用于所有关联查询 ON：只能和JOIN一起使用，只能写关联条件。虽然关联条件可以并到WHERE中和其他条件一起写，但分开写可读性更好。 USING：只能和JOIN一起使用，而且要求两个关联字段在关联表中名称一致，而且只能表示关联字段值相等。 1234567891011121314151617181920212223242526272829303132333435#关联条件#把关联条件写在where后面SELECT last_name,department_name FROM employees,departments WHERE employees.department_id = departments.department_id;#把关联条件写在on后面，只能和JOIN一起使用SELECT last_name,department_name FROM employees INNER JOIN departments ON employees.department_id = departments.department_id;SELECT last_name,department_name FROM employees CROSS JOIN departments ON employees.department_id = departments.department_id;SELECT last_name,department_name FROM employees JOIN departments ON employees.department_id = departments.department_id;#把关联字段写在using()中，只能和JOIN一起使用#而且两个表中的关联字段必须名称相同，而且只能表示=#查询员工姓名与基本工资SELECT last_name,job_titleFROM employees INNER JOIN jobs USING(job_id);#n张表关联，需要n-1个关联条件#查询员工姓名，基本工资，部门名称SELECT last_name,job_title,department_name FROM employees,departments,jobs WHERE employees.department_id = departments.department_id AND employees.job_id = jobs.job_id;SELECT last_name,job_title,department_name FROM employees INNER JOIN departments INNER JOIN jobs ON employees.department_id = departments.department_id AND employees.job_id = jobs.job_id; 注意： 我们要控制连接表的数量。多表连接就相当于嵌套 for 循环一样，非常消耗资源，会让 SQL 查询性能下降得很严重，因此不要连接不必要的表。在许多 DBMS 中，也都会有最大连接表的限制。 【强制】超过三个表禁止 join。需要 join 的字段，数据类型保持绝对一致；多表关联查询时， 保证被关联的字段需要有索引。 说明：即使双表 join 也要注意表索引、SQL 性能。 来源：阿里巴巴《Java开发手册》 GROUP BY基本使用GROUP BY语句通常与聚合函数（COUNT，MAX，MIN，SUM，AVG）一起使用，以按一个或多个列对结果集进行分组。 语法： 12345SELECT column, group_function(column)FROM table[WHERE condition][GROUP BY group_by_expression][ORDER BY column]; 明确：WHERE一定放在FROM后面 在SELECT列表中所有未包含在聚合函数中的列都应该包含在 GROUP BY子句中 123SELECT department_id, AVG(salary)FROM employeesGROUP BY department_id ; 包含在 GROUP BY 子句中的列不必包含在SELECT 列表中 123SELECT AVG(salary)FROM employeesGROUP BY department_id ; 使用多个列分组 123SELECT department_id dept_id, job_id, SUM(salary)FROM employeesGROUP BY department_id, job_id ; WITH ROLLUP使用WITH ROLLUP关键字之后，在所有查询出的分组记录之后增加一条记录，该记录计算查询出的所有记录的总和，即统计记录数量。 1234SELECT department_id,AVG(salary)FROM employeesWHERE department_id &gt; 80GROUP BY department_id WITH ROLLUP; 注意： 当使用ROLLUP时，不能同时使用ORDER BY子句进行结果排序，即ROLLUP和ORDER BY是互相排斥的。 HAVING基本使用HAVING 子句使你能够指定过滤条件，从而控制查询结果中哪些组可以出现在最终结果里面。 HAVING 不能单独使用，必须要跟 GROUP BY 一起使用。 在HAVING子句中可以使用聚合函数。 1234SELECT department_id, MAX(salary)FROM employeesGROUP BY department_idHAVING MAX(salary)&gt;10000 ; 非法使用聚合函数 ：不能在 WHERE 子句中使用聚合函数。 错误示例： 1234SELECT department_id, AVG(salary)FROM employeesWHERE AVG(salary) &gt; 8000GROUP BY department_id; WHERE和HAVING的对比区别1： WHERE 可以直接使用表中的字段作为筛选条件，但不能使用分组中的计算函数作为筛选条件； HAVING 必须要与 GROUP BY 配合使用，可以把分组计算的函数和分组字段作为筛选条件。 在需要对数据进行分组统计的时候，HAVING 可以完成 WHERE 不能完成的任务。这是因为，在查询语法结构中，WHERE 在 GROUP BY 之前，所以无法对分组结果进行筛选。HAVING 在 GROUP BY 之后，可以使用分组字段和分组中的计算函数，对分组的结果集进行筛选，这个功能是 WHERE 无法完成的。另外，WHERE排除的记录不再包括在分组中。 区别2： 如果需要通过连接从关联表中获取需要的数据，WHERE 是先筛选后连接，而 HAVING 是先连接后筛选。 在关联查询中，WHERE 比 HAVING 更高效。因为 WHERE 可以先筛选，用一个筛选后的较小数据集和关联表进行连接，这样占用的资源比较少，执行效率也比较高。HAVING 则需要先把结果集准备好，也就是用未被筛选的数据集进行关联，然后对这个大的数据集进行筛选，这样占用的资源就比较多，执行效率也较低。 总结： 优点 缺点 WHERE 先筛选数据再关联，执行效率高 不能使用分组中的计算函数进行筛选 HAVING 可以使用分组中的计算函数 在最后的结果集中进行筛选，执行效率较低 开发中的选择： WHERE 和 HAVING 也不是互相排斥的，我们可以在一个查询里面同时使用 WHERE 和 HAVING。包含分组统计函数的条件用 HAVING，普通条件用 WHERE。这样，我们就既利用了 WHERE 条件的高效快速，又发挥了 HAVING 可以使用包含分组统计函数的查询条件的优点。当数据量特别大的时候，运行效率会有很大的差别。 多行比较操作符 操作符 含义 IN 等于列表中的任意一个 ANY 需要和单行比较操作符一起使用，用于将一个值同条件所指定的列表中的任意值相比较。 ALL 需要和单行比较操作符一起使用，用于将一个值同另一个值集中所有的值进行比较。 SOME 实际上是ANY的别名，作用相同，一般常使用ANY 代码示例 返回其它job_id中比job_id为‘IT_PROG’部门任一工资低的员工的员工号、姓名、job_id 以及salary 返回其它job_id中比job_id为‘IT_PROG’部门所有工资都低的员工的员工号、姓名、job_id以及salary 示例：查询平均工资最低的部门id 123456789101112#方式1：SELECT department_idFROM employeesGROUP BY department_idHAVING AVG(salary) = ( SELECT MIN(avg_sal) FROM ( SELECT AVG(salary) avg_sal FROM employees GROUP BY department_id ) dept_avg_sal ) 123456789#方式2：SELECT department_idFROM employeesGROUP BY department_idHAVING AVG(salary) &lt;= ALL ( SELECT AVG(salary) avg_sal FROM employees GROUP BY department_id) 数据增删改 插入数据方式1：VALUES的方式添加使用这种语法一次只能向表中插入一条数据。 情况1：为表的所有字段按默认顺序插入数据 12INSERT INTO 表名VALUES (value1,value2,....); 值列表中需要为表的每一个字段指定值，并且值的顺序必须和数据表中字段定义时的顺序相同。 举例： 12INSERT INTO departmentsVALUES (70, &#x27;Pub&#x27;, 100, 1700); 12INSERT INTO departmentsVALUES (100, &#x27;Finance&#x27;, NULL, NULL); 情况2：为表的指定字段插入数据 12INSERT INTO 表名(column1 [, column2, …, columnn]) VALUES (value1 [,value2, …, valuen]); 为表的指定字段插入数据，就是在INSERT语句中只向部分字段中插入值，而其他字段的值为表定义时的默认值。 在 INSERT 子句中随意列出列名，但是一旦列出，VALUES中要插入的value1,….valuen需要与column1,…columnn列一一对应。如果类型不同，将无法插入，并且MySQL会产生错误。 举例： 12INSERT INTO departments(department_id, department_name)VALUES (80, &#x27;IT&#x27;); 情况3：同时插入多条记录 INSERT语句可以同时向数据表中插入多条记录，插入时指定多个值列表，每个值列表之间用逗号分隔开，基本语法格式如下： 123456INSERT INTO table_name VALUES (value1 [,value2, …, valuen]),(value1 [,value2, …, valuen]),……(value1 [,value2, …, valuen]); 或者 123456INSERT INTO table_name(column1 [, column2, …, columnn]) VALUES (value1 [,value2, …, valuen]),(value1 [,value2, …, valuen]),……(value1 [,value2, …, valuen]); 举例： 123456mysql&gt; INSERT INTO emp(emp_id,emp_name) -&gt; VALUES (1001,&#x27;shkstart&#x27;), -&gt; (1002,&#x27;atguigu&#x27;), -&gt; (1003,&#x27;Tom&#x27;);Query OK, 3 rows affected (0.00 sec)Records: 3 Duplicates: 0 Warnings: 0 使用INSERT同时插入多条记录时，MySQL会返回一些在执行单行插入时没有的额外信息，这些信息的含义如下：● Records：表明插入的记录条数。● Duplicates：表明插入时被忽略的记录，原因可能是这些记录包含了重复的主键值。● Warnings：表明有问题的数据值，例如发生数据类型转换。 一个同时插入多行记录的INSERT语句等同于多个单行插入的INSERT语句，但是多行的INSERT语句在处理过程中效率更高。因为MySQL执行单条INSERT语句插入多行数据比使用多条INSERT语句快，所以在插入多条记录时最好选择使用单条INSERT语句的方式插入。 小结： VALUES也可以写成VALUE，但是VALUES是标准写法。 字符和日期型数据应包含在单引号中。 方式2：将查询结果插入到表中INSERT还可以将SELECT语句查询的结果插入到表中，此时不需要把每一条记录的值一个一个输入，只需要使用一条INSERT语句和一条SELECT语句组成的组合语句即可快速地从一个或多个表中向一个表中插入多行。 基本语法格式如下： 123456INSERT INTO 目标表名(tar_column1 [, tar_column2, …, tar_columnn])SELECT(src_column1 [, src_column2, …, src_columnn])FROM 源表名[WHERE condition] 在 INSERT 语句中加入子查询。 不必书写 VALUES 子句。 子查询中的值列表应与 INSERT 子句中的列名对应。 举例： 1234INSERT INTO emp2 SELECT * FROM employeesWHERE department_id = 90; 1234INSERT INTO sales_reps(id, name, salary, commission_pct)SELECT employee_id, last_name, salary, commission_pctFROM employeesWHERE job_id LIKE &#x27;%REP%&#x27;; 更新数据 使用 UPDATE 语句更新数据。语法如下： 123UPDATE table_nameSET column1=value1, column2=value2, … , column=valuen[WHERE condition] 可以一次更新多条数据。 如果需要回滚数据，需要保证在DML前，进行设置：SET AUTOCOMMIT = FALSE; 使用 WHERE 子句指定需要更新的数据。 123UPDATE employeesSET department_id = 70WHERE employee_id = 113; 如果省略 WHERE 子句，则表中的所有数据都将被更新。 12UPDATE copy_empSET department_id = 110; 更新中的数据完整性错误 123UPDATE employeesSET department_id = 55WHERE department_id = 110; 说明：不存在 55 号部门 删除数据 使用 DELETE 语句从表中删除数据 1DELETE FROM table_name [WHERE &lt;condition&gt;]; table_name指定要执行删除操作的表；“[WHERE ]”为可选参数，指定删除条件，如果没有WHERE子句，DELETE语句将删除表中的所有记录。 使用 WHERE 子句删除指定的记录。 12DELETE FROM departmentsWHERE department_name = &#x27;Finance&#x27;; 如果省略 WHERE 子句，则表中的全部数据将被删除 1DELETE FROM copy_emp; 删除中的数据完整性错误 12DELETE FROM departmentsWHERE department_id = 60; 说明：You cannot delete a row that contains a primary key that is used as a foreign key in another table. MySQL8新特性：计算列什么叫计算列呢？简单来说就是某一列的值是通过别的列计算得来的。例如，a列值为1、b列值为2，c列不需要手动插入，定义a+b的结果为c的值，那么c就是计算列，是通过别的列计算得来的。 在MySQL 8.0中，CREATE TABLE 和 ALTER TABLE 中都支持增加计算列。下面以CREATE TABLE为例进行讲解。 举例：定义数据表tb1，然后定义字段id、字段a、字段b和字段c，其中字段c为计算列，用于计算a+b的值。首先创建测试表tb1，语句如下： 123456CREATE TABLE tb1(id INT,a INT,b INT,c INT GENERATED ALWAYS AS (a + b) VIRTUAL); 插入演示数据，语句如下： 1INSERT INTO tb1(a,b) VALUES (100,200); 查询数据表tb1中的数据，结果如下： 1234567mysql&gt; SELECT * FROM tb1;+------+------+------+------+| id | a | b | c |+------+------+------+------+| NULL | 100 | 200 | 300 |+------+------+------+------+1 row in set (0.00 sec) 更新数据中的数据，语句如下： 123mysql&gt; UPDATE tb1 SET a = 500;Query OK, 0 rows affected (0.00 sec)Rows matched: 1 Changed: 0 Warnings: 0 综合案例123# 1、创建数据库test01_library# 2、创建表 books，表结构如下： 字段名 字段说明 数据类型 id 书编号 INT name 书名 VARCHAR(50) authors 作者 VARCHAR(100) price 价格 FLOAT pubdate 出版日期 YEAR note 说明 VARCHAR(100) num 库存 INT 12345# 3、向books表中插入记录# 1）不指定字段名称，插入第一条记录# 2）指定所有字段名称，插入第二记录# 3）同时插入多条记录（剩下的所有记录） id name authors price pubdate note num 1 Tal of AAA Dickes 23 1995 novel 11 2 EmmaT Jane lura 35 1993 joke 22 3 Story of Jane Jane Tim 40 2001 novel 0 4 Lovey Day George Byron 20 2005 novel 30 5 Old land Honore Blade 30 2010 law 0 6 The Battle Upton Sara 30 1999 medicine 40 7 Rose Hood Richard haggard 28 2008 cartoon 28 12345# 4、将小说类型(novel)的书的价格都增加5。# 5、将名称为EmmaT的书的价格改为40，并将说明改为drama。# 6、删除库存为0的记录。 123456789101112131415161718192021222324252627282930313233# 7、统计书名中包含a字母的书# 8、统计书名中包含a字母的书的数量和库存总量# 9、找出“novel”类型的书，按照价格降序排列# 10、查询图书信息，按照库存量降序排列，如果库存量相同的按照note升序排列# 11、按照note分类统计书的数量# 12、按照note分类统计书的库存量，显示库存量超过30本的# 13、查询所有图书，每页显示5本，显示第二页# 14、按照note分类统计书的库存量，显示库存量最多的# 15、查询书名达到10个字符的书，不包括里面的空格# 16、查询书名和类型，其中note值为novel显示小说，law显示法律，medicine显示医药，cartoon显示卡通，joke显示笑话# 17、查询书名、库存，其中num值超过30本的，显示滞销，大于0并低于10的，显示畅销，为0的显示需要无货# 18、统计每一种note的库存量，并合计总量# 19、统计每一种note的数量，并合计总量# 20、统计库存量前三名的图书# 21、找出最早出版的一本书# 22、找出novel中价格最高的一本书# 23、找出书名中字数最多的一本书，不含空格 答案： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#1、创建数据库test01_libraryCREATE DATABASE IF NOT EXISTS test01_library CHARACTER SET &#x27;utf8&#x27;;#指定使用哪个数据库USE test01_library;#2、创建表 booksCREATE TABLE books( id INT, name VARCHAR(50), `authors` VARCHAR(100) , price FLOAT, pubdate YEAR , note VARCHAR(100), num INT);#3、向books表中插入记录# 1）不指定字段名称，插入第一条记录INSERT INTO books VALUES(1,&#x27;Tal of AAA&#x27;,&#x27;Dickes&#x27;,23,1995,&#x27;novel&#x27;,11);# 2）指定所有字段名称，插入第二记录INSERT INTO books (id,name,`authors`,price,pubdate,note,num)VALUES(2,&#x27;EmmaT&#x27;,&#x27;Jane lura&#x27;,35,1993,&#x27;Joke&#x27;,22);# 3）同时插入多条记录（剩下的所有记录）INSERT INTO books (id,name,`authors`,price,pubdate,note,num) VALUES(3,&#x27;Story of Jane&#x27;,&#x27;Jane Tim&#x27;,40,2001,&#x27;novel&#x27;,0),(4,&#x27;Lovey Day&#x27;,&#x27;George Byron&#x27;,20,2005,&#x27;novel&#x27;,30),(5,&#x27;Old land&#x27;,&#x27;Honore Blade&#x27;,30,2010,&#x27;Law&#x27;,0),(6,&#x27;The Battle&#x27;,&#x27;Upton Sara&#x27;,30,1999,&#x27;medicine&#x27;,40),(7,&#x27;Rose Hood&#x27;,&#x27;Richard haggard&#x27;,28,2008,&#x27;cartoon&#x27;,28);# 4、将小说类型(novel)的书的价格都增加5。UPDATE books SET price=price+5 WHERE note = &#x27;novel&#x27;;# 5、将名称为EmmaT的书的价格改为40，并将说明改为drama。UPDATE books SET price=40, note=&#x27;drama&#x27; WHERE name=&#x27;EmmaT&#x27;;# 6、删除库存为0的记录。DELETE FROM books WHERE num=0; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# 7、统计书名中包含a字母的书SELECT * FROM books WHERE name LIKE &#x27;%a%&#x27;;# 8、统计书名中包含a字母的书的数量和库存总量SELECT COUNT(*),SUM(num) FROM books WHERE name LIKE &#x27;%a%&#x27;;# 9、找出“novel”类型的书，按照价格降序排列SELECT * FROM books WHERE note = &#x27;novel&#x27; ORDER BY price DESC;# 10、查询图书信息，按照库存量降序排列，如果库存量相同的按照note升序排列SELECT * FROM books ORDER BY num DESC,note ASC;# 11、按照note分类统计书的数量SELECT note,COUNT(*) FROM books GROUP BY note;# 12、按照note分类统计书的库存量，显示库存量超过30本的SELECT note,SUM(num) FROM books GROUP BY note HAVING SUM(num)&gt;30;# 13、查询所有图书，每页显示5本，显示第二页SELECT * FROM books LIMIT 5,5;# 14、按照note分类统计书的库存量，显示库存量最多的SELECT note,SUM(num) sum_num FROM books GROUP BY note ORDER BY sum_num DESC LIMIT 0,1;# 15、查询书名达到10个字符的书，不包括里面的空格SELECT * FROM books WHERE CHAR_LENGTH(REPLACE(name,&#x27; &#x27;,&#x27;&#x27;))&gt;=10;/*16、查询书名和类型， 其中note值为 novel显示小说，law显示法律，medicine显示医药，cartoon显示卡通，joke显示笑话*/SELECT name AS &quot;书名&quot; ,note, CASE note WHEN &#x27;novel&#x27; THEN &#x27;小说&#x27; WHEN &#x27;law&#x27; THEN &#x27;法律&#x27; WHEN &#x27;medicine&#x27; THEN &#x27;医药&#x27; WHEN &#x27;cartoon&#x27; THEN &#x27;卡通&#x27; WHEN &#x27;joke&#x27; THEN &#x27;笑话&#x27; END AS &quot;类型&quot;FROM books;# 17、查询书名、库存，其中num值超过30本的，显示滞销，大于0并低于10的，显示畅销，为0的显示需要无货SELECT name,num,CASE WHEN num&gt;30 THEN &#x27;滞销&#x27; WHEN num&gt;0 AND num&lt;10 THEN &#x27;畅销&#x27; WHEN num=0 THEN &#x27;无货&#x27; ELSE &#x27;正常&#x27; END AS &quot;库存状态&quot;FROM books;# 18、统计每一种note的库存量，并合计总量SELECT IFNULL(note,&#x27;合计总库存量&#x27;) AS note,SUM(num) FROM books GROUP BY note WITH ROLLUP;# 19、统计每一种note的数量，并合计总量SELECT IFNULL(note,&#x27;合计总数&#x27;) AS note,COUNT(*) FROM books GROUP BY note WITH ROLLUP;# 20、统计库存量前三名的图书SELECT * FROM books ORDER BY num DESC LIMIT 0,3;# 21、找出最早出版的一本书SELECT * FROM books ORDER BY pubdate ASC LIMIT 0,1;# 22、找出novel中价格最高的一本书SELECT * FROM books WHERE note = &#x27;novel&#x27; ORDER BY price DESC LIMIT 0,1;# 23、找出书名中字数最多的一本书，不含空格SELECT * FROM books ORDER BY CHAR_LENGTH(REPLACE(name,&#x27; &#x27;,&#x27;&#x27;)) DESC LIMIT 0,1; 数据定义语言 - DDLDDL（Data Definition Languages） 数据定义语言，这些语句定义了不同的数据段、数据库、表、列、索引等数据库对象的定义。 常用的语句关键字主要包括 CREATE、DROP、ALTER等。 创建和管理数据库创建数据库 方式1：创建数据库 1CREATE DATABASE 数据库名; 方式2：创建数据库并指定字符集 1CREATE DATABASE 数据库名 CHARACTER SET 字符集; 方式3：判断数据库是否已经存在，不存在则创建数据库（推荐） 1CREATE DATABASE IF NOT EXISTS 数据库名 CHARACTER SET 字符集; 如果MySQL中已经存在相关的数据库，则忽略创建语句，不再创建数据库。 注意：DATABASE 不能改名。一些可视化工具可以改名，它是建新库，把所有表复制到新库，再删旧库完成的。 使用/切换数据库 查看当前所有的数据库 12SHOW DATABASES; #有一个S，代表多个数据库 查看当前正在使用的数据库 12SELECT DATABASE(); #使用的一个 mysql 中的全局函数 查看指定库下所有的表 1SHOW TABLES FROM 数据库名; 查看数据库的创建信息 123SHOW CREATE DATABASE 数据库名;或者：SHOW CREATE DATABASE 数据库名\\G 使用/切换数据库 1USE 数据库名; 注意：要操作表格和数据之前必须先说明是对哪个数据库进行操作，否则就要对所有对象加上“数据库名.”。 修改数据库 更改数据库字符集 1ALTER DATABASE 数据库名 CHARACTER SET 字符集; #比如：gbk、utf8等 删除数据库 方式1：删除指定的数据库 1DROP DATABASE 数据库名; 方式2：删除指定的数据库（推荐） 1DROP DATABASE IF EXISTS 数据库名; 创建表创建方式1 必须具备： CREATE TABLE权限 存储空间 语法格式： 1234567CREATE TABLE [IF NOT EXISTS] 表名( 字段1, 数据类型 [约束条件] [默认值], 字段2, 数据类型 [约束条件] [默认值], 字段3, 数据类型 [约束条件] [默认值], …… [表约束条件]); 加上了IF NOT EXISTS关键字，则表示： 如果当前数据库中不存在要创建的数据表，则创建数据表； 如果当前数据库中已经存在要创建的数据表，则忽略建表语句，不再创建数据表。 必须指定： 表名 列名(或字段名)，数据类型，长度 可选指定： 约束条件 默认值 创建表举例1： 1234567891011-- 创建表CREATE TABLE emp ( -- int类型 emp_id INT, -- 最多保存20个中英文字符 emp_name VARCHAR(20), -- 总位数不超过15位 salary DOUBLE, -- 日期类型 birthday DATE); MySQL在执行建表语句时，将id字段的类型设置为int(11)，这里的11实际上是int类型指定的显示宽度，默认的显示宽度为11。也可以在创建数据表的时候指定数据的显示宽度。 创建表举例2： 12345678CREATE TABLE dept( -- int类型，自增 deptno INT(2) AUTO_INCREMENT, dname VARCHAR(14), loc VARCHAR(13), -- 主键 PRIMARY KEY (deptno)); 在MySQL 8.x版本中，不再推荐为INT类型指定显示长度，并在未来的版本中可能去掉这样的语法。 创建方式2 使用 AS subquery 选项，将创建表和插入数据结合起来 指定的列和子查询中的列要一一对应 通过列名和默认值定义列 123456789CREATE TABLE emp1 AS SELECT * FROM employees;CREATE TABLE emp2 AS SELECT * FROM employees WHERE 1=2; -- 创建的emp2是空表 123456CREATE TABLE dept80AS SELECT employee_id, last_name, salary*12 ANNSAL, hire_dateFROM employeesWHERE department_id = 80; 查看数据表结构在MySQL中创建好数据表之后，可以查看数据表的结构。MySQL支持使用DESCRIBE/DESC语句查看数据表结构，也支持使用SHOW CREATE TABLE语句查看数据表结构。 语法格式如下： 1SHOW CREATE TABLE 表名\\G 使用SHOW CREATE TABLE语句不仅可以查看表创建时的详细语句，还可以查看存储引擎和字符编码。 修改表修改表指的是修改数据库中已经存在的数据表的结构。 使用 ALTER TABLE 语句可以实现： 向已有的表中添加列 修改现有表中的列 删除现有表中的列 重命名现有表中的列 追加一个列语法格式如下： 1ALTER TABLE 表名 ADD 【COLUMN】 字段名 字段类型 【FIRST|AFTER 字段名】; 举例： 12ALTER TABLE dept80 ADD job_id varchar(15); 修改一个列 可以修改列的数据类型，长度、默认值和位置 修改字段数据类型、长度、默认值、位置的语法格式如下： 1ALTER TABLE 表名 MODIFY 【COLUMN】 字段名1 字段类型 【DEFAULT 默认值】【FIRST|AFTER 字段名2】; 举例： 12ALTER TABLE dept80MODIFY last_name VARCHAR(30); 12ALTER TABLE dept80MODIFY salary double(9,2) default 1000; 对默认值的修改只影响今后对表的修改 此外，还可以通过此种方式修改列的约束。这里暂先不讲。 重命名一个列使用 CHANGE old_column new_column dataType子句重命名列。语法格式如下： 1ALTER TABLE 表名 CHANGE 【column】 列名 新列名 新数据类型; 举例： 12ALTER TABLE dept80CHANGE department_name dept_name varchar(15); 删除一个列删除表中某个字段的语法格式如下： 1ALTER TABLE 表名 DROP 【COLUMN】字段名 举例： 12ALTER TABLE dept80DROP COLUMN job_id; 重命名表 方式一：使用RENAME 12RENAME TABLE empTO myemp; 方式二： 12ALTER table deptRENAME [TO] detail_dept; -- [TO]可以省略 必须是对象的拥有者 删除表 在MySQL中，当一张数据表没有与其他任何数据表形成关联关系时，可以将当前数据表直接删除。 数据和结构都被删除 所有正在运行的相关事务被提交 所有相关索引被删除 语法格式： 1DROP TABLE [IF EXISTS] 数据表1 [, 数据表2, …, 数据表n]; IF EXISTS的含义为： 如果当前数据库中存在相应的数据表，则删除数据表； 如果当前数据库中不存在相应的数据表，则忽略删除语句，不再执行删除数据表的操作。 举例： 1DROP TABLE dept80; DROP TABLE 语句不能回滚 清空表 TRUNCATE TABLE语句： 删除表中所有的数据 释放表的存储空间 举例： 1TRUNCATE TABLE detail_dept; TRUNCATE语句不能回滚，而使用 DELETE 语句删除数据，可以回滚 对比： 12345678910SET autocommit = FALSE; DELETE FROM emp2; #TRUNCATE TABLE emp2; SELECT * FROM emp2; ROLLBACK; SELECT * FROM emp2; 阿里开发规范： 【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无事务且不触发 TRIGGER，有可能造成事故，故不建议在开发代码中使用此语句。 说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。 内容拓展 - 字段命名阿里巴巴《Java开发手册》之MySQL字段命名 【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。 正例：aliyun_admin，rdc_config，level3_name 反例：AliyunAdmin，rdcConfig，level_3_name 【强制】禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。 【强制】表必备三字段：id, gmt_create, gmt_modified。 说明：其中 id 必为主键，类型为BIGINT UNSIGNED、单表时自增、步长为 1。gmt_create, gmt_modified 的类型均为 DATETIME 类型，前者现在时表示主动式创建，后者过去分词表示被动式更新 【推荐】表的命名最好是遵循 “业务名称_表的作用”。 正例：alipay_task 、 force_project、 trade_config 【推荐】库名与应用名称尽量一致。 【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。 正例：无符号值可以避免误存负数，且扩大了表示范围。 如何理解清空表、删除表等操作需谨慎？！表删除操作将把表的定义和表中的数据一起删除，并且MySQL在执行删除操作时，不会有任何的确认信息提示，因此执行删除操时应当慎重。在删除表前，最好对表中的数据进行备份，这样当操作失误时可以对数据进行恢复，以免造成无法挽回的后果。 同样的，在进行表的基本修改操作时，在执行操作过程之前，也应该确保对数据进行完整的备份，因为数据库的改变是无法撤销的，如果添加了一个不需要的字段，可以将其删除；相同的，如果删除了一个需要的列，该列下面的所有数据都将会丢失。 MySQL8新特性—DDL的原子化在MySQL 8.0版本中，InnoDB表的DDL支持事务完整性，即DDL操作要么成功要么回滚。 DDL操作回滚日志写入到data dictionary数据字典表mysql.innodb_ddl_log（该表是隐藏的表，通过show tables无法看到）中，用于回滚操作。通过设置参数，可将DDL操作日志打印输出到MySQL错误日志中。 分别在MySQL 5.7版本和MySQL 8.0版本中创建数据库和数据表，结果如下： 12345678910CREATE DATABASE mytest;USE mytest;CREATE TABLE book1(book_id INT ,book_name VARCHAR(255));SHOW TABLES; （1）在MySQL 5.7版本中，测试步骤如下：删除数据表book1和数据表book2，结果如下： 12mysql&gt; DROP TABLE book1,book2;ERROR 1051 (42S02): Unknown table &#x27;mytest.book2&#x27; 再次查询数据库中的数据表名称，结果如下： 12mysql&gt; SHOW TABLES;Empty set (0.00 sec) 从结果可以看出，虽然删除操作时报错了，但是仍然删除了数据表book1。 （2）在MySQL 8.0版本中，测试步骤如下：删除数据表book1和数据表book2，结果如下： 12mysql&gt; DROP TABLE book1,book2;ERROR 1051 (42S02): Unknown table &#x27;mytest.book2&#x27; 再次查询数据库中的数据表名称，结果如下： 1234567mysql&gt; show tables;+------------------+| Tables_in_mytest |+------------------+| book1 |+------------------+1 row in set (0.00 sec) 从结果可以看出，数据表book1并没有被删除。 数据控制语言 - DCLDCL（Data Control Language） 数据控制语句，用于控制不同数据段直接的许可和访问级别的语句。这些语句定义了数据库、表、字段、用户的访问权限和安全级别。 主要的语句关键字包括 grant、revoke 等。 数据类型 类型 类型举例 整数类型 TINYINT、SMALLINT、MEDIUMINT、INT(或INTEGER)、BIGINT 浮点类型 FLOAT、DOUBLE 定点数类型 DECIMAL 位类型 BIT 日期时间类型 YEAR、TIME、DAT E、DATETIME、TIMESTAMP 文本字符串类型 CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT 枚举类型 ENUM 集合类型 SET 二进制字符串类型 BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB JSON类型 JSON对象、JSON数组 空间数据类型 单值：GEOMETRY、POINT、LINESTRING、POLYGON；集合：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION 常用的几类类型介绍如下： 数据类型 描述 INT 从-2^31到2^31-1的整型数据。存储大小为 4个字节 CHAR(size) 定长字符数据。若未指定，默认为1个字符，最大长度255 VARCHAR(size) 可变长字符数据，根据字符串实际长度保存，必须指定长度 FLOAT(M,D) 单精度，占用4个字节，M=整数位+小数位，D=小数位。 D&lt;=M&lt;=255,0&lt;=D&lt;=30，默认M+D&lt;=6 DOUBLE(M,D) 双精度，占用8个字节，D&lt;=M&lt;=255,0&lt;=D&lt;=30，默认M+D&lt;=15 DECIMAL(M,D) 高精度小数，占用M+2个字节，D&lt;=M&lt;=65，0&lt;=D&lt;=30，最大取值范围与DOUBLE相同。 DATE 日期型数据，格式’YYYY-MM-DD’ BLOB 二进制形式的长文本数据，最大可达4G TEXT 长文本数据，最大可达4G 在定义数据类型时： 如果确定是整数，就用INT； 如果是小数，一定用定点数类型 DECIMAL(M,D)； 如果是日期与时间，就用 DATETIME。 这样做的好处是，首先确保你的系统不会因为数据类型定义出错。不过，凡事都是有两面的，可靠性好，并不意味着高效。比如，TEXT 虽然使用方便，但是效率不如 CHAR(M) 和 VARCHAR(M)。 常见数据类型的属性，如下： MySQL关键字 含义 NULL 数据列可包含NULL值 NOT NULL 数据列不允许包含NULL值 DEFAULT 默认值 PRIMARY KEY 主键 AUTO_INCREMENT 自动递增，适用于整数类型 UNSIGNED 无符号 CHARACTER SET name 指定一个字符集 整数类型整数类型一共有 5 种，包括 TINYINT、SMALLINT、MEDIUMINT、INT（INTEGER）和 BIGINT。 它们的区别如下表所示： 整数类型 字节 有符号数取值范围 无符号数取值范围 TINYINT 1 -128~127 0~255 SMALLINT 2 -32768~32767 0~65535 MEDIUMINT 3 -8388608~8388607 0~16777215 INT、INTEGER 4 -2147483648~2147483647 0~4294967295 BIGINT 8 -9223372036854775808~9223372036854775807 0~18446744073709551615 UNISIGNEDUNSIGNED: 无符号类型（非负），所有的整数类型都有一个可选的属性UNSIGNED（无符号属性），无符号整数类型的最小取值为0。所以，如果需要在MySQL数据库中保存非负整数值时，可以将整数类型设置为无符号类型。 ZEROFILLZEROFILL: 0填充,（如果某列是ZEROFILL，那么MySQL会自动为当前列添加UNSIGNED属性），如果指定了ZEROFILL只是表示不够M位时，用0在左边填充，如果超过M位，只要不超过数据存储范围即可。 原来，在 int(M) 中，M 的值跟 int(M) 所占多少存储空间并无任何关系。 int(3)、int(4)、int(8) 在磁盘上都是占用 4 bytes 的存储空间。也就是说，int(M)，必须和UNSIGNED ZEROFILL一起使用才有意义。如果整数值超过M位，就按照实际位数存储。只是无须再用字符 0 进行填充。 浮点类型浮点数和定点数类型的特点是可以处理小数，可以把整数看成小数的一个特例。因此，浮点数和定点数的使用场景，比整数大多了。 MySQL支持的浮点数类型，分别是 FLOAT、DOUBLE、REAL。 FLOAT 表示单精度浮点数； DOUBLE 表示双精度浮点数； REAL默认就是 DOUBLE。如果你把 SQL 模式设定为启用“REAL_AS_FLOAT”，那 么，MySQL 就认为 REAL 是 FLOAT。如果要启用“REAL_AS_FLOAT”，可以通过以下 SQL 语句实现： 1SET sql_mode = “REAL_AS_FLOAT”; 问题1：FLOAT 和 DOUBLE 这两种数据类型的区别是啥呢？ FLOAT 占用字节数少，取值范围小；DOUBLE 占用字节数多，取值范围也大。 问题2：为什么浮点数类型的无符号数取值范围，只相当于有符号数取值范围的一半，也就是只相当于有符号数取值范围大于等于零的部分呢？ MySQL 存储浮点数的格式为：符号(S)、尾数(M)和 阶码(E)。因此，无论有没有符号，MySQL 的浮点数都会存储表示符号的部分。因此， 所谓的无符号数取值范围，其实就是有符号数取值范围大于等于零的部分。 数据精度说明对于浮点类型，在MySQL中单精度值使用4个字节，双精度值使用8个字节。 MySQL允许使用非标准语法（其他数据库未必支持，因此如果涉及到数据迁移，则最好不要这么用）： FLOAT(M,D)或DOUBLE(M,D)。这里，M称为精度，D称为标度。(M,D)中 M=整数位+小数位，D=小数位。 D&lt;=M&lt;=255，0&lt;=D&lt;=30。 例如，定义为FLOAT(5,2)的一个列可以显示为-999.99-999.99。如果超过这个范围会报错。 FLOAT和DOUBLE类型在不指定(M,D)时，默认会按照实际的精度（由实际的硬件和操作系统决定）来显示。 说明：浮点类型，也可以加UNSIGNED，但是不会改变数据范围，例如：FLOAT(3,2) UNSIGNED仍然只能表示0-9.99的范围。 不管是否显式设置了精度(M,D)，这里MySQL的处理方案如下： 如果存储时，整数部分超出了范围，MySQL就会报错，不允许存这样的值 如果存储时，小数点部分若超出范围，就分以下情况： 若四舍五入后，整数部分没有超出范围，则只警告，但能成功操作并四舍五入删除多余的小数位后保存。例如在FLOAT(5,2)列内插入999.009，近似结果是999.01。 若四舍五入后，整数部分超出范围，则MySQL报错，并拒绝处理。如FLOAT(5,2)列内插入999.995和-999.995都会报错。 从MySQL 8.0.17开始，FLOAT(M,D) 和DOUBLE(M,D)用法在官方文档中已经明确不推荐使用，将来可能被移除。另外，关于浮点型FLOAT和DOUBLE的UNSIGNED也不推荐使用了，将来也可能被移除。 举例 1234567891011121314151617CREATE TABLE test_double1(f1 FLOAT,f2 FLOAT(5,2),f3 DOUBLE,f4 DOUBLE(5,2));DESC test_double1;INSERT INTO test_double1VALUES(123.456,123.456,123.4567,123.45);#Out of range value for column &#x27;f2&#x27; at row 1INSERT INTO test_double1VALUES(123.456,1234.456,123.4567,123.45); SELECT * FROM test_double1; 精度误差说明浮点数类型有个缺陷，就是不精准。比如，我们设计一个表，有f1这个字段，插入值分别为0.47,0.44,0.19，我们期待的运行结果是：0.47 + 0.44 + 0.19 = 1.1。而使用sum之后查询： 123456CREATE TABLE test_double2(f1 DOUBLE);INSERT INTO test_double2VALUES(0.47),(0.44),(0.19); 12345678mysql&gt; SELECT SUM(f1) -&gt; FROM test_double2;+--------------------+| SUM(f1) |+--------------------+| 1.0999999999999999 |+--------------------+1 row in set (0.00 sec) 12345678mysql&gt; SELECT SUM(f1) = 1.1,1.1 = 1.1 -&gt; FROM test_double2;+---------------+-----------+| SUM(f1) = 1.1 | 1.1 = 1.1 |+---------------+-----------+| 0 | 1 |+---------------+-----------+1 row in set (0.00 sec) 查询结果是 1.0999999999999999。看到了吗？虽然误差很小，但确实有误差。 你也可以尝试把数据类型改成 FLOAT，然后运行求和查询，得到的是， 1.0999999940395355。显然，误差更大了。 那么，为什么会存在这样的误差呢？问题还是出在 MySQL 对浮点类型数据的存储方式上。 MySQL 用 4 个字节存储 FLOAT 类型数据，用 8 个字节来存储 DOUBLE 类型数据。无论哪个，都是采用二进制的方式来进行存储的。比如 9.625，用二进制来表达，就是 1001.101，或者表达成 1.001101×2^3。如果尾数不是 0 或 5（比如 9.624），你就无法用一个二进制数来精确表达。进而，就只好在取值允许的范围内进行四舍五入。 因为浮点数是不准确的，所以我们要避免使用“=”来判断两个数是否相等。同时，在一些对精确度要求较高的项目中，千万不要使用浮点数，不然会导致结果错误，甚至是造成不可挽回的损失。那么，MySQL 有没有精准的数据类型呢？当然有，这就是定点数类型：DECIMAL。 定点数类型 MySQL中的定点数类型只有 DECIMAL 一种类型。 数据类型 字节数 含义 DECIMAL(M,D),DEC,NUMERIC M+2字节 有效范围由M和D决定 使用 DECIMAL(M,D) 的方式表示高精度小数。 其中，M被称为精度，D被称为标度。0&lt;=M&lt;=65，0&lt;=D&lt;=30，D&lt;M。 例如，定义DECIMAL（5,2）的类型，表示该列取值范围是-999.99~999.99。 DECIMAL(M,D)的最大取值范围与DOUBLE类型一样，但是有效的数据范围是由M和D决定的。DECIMAL 的存储空间并不是固定的，由精度值M决定，总共占用的存储空间为M+2个字节。也就是说，在一些对精度要求不高的场景下，比起占用同样字节长度的定点数，浮点数表达的数值范围可以更大一些。 定点数在MySQL内部是以字符串的形式进行存储，这就决定了它一定是精准的。 当DECIMAL类型不指定精度和标度时，其默认为DECIMAL(10,0)。当数据的精度超出了定点数类型的精度范围时，则MySQL同样会进行四舍五入处理。 浮点数 vs 定点数 浮点数相对于定点数的优点是在长度一定的情况下，浮点类型取值范围大，但是不精准，适用于需要取值范围大，又可以容忍微小误差的科学计算场景（比如计算化学、分子建模、流体动力学等） 定点数类型取值范围相对小，但是精准，没有误差，适合于对精度要求极高的场景 （比如涉及金额计算的场景） 举例 12345678910111213CREATE TABLE test_decimal1(f1 DECIMAL,f2 DECIMAL(5,2));DESC test_decimal1;INSERT INTO test_decimal1(f1,f2)VALUES(123.123,123.456);#Out of range value for column &#x27;f2&#x27; at row 1INSERT INTO test_decimal1(f2)VALUES(1234.34); 1234567mysql&gt; SELECT * FROM test_decimal1;+------+--------+| f1 | f2 |+------+--------+| 123 | 123.46 |+------+--------+1 row in set (0.00 sec) 日期与时间类型MySQL有多种表示日期和时间的数据类型，不同的版本可能有所差异，MySQL8.0版本支持的日期和时间类型主要有：YEAR类型、TIME类型、DATE类型、DATETIME类型和TIMESTAMP类型。 YEAR类型通常用来表示年 DATE类型通常用来表示年、月、日 TIME类型通常用来表示时、分、秒 DATETIME类型通常用来表示年、月、日、时、分、秒 TIMESTAMP类型通常用来表示带时区的年、月、日、时、分、秒 类型 名称 字节 日期格式 最小值 最大值 YEAR 年 1 YYYY或YY 1901 2155 TIME 时间 3 HH:MM:SS -838:59:59 838:59:59 DATE 日期 3 YYYY-MM-DD 1000-01-01 9999-12-03 DATETIME 日期时间 8 YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00 9999-12-31 23:59:59 TIMESTAMP 日期时间 4 YYYY-MM-DD HH:MM:SS 1970-01-01 00:00:00 UTC 2038-01-19 03:14:07UTC 为什么时间类型 TIME 的取值范围不是 -23:59:59～23:59:59 呢？原因是 MySQL 设计的 TIME 类型，不光表示一天之内的时间，而且可以用来表示一个时间间隔，这个时间间隔可以超过 24 小时。 YEAR类型YEAR类型用来表示年份，在所有的日期时间类型中所占用的存储空间最小，只需要1个字节的存储空间。 在MySQL中，YEAR有以下几种存储格式： 以4位字符串或数字格式表示YEAR类型，其格式为YYYY，最小值为1901，最大值为2155。 以2位字符串格式表示YEAR类型，最小值为00，最大值为99。 当取值为01到69时，表示2001到2069； 当取值为70到99时，表示1970到1999； 当取值整数的0或00添加的话，那么是0000年； 当取值是日期/字符串的’0’添加的话，是2000年。 从MySQL5.5.27开始，2位格式的YEAR已经不推荐使用。YEAR默认格式就是“YYYY”，没必要写成YEAR(4)，从MySQL 8.0.19开始，不推荐使用指定显示宽度的YEAR(4)数据类型。 DATE类型DATE类型表示日期，没有时间部分，格式为YYYY-MM-DD 其中，YYYY表示年份，MM表示月份，DD表示日期。需要3个字节的存储空间。在向DATE类型的字段插入数据时，同样需要满足一定的格式条件。 以YYYY-MM-DD格式或者YYYYMMDD格式表示的字符串日期，其最小取值为1000-01-01，最大取值为9999-12-03。YYYYMMDD格式会被转化为YYYY-MM-DD格式。 以YY-MM-DD格式或者YYMMDD格式表示的字符串日期，此格式中，年份为两位数值或字符串满足YEAR类型的格式条件为：当年份取值为00到69时，会被转化为2000到2069；当年份取值为70到99时，会被转化为1970到1999。 使用CURRENT_DATE()或者NOW()函数，会插入当前系统的日期。 TIME类型TIME类型用来表示时间，不包含日期部分。在MySQL中，需要3个字节的存储空间来存储TIME类型的数据，可以使用“HH:MM:SS”格式来表示TIME类型，其中，HH表示小时，MM表示分钟，SS表示秒。 在MySQL中，向TIME类型的字段插入数据时，也可以使用几种不同的格式。（1）可以使用带有冒号的字符串，比如’D HH:MM:SS&#39;、’HH:MM:SS‘、’HH:MM‘、’D HH:MM‘、’D HH‘或’SS‘格式，都能被正确地插入TIME类型的字段中。其中D表示天，其最小值为0，最大值为34。如果使用带有D格式的字符串插入TIME类型的字段时，D会被转化为小时，计算格式为D*24+HH。当使用带有冒号并且不带D的字符串表示时间时，表示当天的时间，比如12:10表示12:10:00，而不是00:12:10。（2）可以使用不带有冒号的字符串或者数字，格式为’HHMMSS‘或者HHMMSS。如果插入一个不合法的字符串或者数字，MySQL在存储数据时，会将其自动转化为00:00:00进行存储。比如1210，MySQL会将最右边的两位解析成秒，表示00:12:10，而不是12:10:00。（3）使用CURRENT_TIME()或者NOW()，会插入当前系统的时间。 举例： 创建数据表，表中包含一个TIME类型的字段f1。 1234CREATE TABLE test_time1(f1 TIME);Query OK, 0 rows affected (0.02 sec) 12345678910INSERT INTO test_time1VALUES(&#x27;2 12:30:29&#x27;), (&#x27;12:35:29&#x27;), (&#x27;12:40&#x27;), (&#x27;2 12:40&#x27;),(&#x27;1 05&#x27;), (&#x27;45&#x27;);INSERT INTO test_time1VALUES (&#x27;123520&#x27;), (124011),(1210);INSERT INTO test_time1VALUES (NOW()), (CURRENT_TIME());SELECT * FROM test_time1; DATETIME类型DATETIME类型在所有的日期时间类型中占用的存储空间最大，总共需要8个字节的存储空间。在格式上为DATE类型和TIME类型的组合，可以表示为YYYY-MM-DD HH:MM:SS，其中YYYY表示年份，MM表示月份，DD表示日期，HH表示小时，MM表示分钟，SS表示秒。 在向DATETIME类型的字段插入数据时，同样需要满足一定的格式条件。 以YYYY-MM-DD HH:MM:SS格式或者YYYYMMDDHHMMSS格式的字符串插入DATETIME类型的字段时，最小值为1000-01-01 00:00:00，最大值为9999-12-03 23:59:59。 以YYYYMMDDHHMMSS格式的数字插入DATETIME类型的字段时，会被转化为YYYY-MM-DD HH:MM:SS格式。 以YY-MM-DD HH:MM:SS格式或者YYMMDDHHMMSS格式的字符串插入DATETIME类型的字段时，两位数的年份规则符合YEAR类型的规则，00到69表示2000到2069；70到99表示1970到1999。 使用函数CURRENT_TIMESTAMP()和NOW()，可以向DATETIME类型的字段插入系统的当前日期和时间。 举例： 创建数据表，表中包含一个DATETIME类型的字段dt。 1234CREATE TABLE test_datetime1(dt DATETIME);Query OK, 0 rows affected (0.02 sec) 插入数据： 1234567891011INSERT INTO test_datetime1VALUES (&#x27;2021-01-01 06:50:30&#x27;), (&#x27;20210101065030&#x27;);INSERT INTO test_datetime1VALUES (&#x27;99-01-01 00:00:00&#x27;), (&#x27;990101000000&#x27;), (&#x27;20-01-01 00:00:00&#x27;), (&#x27;200101000000&#x27;);INSERT INTO test_datetime1VALUES (20200101000000), (200101000000), (19990101000000), (990101000000); INSERT INTO test_datetime1VALUES (CURRENT_TIMESTAMP()), (NOW()); TIMESTAMP类型TIMESTAMP类型也可以表示日期时间，其显示格式与DATETIME类型相同，都是YYYY-MM-DD HH:MM:SS，需要4个字节的存储空间。但是TIMESTAMP存储的时间范围比DATETIME要小很多，只能存储“1970-01-01 00:00:01 UTC”到“2038-01-19 03:14:07 UTC”之间的时间。其中，UTC表示世界统一时间，也叫作世界标准时间。 存储数据的时候需要对当前时间所在的时区进行转换，查询数据的时候再将时间转换回当前的时区。因此，使用TIMESTAMP存储的同一个时间值，在不同的时区查询时会显示不同的时间。 向TIMESTAMP类型的字段插入数据时，当插入的数据格式满足YY-MM-DD HH:MM:SS和YYMMDDHHMMSS时，两位数值的年份同样符合YEAR类型的规则条件，只不过表示的时间范围要小很多。 如果向TIMESTAMP类型的字段插入的时间超出了TIMESTAMP类型的范围，则MySQL会抛出错误信息。 举例： 创建数据表，表中包含一个TIMESTAMP类型的字段ts。 123CREATE TABLE test_timestamp1(ts TIMESTAMP); 插入数据： 123456789101112INSERT INTO test_timestamp1VALUES (&#x27;1999-01-01 03:04:50&#x27;), (&#x27;19990101030405&#x27;), (&#x27;99-01-01 03:04:05&#x27;), (&#x27;990101030405&#x27;);INSERT INTO test_timestamp1VALUES (&#x27;2020@01@01@00@00@00&#x27;), (&#x27;20@01@01@00@00@00&#x27;);INSERT INTO test_timestamp1VALUES (CURRENT_TIMESTAMP()), (NOW());#Incorrect datetime valueINSERT INTO test_timestamp1VALUES (&#x27;2038-01-20 03:14:07&#x27;); TIMESTAMP和DATETIME的区别： TIMESTAMP存储空间比较小，表示的日期时间范围也比较小 底层存储方式不同，TIMESTAMP底层存储的是毫秒值，距离1970-1-1 0:0:0 0毫秒的毫秒值。 两个日期比较大小或日期计算时，TIMESTAMP更方便、更快。 TIMESTAMP和时区有关。TIMESTAMP会根据用户的时区不同，显示不同的结果。而DATETIME则只能反映出插入时当地的时区，其他时区的人查看数据必然会有误差的。 1234CREATE TABLE temp_time(d1 DATETIME,d2 TIMESTAMP); 123INSERT INTO temp_time VALUES(&#x27;2021-9-2 14:45:52&#x27;,&#x27;2021-9-2 14:45:52&#x27;);INSERT INTO temp_time VALUES(NOW(),NOW()); 12345678mysql&gt; SELECT * FROM temp_time;+---------------------+---------------------+| d1 | d2 |+---------------------+---------------------+| 2021-09-02 14:45:52 | 2021-09-02 14:45:52 || 2021-11-03 17:38:17 | 2021-11-03 17:38:17 |+---------------------+---------------------+2 rows in set (0.00 sec) 12#修改当前的时区SET time_zone = &#x27;+9:00&#x27;; 12345678mysql&gt; SELECT * FROM temp_time;+---------------------+---------------------+| d1 | d2 |+---------------------+---------------------+| 2021-09-02 14:45:52 | 2021-09-02 15:45:52 || 2021-11-03 17:38:17 | 2021-11-03 18:38:17 |+---------------------+---------------------+2 rows in set (0.00 sec) 文本字符串类型在实际的项目中，我们还经常遇到一种数据，就是字符串数据。 MySQL中，文本字符串总体上分为CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、ENUM、SET等类型。 CHAR与VARCHAR类型CHAR和VARCHAR类型都可以存储比较短的字符串。 字符串(文本)类型 特点 长度 长度范围 占用的存储空间 CHAR(M) 固定长度 M 0 &lt;= M &lt;= 255 M个字节 VARCHAR(M) 可变长度 M 0 &lt;= M &lt;= 65535 (实际长度 + 1) 个字节 CHAR类型： CHAR(M) 类型一般需要预先定义字符串长度。如果不指定(M)，则表示长度默认是1个字符。 如果保存时，数据的实际长度比CHAR类型声明的长度小，则会在右侧填充空格以达到指定的长度。当MySQL检索CHAR类型的数据时，CHAR类型的字段会去除尾部的空格。 定义CHAR类型字段时，声明的字段长度即为CHAR类型字段所占的存储空间的字节数。 VARCHAR类型： VARCHAR(M) 定义时，必须指定长度M，否则报错。 MySQL4.0版本以下，varchar(20)：指的是20字节，如果存放UTF8汉字时，只能存6个（每个汉字3字节） ；MySQL5.0版本以上，varchar(20)：指的是20字符。 检索VARCHAR类型的字段数据时，会保留数据尾部的空格。VARCHAR类型的字段所占用的存储空间为字符串实际长度加1个字节。 123CREATE TABLE test_varchar1(NAME VARCHAR #错误); 1234#Column length too big for column &#x27;NAME&#x27; (max = 21845);CREATE TABLE test_varchar2(NAME VARCHAR(65535) #错误); 12345678910CREATE TABLE test_varchar3(NAME VARCHAR(5));INSERT INTO test_varchar3VALUES(&#x27;尚硅谷&#x27;),(&#x27;尚硅谷教育&#x27;);#Data too long for column &#x27;NAME&#x27; at row 1INSERT INTO test_varchar3VALUES(&#x27;尚硅谷IT教育&#x27;); 哪些情况使用 CHAR 或 VARCHAR 更好 类型 特点 空间上 时间上 适用场景 CHAR(M) 固定长度 浪费存储空间 效率高 存储不大，速度要求高 VARCHAR(M) 可变长度 节省存储空间 效率低 非CHAR的情况 情况1： 存储很短的信息。比如门牌号码101，201……这样很短的信息应该用char，因为varchar还要占个byte用于存储信息长度，本来打算节约存储的，结果得不偿失。 情况2： 固定长度的。比如使用uuid作为主键，那用char应该更合适。因为他固定长度，varchar动态根据长度的特性就消失了，而且还要占个长度信息。 情况3： 十分频繁改变的column。因为varchar每次存储都要有额外的计算，得到长度等工作，如果一个非常频繁改变的，那就要有很多的精力用于计算，而这些对于char来说是不需要的。 情况4： 具体存储引擎中的情况： MyISAM 数据存储引擎和数据列：MyISAM数据表，最好使用固定长度(CHAR)的数据列代替可变长度(VARCHAR)的数据列。这样使得整个表静态化，从而使数据检索更快，用空间换时间。 MEMORY 存储引擎和数据列：MEMORY数据表目前都使用固定长度的数据行存储，因此无论使用CHAR或VARCHAR列都没有关系，两者都是作为CHAR类型处理的。 InnoDB存储引擎，建议使用VARCHAR类型。因为对于InnoDB数据表，内部的行存储格式并没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），而且主要影响性能的因素是数据行使用的存储总量，由于char平均占用的空间多于varchar，所以除了简短并且固定长度的，其他考虑varchar。这样节省空间，对磁盘I/O和数据存储总量比较好。 TEXT类型在MySQL中，TEXT用来保存文本类型的字符串，总共包含4种类型，分别为TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT 类型。 在向TEXT类型的字段保存和查询数据时，系统自动按照实际长度存储，不需要预先定义长度。这一点和 VARCHAR类型相同。 每种TEXT类型保存的数据长度和所占用的存储空间不同，如下： 文本字符串类型 特点 长度 长度范围 占用的存储空间 TINYTEXT 小文本、可变长度 L 0 &lt;= L &lt;= 255 L + 2 个字节 TEXT 文本、可变长度 L 0 &lt;= L &lt;= 65535 L + 2 个字节 MEDIUMTEXT 中等文本、可变长度 L 0 &lt;= L &lt;= 16777215 L + 3 个字节 LONGTEXT 大文本、可变长度 L 0 &lt;= L&lt;= 4294967295（相当于4GB） L + 4 个字节 由于实际存储的长度不确定，MySQL 不允许 TEXT 类型的字段做主键。遇到这种情况，你只能采用 CHAR(M)，或者 VARCHAR(M)。 举例： 创建数据表： 123CREATE TABLE test_text(tx TEXT); 12345INSERT INTO test_textVALUES(&#x27;atguigu &#x27;);SELECT CHAR_LENGTH(tx)FROM test_text; #10 说明在保存和查询数据时，并没有删除TEXT类型的数据尾部的空格。 开发中经验： TEXT文本类型，可以存比较大的文本段，搜索速度稍慢，因此如果不是特别大的内容，建议使用CHAR，VARCHAR来代替。还有TEXT类型不用加默认值，加了也没用。而且text和blob类型的数据删除后容易导致“空洞”，使得文件碎片比较多，所以频繁使用的表不建议包含TEXT类型字段，建议单独分出去，单独用一个表。 ENUM类型ENUM类型也叫作枚举类型，ENUM类型的取值范围需要在定义字段时进行指定。设置字段值时，ENUM类型只允许从成员中选取单个值，不能一次选取多个值。 其所需要的存储空间由定义ENUM类型时指定的成员个数决定。 文本字符串类型 长度 长度范围 占用的存储空间 ENUM L 1 &lt;= L &lt;= 65535 1或2个字节 当ENUM类型包含1～255个成员时，需要1个字节的存储空间； 当ENUM类型包含256～65535个成员时，需要2个字节的存储空间。 ENUM类型的成员个数的上限为65535个。 举例： 创建表如下： 123CREATE TABLE test_enum(season ENUM(&#x27;春&#x27;,&#x27;夏&#x27;,&#x27;秋&#x27;,&#x27;冬&#x27;,&#x27;unknow&#x27;)); 添加数据： 123456789101112131415161718INSERT INTO test_enumVALUES(&#x27;春&#x27;),(&#x27;秋&#x27;);# 忽略大小写INSERT INTO test_enumVALUES(&#x27;UNKNOW&#x27;);# 允许按照角标的方式获取指定索引位置的枚举值INSERT INTO test_enumVALUES(&#x27;1&#x27;),(3);# Data truncated for column &#x27;season&#x27; at row 1INSERT INTO test_enumVALUES(&#x27;ab&#x27;);# 当ENUM类型的字段没有声明为NOT NULL时，插入NULL也是有效的INSERT INTO test_enumVALUES(NULL); 约束约束是表级的强制规定。可以在创建表时规定约束（通过 CREATE TABLE 语句），或者在表创建之后通过 ALTER TABLE 语句规定约束。 数据完整性（Data Integrity）是指数据的精确性（Accuracy）和可靠性（Reliability）。它是防止数据库中存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出的。 为了保证数据的完整性，SQL规范以约束的方式对表数据进行额外的条件限制。从以下四个方面考虑： 实体完整性（Entity Integrity）：例如，同一个表中，不能存在两条完全相同无法区分的记录 域完整性（Domain Integrity）：例如：年龄范围0-120，性别范围“男/女” 引用完整性（Referential Integrity）：例如：员工所在部门，在部门表中要能找到这个部门 用户自定义完整性（User-defined Integrity）：例如：用户名唯一、密码不能为空等，本部门经理的工资不得高于本部门职工的平均工资的5倍。 根据约束起的作用，约束可分为： NOT NULL 非空约束，规定某个字段不能为空 UNIQUE 唯一约束，规定某个字段在整个表中是唯一的 PRIMARY KEY 主键(非空且唯一)约束 FOREIGN KEY 外键约束 CHECK 检查约束 DEFAULT 默认值约束 注意： MySQL不支持check约束，但可以使用check约束，而没有任何效果 查看某个表已有的约束 1234#information_schema数据库名（系统库）#table_constraints表名称（专门存储各个表的约束）SELECT * FROM information_schema.table_constraints WHERE table_name = &#x27;表名称&#x27;; 非空约束 - NOT NULL作用限定某个字段/某列的值不允许为空 特点 默认，所有的类型的值都可以是NULL，包括INT、FLOAT等数据类型 非空约束只能出现在表对象的列上，只能某个列单独限定非空，不能组合非空 一个表可以有很多列都分别限定了非空 空字符串&#39;&#39;不等于NULL，0也不等于NULL 添加非空约束（1）建表时 12345CREATE TABLE 表名称( 字段名 数据类型, 字段名 数据类型 NOT NULL, 字段名 数据类型 NOT NULL); 举例： 12345CREATE TABLE emp( id INT(10) NOT NULL, NAME VARCHAR(20) NOT NULL, sex CHAR NULL); 123456CREATE TABLE student( sid int, sname varchar(20) not null, tel char(11) , cardid char(18) not null); 123456789insert into student values(1,&#x27;张三&#x27;,&#x27;13710011002&#x27;,&#x27;110222198912032545&#x27;); #成功insert into student values(2,&#x27;李四&#x27;,&#x27;13710011002&#x27;,null);#身份证号为空ERROR 1048 (23000): Column &#x27;cardid&#x27; cannot be nullinsert into student values(2,&#x27;李四&#x27;,null,&#x27;110222198912032546&#x27;);#成功，tel允许为空insert into student values(3,null,null,&#x27;110222198912032547&#x27;);#失败ERROR 1048 (23000): Column &#x27;sname&#x27; cannot be null （2）建表后 1alter table 表名称 modify 字段名 数据类型 not null; 举例： 12ALTER TABLE empMODIFY sex VARCHAR(30) NOT NULL; 1alter table student modify sname varchar(20) not null; 删除非空约束1234567alter table 表名称 modify 字段名 数据类型 NULL;#去掉not null，相当于修改某个非注解字段，该字段允许为空或 alter table 表名称 modify 字段名 数据类型;#去掉not null，相当于修改某个非注解字段，该字段允许为空 举例： 12ALTER TABLE empMODIFY sex VARCHAR(30) NULL; 12ALTER TABLE empMODIFY NAME VARCHAR(15) DEFAULT &#x27;abc&#x27; NULL; 唯一性约束 - UNIQUE作用用来限制某个字段/某列的值不能重复。 特点 同一个表可以有多个唯一约束。 唯一约束可以是某一个列的值唯一，也可以多个列组合的值唯一。 唯一性约束允许列值为空。 在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。 MySQL会给唯一约束的列上默认创建一个唯一索引。 添加唯一约束（1）建表时 123456789101112create table 表名称( 字段名 数据类型, 字段名 数据类型 unique, 字段名 数据类型 unique key, 字段名 数据类型);create table 表名称( 字段名 数据类型, 字段名 数据类型, 字段名 数据类型, [constraint 约束名] unique key(字段名)); 举例： 123456create table student( sid int, sname varchar(20), tel char(11) unique, cardid char(18) unique key); 123456CREATE TABLE t_course( cid INT UNIQUE, cname VARCHAR(100) UNIQUE, description VARCHAR(200)); 1234567CREATE TABLE USER( id INT NOT NULL, NAME VARCHAR(25), PASSWORD VARCHAR(16), -- 使用表级约束语法 CONSTRAINT uk_name_pwd UNIQUE(NAME,PASSWORD)); 表示用户名和密码组合不能重复 12insert into student values(1,&#x27;张三&#x27;,&#x27;13710011002&#x27;,&#x27;101223199012015623&#x27;);insert into student values(2,&#x27;李四&#x27;,&#x27;13710011003&#x27;,&#x27;101223199012015624&#x27;); 12345678mysql&gt; select * from student;+-----+-------+-------------+--------------------+| sid | sname | tel | cardid |+-----+-------+-------------+--------------------+| 1 | 张三 | 13710011002 | 101223199012015623 || 2 | 李四 | 13710011003 | 101223199012015624 |+-----+-------+-------------+--------------------+2 rows in set (0.00 sec) 12345insert into student values(3,&#x27;王五&#x27;,&#x27;13710011004&#x27;,&#x27;101223199012015624&#x27;); #身份证号重复ERROR 1062 (23000): Duplicate entry &#x27;101223199012015624&#x27; for key &#x27;cardid&#x27;#手机号重复insert into student values(3,&#x27;王五&#x27;,&#x27;13710011003&#x27;,&#x27;101223199012015625&#x27;); ERROR 1062 (23000): Duplicate entry &#x27;13710011003&#x27; for key &#x27;tel&#x27; （2）建表后指定唯一键约束 123#字段列表中如果是一个字段，表示该列的值唯一。如果是两个或更多个字段，那么复合唯一，即多个字段的组合是唯一的#方式1：alter table 表名称 add unique key(字段列表); 12#方式2：alter table 表名称 modify 字段名 字段类型 unique; 举例： 12ALTER TABLE USER ADD UNIQUE(NAME,PASSWORD); 12ALTER TABLE USER ADD CONSTRAINT uk_name_pwd UNIQUE(NAME,PASSWORD); 12ALTER TABLE USER MODIFY NAME VARCHAR(20) UNIQUE; 举例： 123456create table student( sid int primary key, sname varchar(20), tel char(11) , cardid char(18) ); 12alter table student add unique key(tel);alter table student add unique key(cardid); 关于复合唯一约束123456create table 表名称( 字段名 数据类型, 字段名 数据类型, 字段名 数据类型, unique key(字段列表) #字段列表中写的是多个字段名，多个字段名用逗号分隔，表示那么是复合唯一，即多个字段的组合是唯一的); 12345678910111213141516171819202122#学生表create table student( sid int, #学号 sname varchar(20), #姓名 tel char(11) unique key, #电话 cardid char(18) unique key #身份证号);#课程表create table course( cid int, #课程编号 cname varchar(20) #课程名称);#选课表create table student_course( id int, sid int, cid int, score int, unique key(sid,cid) #复合唯一); 123insert into student values(1,&#x27;张三&#x27;,&#x27;13710011002&#x27;,&#x27;101223199012015623&#x27;);#成功insert into student values(2,&#x27;李四&#x27;,&#x27;13710011003&#x27;,&#x27;101223199012015624&#x27;);#成功insert into course values(1001,&#x27;Java&#x27;),(1002,&#x27;MySQL&#x27;);#成功 1234567891011121314151617mysql&gt; select * from student;+-----+-------+-------------+--------------------+| sid | sname | tel | cardid |+-----+-------+-------------+--------------------+| 1 | 张三 | 13710011002 | 101223199012015623 || 2 | 李四 | 13710011003 | 101223199012015624 |+-----+-------+-------------+--------------------+2 rows in set (0.00 sec)mysql&gt; select * from course;+------+-------+| cid | cname |+------+-------+| 1001 | Java || 1002 | MySQL |+------+-------+2 rows in set (0.00 sec) 12345insert into student_course values(1, 1, 1001, 89),(2, 1, 1002, 90),(3, 2, 1001, 88),(4, 2, 1002, 56);#成功 12345678910mysql&gt; select * from student_course;+----+------+------+-------+| id | sid | cid | score |+----+------+------+-------+| 1 | 1 | 1001 | 89 || 2 | 1 | 1002 | 90 || 3 | 2 | 1001 | 88 || 4 | 2 | 1002 | 56 |+----+------+------+-------+4 rows in set (0.00 sec) 123insert into student_course values (5, 1, 1001, 88);#失败#ERROR 1062 (23000): Duplicate entry &#x27;1-1001&#x27; for key &#x27;sid&#x27; 违反sid-cid的复合唯一 删除唯一约束 添加唯一性约束的列上也会自动创建唯一索引。 删除唯一约束只能通过删除唯一索引的方式删除。 删除时需要指定唯一索引名，唯一索引名就和唯一约束名一样。 如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同；如果是组合列，那么默认和()中排在第一个的列名相同。也可以自定义唯一性约束名。 1SELECT * FROM information_schema.table_constraints WHERE table_name = &#x27;表名&#x27;; #查看都有哪些约束 12ALTER TABLE USER DROP INDEX uk_name_pwd; 注意：可以通过 show index from 表名称;查看表的索引 主键约束 - PRIMARY KEY作用用来唯一标识表中的一行记录。 特点 主键约束相当于唯一约束+非空约束的组合，主键约束列不允许重复，也不允许出现空值。 一个表最多只能有一个主键约束，建立主键约束可以在列级别创建，也可以在表级别上创建。 主键约束对应着表中的一列或者多列（复合主键） 如果是多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复。 MySQL的主键名总是PRIMARY，就算自己命名了主键约束名也没用。 当创建主键约束时，系统默认会在所在的列或列组合上建立对应的主键索引（能够根据主键查询的，就根据主键查询，效率更高）。如果删除主键约束了，主键约束对应的索引就自动删除了。 需要注意的一点是，不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能会破坏数据的完整性。 添加主键约束（1）建表时指定主键约束 1234567891011create table 表名称( 字段名 数据类型 primary key, #列级模式 字段名 数据类型, 字段名 数据类型 );create table 表名称( 字段名 数据类型, 字段名 数据类型, 字段名 数据类型, [constraint 约束名] primary key(字段名) #表级模式); 举例： 1234create table temp( id int primary key, name varchar(20)); 12345678mysql&gt; desc temp;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(20) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+2 rows in set (0.00 sec) 12insert into temp values(1,&#x27;张三&#x27;);#成功insert into temp values(2,&#x27;李四&#x27;);#成功 12345678mysql&gt; select * from temp;+----+------+| id | name |+----+------+| 1 | 张三 || 2 | 李四 |+----+------+2 rows in set (0.00 sec) 12345678insert into temp values(1,&#x27;张三&#x27;);#失败ERROR 1062 (23000): Duplicate（重复） entry（键入，输入） &#x27;1&#x27; for key &#x27;PRIMARY&#x27;insert into temp values(1,&#x27;王五&#x27;);#失败ERROR 1062 (23000): Duplicate entry &#x27;1&#x27; for key &#x27;PRIMARY&#x27;insert into temp values(3,&#x27;张三&#x27;);#成功 123456789mysql&gt; select * from temp;+----+------+| id | name |+----+------+| 1 | 张三 || 2 | 李四 || 3 | 张三 |+----+------+3 rows in set (0.00 sec) 12345insert into temp values(4,null);#成功insert into temp values(null,&#x27;李琦&#x27;);#失败ERROR 1048 (23000): Column &#x27;id&#x27; cannot be null 12345678910mysql&gt; select * from temp;+----+------+| id | name |+----+------+| 1 | 张三 || 2 | 李四 || 3 | 张三 || 4 | NULL |+----+------+4 rows in set (0.00 sec) 123456#演示一个表建立两个主键约束create table temp( id int primary key, name varchar(20) primary key);ERROR 1068 (42000): Multiple（多重的） primary key defined（定义） 再举例： 列级约束 1234CREATE TABLE emp4(id INT PRIMARY KEY AUTO_INCREMENT ,NAME VARCHAR(20)); 表级约束 123456CREATE TABLE emp5(id INT NOT NULL AUTO_INCREMENT,NAME VARCHAR(20),pwd VARCHAR(15),CONSTRAINT emp5_id_pk PRIMARY KEY(id)); （2）建表后增加主键约束 1ALTER TABLE 表名称 ADD PRIMARY KEY(字段列表); #字段列表可以是一个字段，也可以是多个字段，如果是多个字段的话，是复合主键 1ALTER TABLE student ADD PRIMARY KEY (sid); 1ALTER TABLE emp5 ADD PRIMARY KEY(NAME,pwd); 关于复合主键123456create table 表名称( 字段名 数据类型, 字段名 数据类型, 字段名 数据类型, primary key(字段名1,字段名2) #表示字段1和字段2的组合是唯一的，也可以有更多个字段); 12345678910111213141516171819#学生表create table student( sid int primary key, #学号 sname varchar(20) #学生姓名);#课程表create table course( cid int primary key, #课程编号 cname varchar(20) #课程名称);#选课表create table student_course( sid int, cid int, score int, primary key(sid,cid) #复合主键); 12insert into student values(1,&#x27;张三&#x27;),(2,&#x27;李四&#x27;);insert into course values(1001,&#x27;Java&#x27;),(1002,&#x27;MySQL&#x27;); 1234567891011121314151617mysql&gt; select * from student;+-----+-------+| sid | sname |+-----+-------+| 1 | 张三 || 2 | 李四 |+-----+-------+2 rows in set (0.00 sec)mysql&gt; select * from course;+------+-------+| cid | cname |+------+-------+| 1001 | Java || 1002 | MySQL |+------+-------+2 rows in set (0.00 sec) 1insert into student_course values(1, 1001, 89),(1,1002,90),(2,1001,88),(2,1002,56); 12345678910mysql&gt; select * from student_course;+-----+------+-------+| sid | cid | score |+-----+------+-------+| 1 | 1001 | 89 || 1 | 1002 | 90 || 2 | 1001 | 88 || 2 | 1002 | 56 |+-----+------+-------+4 rows in set (0.00 sec) 12insert into student_course values(1, 1001, 100);ERROR 1062 (23000): Duplicate entry &#x27;1-1001&#x27; for key &#x27;PRIMARY&#x27; 123456789mysql&gt; desc student_course;+-------+---------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| sid | int(11) | NO | PRI | NULL | || cid | int(11) | NO | PRI | NULL | || score | int(11) | YES | | NULL | |+-------+---------+------+-----+---------+-------+3 rows in set (0.00 sec) 再举例 123456CREATE TABLE emp6(id INT NOT NULL,NAME VARCHAR(20),pwd VARCHAR(15),CONSTRAINT emp7_pk PRIMARY KEY(NAME,pwd)); 删除主键约束1alter table 表名称 drop primary key; 举例： 1ALTER TABLE student DROP PRIMARY KEY; 1ALTER TABLE emp5 DROP PRIMARY KEY; 说明：删除主键约束，不需要指定主键名，因为一个表只有一个主键，删除主键约束后，非空还存在。 自增列 - AUTO_INCREMENT作用某个字段的值自增 特点和要求（1）一个表最多只能有一个自增长列 （2）当需要产生唯一标识符或顺序值时，可设置自增长 （3）自增长列约束的列必须是键列（主键列，唯一键列） （4）自增约束的列的数据类型必须是整数类型 （5）如果自增列指定了 0 和 null，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接赋值为具体值。 错误演示： 12345create table employee( eid int auto_increment, ename varchar(20));# ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key 12345create table employee( eid int primary key, ename varchar(20) unique key auto_increment);# ERROR 1063 (42000): Incorrect column specifier for column &#x27;ename&#x27; 因为ename不是整数类型 如何指定自增约束（1）建表时 123456789101112create table 表名称( 字段名 数据类型 primary key auto_increment, 字段名 数据类型 unique key not null, 字段名 数据类型 unique key, 字段名 数据类型 not null default 默认值, );create table 表名称( 字段名 数据类型 default 默认值 , 字段名 数据类型 unique key auto_increment, 字段名 数据类型 not null default 默认值,, primary key(字段名)); 1234create table employee( eid int primary key auto_increment, ename varchar(20)); 12345678mysql&gt; desc employee;+-------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+----------------+| eid | int(11) | NO | PRI | NULL | auto_increment || ename | varchar(20) | YES | | NULL | |+-------+-------------+------+-----+---------+----------------+2 rows in set (0.00 sec) （2）建表后 1alter table 表名称 modify 字段名 数据类型 auto_increment; 例如： 1234create table employee( eid int primary key , ename varchar(20)); 1alter table employee modify eid int auto_increment; 12345678mysql&gt; desc employee;+-------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+----------------+| eid | int(11) | NO | PRI | NULL | auto_increment || ename | varchar(20) | YES | | NULL | |+-------+-------------+------+-----+---------+----------------+2 rows in set (0.00 sec) 如何删除自增约束123#alter table 表名称 modify 字段名 数据类型 auto_increment;#给这个字段增加自增约束alter table 表名称 modify 字段名 数据类型; #去掉auto_increment相当于删除 1alter table employee modify eid int; 12345678mysql&gt; desc employee;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| eid | int(11) | NO | PRI | NULL | || ename | varchar(20) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+2 rows in set (0.00 sec) MySQL 8.0新特性—自增变量的持久化在MySQL 8.0之前，自增主键AUTO_INCREMENT的值如果大于max(primary key)+1，在MySQL重启后，会重置AUTO_INCREMENT=max(primary key)+1，这种现象在某些情况下会导致业务主键冲突或者其他难以发现的问题。 在MySQL 5.7版本中，测试步骤如下：创建的数据表中包含自增主键的id字段，语句如下： 123CREATE TABLE test1(id INT PRIMARY KEY AUTO_INCREMENT); 插入4个空值，执行如下： 12INSERT INTO test1VALUES(0),(0),(0),(0); 查询数据表test1中的数据，结果如下： 12345678910mysql&gt; SELECT * FROM test1;+----+| id |+----+| 1 || 2 || 3 || 4 |+----+4 rows in set (0.00 sec) 删除id为4的记录，语句如下： 1DELETE FROM test1 WHERE id = 4; 再次插入一个空值，语句如下： 1INSERT INTO test1 VALUES(0); 查询此时数据表test1中的数据，结果如下： 12345678910mysql&gt; SELECT * FROM test1;+----+| id |+----+| 1 || 2 || 3 || 5 |+----+4 rows in set (0.00 sec) 从结果可以看出，虽然删除了id为4的记录，但是再次插入空值时，并没有重用被删除的4，而是分配了5。删除id为5的记录，结果如下： 1DELETE FROM test1 where id=5; 重启数据库，重新插入一个空值。 1INSERT INTO test1 values(0); 再次查询数据表test1中的数据，结果如下： 12345678910mysql&gt; SELECT * FROM test1;+----+| id |+----+| 1 || 2 || 3 || 4 |+----+4 rows in set (0.00 sec) 从结果可以看出，新插入的0值分配的是4，按照重启前的操作逻辑，此处应该分配6。出现上述结果的主要原因是自增主键没有持久化。在MySQL 5.7系统中，对于自增主键的分配规则，是由InnoDB数据字典内部一个计数器来决定的，而该计数器只在内存中维护，并不会持久化到磁盘中。当数据库重启时，该计数器会被初始化。 在MySQL 8.0版本中，上述测试步骤最后一步的结果如下： 12345678910mysql&gt; SELECT * FROM test1;+----+| id |+----+| 1 || 2 || 3 || 6 |+----+4 rows in set (0.00 sec) 从结果可以看出，自增变量已经持久化了。 MySQL 8.0将自增主键的计数器持久化到重做日志中。每次计数器发生改变，都会将其写入重做日志中。如果数据库重启，InnoDB会根据重做日志中的信息来初始化计数器的内存值。 外键约束 - FOREIGN KEY作用限定某个表的某个字段的引用完整性。 比如：员工表的员工所在部门的选择，必须在部门表能找到对应的部分。 主表和从表/父表和子表主表（父表）：被引用的表，被参考的表 从表（子表）：引用别人的表，参考别人的表 例如：员工表的员工所在部门这个字段的值要参考部门表：部门表是主表，员工表是从表。 例如：学生表、课程表、选课表：选课表的学生和课程要分别参考学生表和课程表，学生表和课程表是主表，选课表是从表。 特点（1）从表的外键列，必须引用/参考主表的主键或唯一约束的列 ​ 为什么？因为被依赖/被参考的值必须是唯一的 （2）在创建外键约束时，如果不给外键约束命名，默认名不是列名，而是自动产生一个外键名（例如 student_ibfk_1;），也可以指定外键约束名。 （3）创建(CREATE)表时就指定外键约束的话，先创建主表，再创建从表 （4）删表时，先删从表（或先删除外键约束），再删除主表 （5）当主表的记录被从表参照时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖该记录的数据，然后才可以删除主表的数据 （6）在“从表”中指定外键约束，并且一个表可以建立多个外键约束 （7）从表的外键列与主表被参照的列名字可以不相同，但是数据类型必须一样，逻辑意义一致。如果类型不一样，创建子表时，就会出现错误“ERROR 1005 (HY000): Can’t create table’database.tablename’(errno: 150)”。 ​ 例如：都是表示部门编号，都是int类型。 （8）当创建外键约束时，系统默认会在所在的列上建立对应的普通索引。但是索引名是外键的约束名。（根据外键查询效率很高） （9）删除外键约束后，必须手动删除对应的索引 添加外键约束（1）建表时 123456789101112131415create table 主表名称( 字段1 数据类型 primary key, 字段2 数据类型);create table 从表名称( 字段1 数据类型 primary key, 字段2 数据类型, [CONSTRAINT &lt;外键约束名称&gt;] FOREIGN KEY（从表的某个字段) references 主表名(被参考字段));#(从表的某个字段)的数据类型必须与主表名(被参考字段)的数据类型一致，逻辑意义也一样#(从表的某个字段)的字段名可以与主表名(被参考字段)的字段名一样，也可以不一样-- FOREIGN KEY: 在表级指定子表中的列-- REFERENCES: 标示在父表中的列 12345678910111213141516create table dept( #主表 did int primary key, #部门编号 dname varchar(50) #部门名称);create table emp(#从表 eid int primary key, #员工编号 ename varchar(5), #员工姓名 deptid int, #员工所在的部门 foreign key (deptid) references dept(did) #在从表中指定外键约束 #emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号);说明：（1）主表dept必须先创建成功，然后才能创建emp表，指定外键成功。（2）删除表时，先删除从表emp，再删除主表dept （2）建表后 一般情况下，表与表的关联都是提前设计好了的，因此，会在创建表的时候就把外键约束定义好。不过，如果需要修改表的设计（比如添加新的字段，增加新的关联关系），但没有预先定义外键约束，那么，就要用修改表的方式来补充定义。 格式： 1ALTER TABLE 从表名 ADD [CONSTRAINT 约束名] FOREIGN KEY (从表的字段) REFERENCES 主表名(被引用字段) [on update xx][on delete xx]; 举例： 12ALTER TABLE emp1ADD [CONSTRAINT emp_dept_id_fk] FOREIGN KEY(dept_id) REFERENCES dept(dept_id); 举例： 1234567891011create table dept( did int primary key, #部门编号 dname varchar(50) #部门名称);create table emp( eid int primary key, #员工编号 ename varchar(5), #员工姓名 deptid int #员工所在的部门);#这两个表创建时，没有指定外键的话，那么创建顺序是随意 1alter table emp add foreign key (deptid) references dept(did); 演示问题（1）失败：不是键列 123456789101112create table dept( did int , #部门编号 dname varchar(50) #部门名称);create table emp( eid int primary key, #员工编号 ename varchar(5), #员工姓名 deptid int, #员工所在的部门 foreign key (deptid) references dept(did));#ERROR 1215 (HY000): Cannot add foreign key constraint 原因是dept的did不是键列 （2）失败：数据类型不一致 123456789101112create table dept( did int primary key, #部门编号 dname varchar(50) #部门名称);create table emp( eid int primary key, #员工编号 ename varchar(5), #员工姓名 deptid char, #员工所在的部门 foreign key (deptid) references dept(did));#ERROR 1215 (HY000): Cannot add foreign key constraint 原因是从表的deptid字段和主表的did字段的数据类型不一致，并且要它俩的逻辑意义一致 （3）成功，两个表字段名一样 12345678910111213create table dept( did int primary key, #部门编号 dname varchar(50) #部门名称);create table emp( eid int primary key, #员工编号 ename varchar(5), #员工姓名 did int, #员工所在的部门 foreign key (did) references dept(did) #emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号 #是否重名没问题，因为两个did在不同的表中); （4）添加、删除、修改问题 123456789101112create table dept( did int primary key, #部门编号 dname varchar(50) #部门名称);create table emp( eid int primary key, #员工编号 ename varchar(5), #员工姓名 deptid int, #员工所在的部门 foreign key (deptid) references dept(did) #emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号); 1234567insert into dept values(1001,&#x27;教学部&#x27;);insert into dept values(1003, &#x27;财务部&#x27;);insert into emp values(1,&#x27;张三&#x27;,1001); #添加从表记录成功，在添加这条记录时，要求部门表有1001部门insert into emp values(2,&#x27;李四&#x27;,1005);#添加从表记录失败ERROR 1452 (23000): Cannot add（添加） or update（修改） a child row: a foreign key constraint fails (`atguigudb`.`emp`, CONSTRAINT `emp_ibfk_1` FOREIGN KEY (`deptid`) REFERENCES `dept` (`did`)) 从表emp添加记录失败，因为主表dept没有1005部门 12345678910111213141516mysql&gt; select * from dept;+------+--------+| did | dname |+------+--------+| 1001 | 教学部 || 1003 | 财务部 |+------+--------+2 rows in set (0.00 sec)mysql&gt; select * from emp;+-----+-------+--------+| eid | ename | deptid |+-----+-------+--------+| 1 | 张三 | 1001 |+-----+-------+--------+1 row in set (0.00 sec) 1234567update emp set deptid = 1002 where eid = 1;#修改从表失败 ERROR 1452 (23000): Cannot add（添加） or update（修改） a child row（子表的记录）: a foreign key constraint fails（外键约束失败） (`atguigudb`.`emp`, CONSTRAINT `emp_ibfk_1` FOREIGN KEY (`deptid`) REFERENCES `dept` (`did`)) #部门表did字段现在没有1002的值，所以员工表中不能修改员工所在部门deptid为1002update dept set did = 1002 where did = 1001;#修改主表失败ERROR 1451 (23000): Cannot delete（删除） or update（修改） a parent row（父表的记录）: a foreign key constraint fails (`atguigudb`.`emp`, CONSTRAINT `emp_ibfk_1` FOREIGN KEY (`deptid`) REFERENCES `dept` (`did`)) #部门表did的1001字段已经被emp引用了，所以部门表的1001字段就不能修改了。update dept set did = 1002 where did = 1003;#修改主表成功 因为部门表的1003部门没有被emp表引用，所以可以修改 12delete from dept where did=1001; #删除主表失败ERROR 1451 (23000): Cannot delete（删除） or update（修改） a parent row（父表记录）: a foreign key constraint fails (`atguigudb`.`emp`, CONSTRAINT `emp_ibfk_1` FOREIGN KEY (`deptid`) REFERENCES `dept` (`did`)) #因为部门表did的1001字段已经被emp引用了，所以部门表的1001字段对应的记录就不能被删除 总结：约束关系是针对双方的 添加了外键约束后，主表的修改和删除数据受约束 添加了外键约束后，从表的添加和修改数据受约束 在从表上建立外键，要求主表必须存在 删除主表时，要求从表从表先删除，或将从表中外键引用该主表的关系先删除 约束等级 Cascade方式：在父表上update/delete记录时，同步update/delete掉子表的匹配记录 Set null方式：在父表上update/delete记录时，将子表上匹配记录的列设为null，但是要注意子表的外键列不能为not null No action方式：如果子表中有匹配的记录，则不允许对父表对应候选键进行update/delete操作 Restrict方式：同no action， 都是立即检查外键约束 Set default方式（在可视化工具SQLyog中可能显示空白）：父表有变更时，子表将外键列设置成一个默认的值，但Innodb不能识别 如果没有指定等级，就相当于Restrict方式。 对于外键约束，最好是采用: ON UPDATE CASCADE ON DELETE RESTRICT 的方式。 （1）演示1：on update cascade on delete set null 123456789101112create table dept( did int primary key, #部门编号 dname varchar(50) #部门名称);create table emp( eid int primary key, #员工编号 ename varchar(5), #员工姓名 deptid int, #员工所在的部门 foreign key (deptid) references dept(did) on update cascade on delete set null #把修改操作设置为级联修改等级，把删除操作设置为set null等级); 123456789insert into dept values(1001,&#x27;教学部&#x27;);insert into dept values(1002, &#x27;财务部&#x27;);insert into dept values(1003, &#x27;咨询部&#x27;);insert into emp values(1,&#x27;张三&#x27;,1001); #在添加这条记录时，要求部门表有1001部门insert into emp values(2,&#x27;李四&#x27;,1001);insert into emp values(3,&#x27;王五&#x27;,1002); 1234mysql&gt; select * from dept;mysql&gt; select * from emp; 123456789101112131415161718192021222324#修改主表成功，从表也跟着修改，修改了主表被引用的字段1002为1004，从表的引用字段就跟着修改为1004了mysql&gt; update dept set did = 1004 where did = 1002;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from dept;+------+--------+| did | dname |+------+--------+| 1001 | 教学部 || 1003 | 咨询部 || 1004 | 财务部 | #原来是1002，修改为1004+------+--------+3 rows in set (0.00 sec)mysql&gt; select * from emp;+-----+-------+--------+| eid | ename | deptid |+-----+-------+--------+| 1 | 张三 | 1001 || 2 | 李四 | 1001 || 3 | 王五 | 1004 | #原来是1002，跟着修改为1004+-----+-------+--------+3 rows in set (0.00 sec) 12345678910111213141516171819202122#删除主表的记录成功，从表对应的字段的值被修改为nullmysql&gt; delete from dept where did = 1001;Query OK, 1 row affected (0.01 sec)mysql&gt; select * from dept;+------+--------+| did | dname | #记录1001部门被删除了+------+--------+| 1003 | 咨询部 || 1004 | 财务部 |+------+--------+2 rows in set (0.00 sec)mysql&gt; select * from emp;+-----+-------+--------+| eid | ename | deptid |+-----+-------+--------+| 1 | 张三 | NULL | #原来引用1001部门的员工，deptid字段变为null| 2 | 李四 | NULL || 3 | 王五 | 1004 |+-----+-------+--------+3 rows in set (0.00 sec) （2）演示2：on update set null on delete cascade 123456789101112create table dept( did int primary key, #部门编号 dname varchar(50) #部门名称);create table emp( eid int primary key, #员工编号 ename varchar(5), #员工姓名 deptid int, #员工所在的部门 foreign key (deptid) references dept(did) on update set null on delete cascade #把修改操作设置为set null等级，把删除操作设置为级联删除等级); 1234567insert into dept values(1001,&#x27;教学部&#x27;);insert into dept values(1002, &#x27;财务部&#x27;);insert into dept values(1003, &#x27;咨询部&#x27;);insert into emp values(1,&#x27;张三&#x27;,1001); #在添加这条记录时，要求部门表有1001部门insert into emp values(2,&#x27;李四&#x27;,1001);insert into emp values(3,&#x27;王五&#x27;,1002); 12345678910111213141516171819mysql&gt; select * from dept;+------+--------+| did | dname |+------+--------+| 1001 | 教学部 || 1002 | 财务部 || 1003 | 咨询部 |+------+--------+3 rows in set (0.00 sec)mysql&gt; select * from emp;+-----+-------+--------+| eid | ename | deptid |+-----+-------+--------+| 1 | 张三 | 1001 || 2 | 李四 | 1001 || 3 | 王五 | 1002 |+-----+-------+--------+3 rows in set (0.00 sec) 123456789101112131415161718192021222324#修改主表，从表对应的字段设置为nullmysql&gt; update dept set did = 1004 where did = 1002;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from dept;+------+--------+| did | dname |+------+--------+| 1001 | 教学部 || 1003 | 咨询部 || 1004 | 财务部 | #原来did是1002+------+--------+3 rows in set (0.00 sec)mysql&gt; select * from emp;+-----+-------+--------+| eid | ename | deptid |+-----+-------+--------+| 1 | 张三 | 1001 || 2 | 李四 | 1001 || 3 | 王五 | NULL | #原来deptid是1002，因为部门表1002被修改了，1002没有对应的了，就设置为null+-----+-------+--------+3 rows in set (0.00 sec) 123456789101112131415161718192021#删除主表的记录成功，主表的1001行被删除了，从表相应的记录也被删除了mysql&gt; delete from dept where did=1001;Query OK, 1 row affected (0.00 sec)mysql&gt; select * from dept;+------+--------+| did | dname | #部门表中1001部门被删除+------+--------+| 1003 | 咨询部 || 1004 | 财务部 |+------+--------+2 rows in set (0.00 sec)mysql&gt; select * from emp;+-----+-------+--------+| eid | ename | deptid |#原来1001部门的员工也被删除了+-----+-------+--------+| 3 | 王五 | NULL |+-----+-------+--------+1 row in set (0.00 sec) （3）演示：on update cascade on delete cascade 123456789101112create table dept( did int primary key, #部门编号 dname varchar(50) #部门名称);create table emp( eid int primary key, #员工编号 ename varchar(5), #员工姓名 deptid int, #员工所在的部门 foreign key (deptid) references dept(did) on update cascade on delete cascade #把修改操作设置为级联修改等级，把删除操作也设置为级联删除等级); 1234567insert into dept values(1001,&#x27;教学部&#x27;);insert into dept values(1002, &#x27;财务部&#x27;);insert into dept values(1003, &#x27;咨询部&#x27;);insert into emp values(1,&#x27;张三&#x27;,1001); #在添加这条记录时，要求部门表有1001部门insert into emp values(2,&#x27;李四&#x27;,1001);insert into emp values(3,&#x27;王五&#x27;,1002); 12345678910111213141516171819mysql&gt; select * from dept;+------+--------+| did | dname |+------+--------+| 1001 | 教学部 || 1002 | 财务部 || 1003 | 咨询部 |+------+--------+3 rows in set (0.00 sec)mysql&gt; select * from emp;+-----+-------+--------+| eid | ename | deptid |+-----+-------+--------+| 1 | 张三 | 1001 || 2 | 李四 | 1001 || 3 | 王五 | 1002 |+-----+-------+--------+3 rows in set (0.00 sec) 123456789101112131415161718192021222324#修改主表，从表对应的字段自动修改mysql&gt; update dept set did = 1004 where did = 1002;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from dept;+------+--------+| did | dname |+------+--------+| 1001 | 教学部 || 1003 | 咨询部 || 1004 | 财务部 | #部门1002修改为1004+------+--------+3 rows in set (0.00 sec)mysql&gt; select * from emp;+-----+-------+--------+| eid | ename | deptid |+-----+-------+--------+| 1 | 张三 | 1001 || 2 | 李四 | 1001 || 3 | 王五 | 1004 | #级联修改+-----+-------+--------+3 rows in set (0.00 sec) 1234567891011121314151617181920#删除主表的记录成功，主表的1001行被删除了，从表相应的记录也被删除了mysql&gt; delete from dept where did=1001;Query OK, 1 row affected (0.00 sec)mysql&gt; select * from dept;+------+--------+| did | dname | #1001部门被删除了+------+--------+| 1003 | 咨询部 || 1004 | 财务部 | +------+--------+2 rows in set (0.00 sec)mysql&gt; select * from emp;+-----+-------+--------+| eid | ename | deptid | #1001部门的员工也被删除了+-----+-------+--------+| 3 | 王五 | 1004 |+-----+-------+--------+1 row in set (0.00 sec) 删除外键约束流程如下： 12345678910(1)第一步先查看约束名和删除外键约束SELECT * FROM information_schema.table_constraints WHERE table_name = &#x27;表名称&#x27;;#查看某个表的约束名ALTER TABLE 从表名 DROP FOREIGN KEY 外键约束名;（2）第二步查看索引名和删除索引。（注意，只能手动删除）SHOW INDEX FROM 表名称; #查看某个表的索引名ALTER TABLE 从表名 DROP INDEX 索引名; 举例： 123456mysql&gt; SELECT * FROM information_schema.table_constraints WHERE table_name = &#x27;emp&#x27;;mysql&gt; alter table emp drop foreign key emp_ibfk_1;Query OK, 0 rows affected (0.02 sec)Records: 0 Duplicates: 0 Warnings: 0 1234567mysql&gt; show index from emp;mysql&gt; alter table emp drop index deptid;Query OK, 0 rows affected (0.01 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; show index from emp; 开发场景问题1：如果两个表之间有关系（一对一、一对多），比如：员工表和部门表（一对多），它们之间是否一定要建外键约束？ 答：不是的 问题2：建和不建外键约束有什么区别？ 答：建外键约束，你的操作（创建表、删除表、添加、修改、删除）会受到限制，从语法层面受到限制。例如：在员工表中不可能添加一个员工信息，它的部门的值在部门表中找不到。 不建外键约束，你的操作（创建表、删除表、添加、修改、删除）不受限制，要保证数据的引用完整性，只能依靠程序员的自觉，或者是在Java程序中进行限定。例如：在员工表中，可以添加一个员工的信息，它的部门指定为一个完全不存在的部门。 问题3：那么建和不建外键约束和查询有没有关系？ 答：没有 在 MySQL 里，外键约束是有成本的，需要消耗系统资源。对于大并发的 SQL 操作，有可能会不适合。比如大型网站的中央数据库，可能会因为外键约束的系统开销而变得非常慢。所以， MySQL 允许你不使用系统自带的外键约束，在应用层面完成检查数据一致性的逻辑。也就是说，即使你不用外键约束，也要想办法通过应用层面的附加逻辑，来实现外键约束的功能，确保数据的一致性。 阿里开发规范【强制】不得使用外键与级联，一切外键概念必须在应用层解决。 说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。 检查约束 - CHECK作用检查某个字段的值是否符号xx要求，一般指的是值的范围 MySQL 5.7 不支持MySQL5.7 可以使用check约束，但check约束对数据验证没有任何作用。添加数据时，没有任何错误或警告 但是MySQL 8.0中可以使用check约束了。 12345create table employee( eid int primary key, ename varchar(5), gender char check (&#x27;男&#x27; or &#x27;女&#x27;)); 1insert into employee values(1,&#x27;张三&#x27;,&#x27;妖&#x27;); 1234567mysql&gt; select * from employee;+-----+-------+--------+| eid | ename | gender |+-----+-------+--------+| 1 | 张三 | 妖 |+-----+-------+--------+1 row in set (0.00 sec) 再举例 123456CREATE TABLE temp(id INT AUTO_INCREMENT,NAME VARCHAR(20),age INT CHECK(age &gt; 20),PRIMARY KEY(id)); 再举例 1age tinyint check(age &gt;20) 或 sex char(2) check(sex in(‘男’,’女’)) 再举例 1CHECK(height&gt;=0 AND height&lt;3) 默认值约束 - DEFAULT作用给某个字段/某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默认值。 如何给字段加默认值（1）建表时 123456789101112131415create table 表名称( 字段名 数据类型 primary key, 字段名 数据类型 unique key not null, 字段名 数据类型 unique key, 字段名 数据类型 not null default 默认值, );create table 表名称( 字段名 数据类型 default 默认值 , 字段名 数据类型 not null default 默认值, 字段名 数据类型 not null default 默认值, primary key(字段名), unique key(字段名));说明：默认值约束一般不在唯一键和主键列上加 123456create table employee( eid int primary key, ename varchar(20) not null, gender char default &#x27;男&#x27;, tel char(11) not null default &#x27;&#x27; #默认是空字符串); 12345678910mysql&gt; desc employee;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| eid | int(11) | NO | PRI | NULL | || ename | varchar(20) | NO | | NULL | || gender | char(1) | YES | | 男 | || tel | char(11) | NO | | | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec) 1insert into employee values(1,&#x27;汪飞&#x27;,&#x27;男&#x27;,&#x27;13700102535&#x27;); #成功 1234567mysql&gt; select * from employee;+-----+-------+--------+-------------+| eid | ename | gender | tel |+-----+-------+--------+-------------+| 1 | 汪飞 | 男 | 13700102535 |+-----+-------+--------+-------------+1 row in set (0.00 sec) 1insert into employee(eid,ename) values(2,&#x27;天琪&#x27;); #成功 12345678mysql&gt; select * from employee;+-----+-------+--------+-------------+| eid | ename | gender | tel |+-----+-------+--------+-------------+| 1 | 汪飞 | 男 | 13700102535 || 2 | 天琪 | 男 | |+-----+-------+--------+-------------+2 rows in set (0.00 sec) 123insert into employee(eid,ename) values(3,&#x27;二虎&#x27;);#ERROR 1062 (23000): Duplicate entry &#x27;&#x27; for key &#x27;tel&#x27; #如果tel有唯一性约束的话会报错，如果tel没有唯一性约束，可以添加成功 再举例： 12345CREATE TABLE myemp(id INT AUTO_INCREMENT PRIMARY KEY,NAME VARCHAR(15),salary DOUBLE(10,2) DEFAULT 2000); （2）建表后 12345alter table 表名称 modify 字段名 数据类型 default 默认值;#如果这个字段原来有非空约束，你还保留非空约束，那么在加默认值约束时，还得保留非空约束，否则非空约束就被删除了#同理，在给某个字段加非空约束也一样，如果这个字段原来有默认值约束，你想保留，也要在modify语句中保留默认值约束，否则就删除了alter table 表名称 modify 字段名 数据类型 default 默认值 not null; 123456create table employee( eid int primary key, ename varchar(20), gender char, tel char(11) not null); 12345678910mysql&gt; desc employee;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| eid | int(11) | NO | PRI | NULL | || ename | varchar(20) | YES | | NULL | || gender | char(1) | YES | | NULL | || tel | char(11) | NO | | NULL | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec) 12alter table employee modify gender char default &#x27;男&#x27;; #给gender字段增加默认值约束alter table employee modify tel char(11) default &#x27;&#x27;; #给tel字段增加默认值约束 12345678910mysql&gt; desc employee;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| eid | int(11) | NO | PRI | NULL | || ename | varchar(20) | YES | | NULL | || gender | char(1) | YES | | 男 | || tel | char(11) | YES | | | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec) 1alter table employee modify tel char(11) default &#x27;&#x27; not null;#给tel字段增加默认值约束，并保留非空约束 12345678910mysql&gt; desc employee;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| eid | int(11) | NO | PRI | NULL | || ename | varchar(20) | YES | | NULL | || gender | char(1) | YES | | 男 | || tel | char(11) | NO | | | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec) 如何删除默认值约束123alter table 表名称 modify 字段名 数据类型 ;#删除默认值约束，也不保留非空约束alter table 表名称 modify 字段名 数据类型 not null; #删除默认值约束，保留非空约束 12alter table employee modify gender char; #删除gender字段默认值约束，如果有非空约束，也一并删除alter table employee modify tel char(11) not null;#删除tel字段默认值约束，保留非空约束 12345678910mysql&gt; desc employee;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| eid | int(11) | NO | PRI | NULL | || ename | varchar(20) | YES | | NULL | || gender | char(1) | YES | | NULL | || tel | char(11) | NO | | NULL | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec) 常见问题问题1、为什么建表时，加 not null default ‘’ 或 default 0 答：不想让表中出现null值。 问题2、为什么不想要 null 的值 答:（1）不好比较。null是一种特殊值，比较时只能用专门的is null 和 is not null来比较。碰到运算符，通常返回null。 ​ （2）效率不高。影响提高索引效果。因此，我们往往在建表时 not null default ‘’ 或 default 0 问题3、带AUTO_INCREMENT约束的字段值是从1开始的吗？在MySQL中，默认AUTO_INCREMENT的初始值是1，每新增一条记录，字段值自动加1。设置自增属性（AUTO_INCREMENT）的时候，还可以指定第一条插入记录的自增字段的值，这样新插入的记录的自增字段值从初始值开始递增，如在表中插入第一条记录，同时指定id值为5，则以后插入的记录的id值就会从6开始往上增加。添加主键约束时，往往需要设置字段自动增加属性。 问题4、并不是每个表都可以任意选择存储引擎？外键约束（FOREIGN KEY）不能跨引擎使用。 MySQL支持多种存储引擎，每一个表都可以指定一个不同的存储引擎，需要注意的是：外键约束是用来保证数据的参照完整性的，如果表之间需要关联外键，却指定了不同的存储引擎，那么这些表之间是不能创建外键约束的。所以说，存储引擎的选择也不完全是随意的。 SQL高级SQL 的执行顺序与原理SQL执行顺序1. 关键字的顺序是不能颠倒的： 1SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ... LIMIT... 2.SELECT 语句的执行顺序（在 MySQL 和 Oracle 中，SELECT 执行顺序基本相同）： 1FROM -&gt; WHERE -&gt; GROUP BY -&gt; HAVING -&gt; SELECT 的字段 -&gt; DISTINCT -&gt; ORDER BY -&gt; LIMIT 比如你写了一个 SQL 语句，那么它的关键字顺序和执行顺序是下面这样的： 1234567SELECT DISTINCT player_id, player_name, count(*) as num # 顺序 5FROM player JOIN team ON player.team_id = team.team_id # 顺序 1WHERE height &gt; 1.80 # 顺序 2GROUP BY player.team_id # 顺序 3HAVING num &gt; 2 # 顺序 4ORDER BY num DESC # 顺序 6LIMIT 2 # 顺序 7 在 SELECT 语句执行这些步骤的时候，每个步骤都会产生一个虚拟表，然后将这个虚拟表传入下一个步骤中作为输入。需要注意的是，这些步骤隐含在 SQL 的执行过程中，对于我们来说是不可见的。 SQL执行原理SELECT 是先执行 FROM 这一步的。在这个阶段，如果是多张表联查，还会经历下面的几个步骤： 首先先通过 CROSS JOIN 求笛卡尔积，相当于得到虚拟表 vt（virtual table）1-1； 通过 ON 进行筛选，在虚拟表 vt1-1 的基础上进行筛选，得到虚拟表 vt1-2； 添加外部行。如果我们使用的是左连接、右连接或者完全连接，就会涉及到外部行，也就是在虚拟表 vt1-2 的基础上增加外部行，得到虚拟表 vt1-3。 如果我们操作的是两张以上的表，还会重复上面的步骤，直到所有表都被处理完为止。这个过程得到是我们的原始数据。 当我们拿到了查询数据表的原始数据，也就是最终的虚拟表 vt1，就可以在此基础上再进行 WHERE 阶段。在这个阶段中，会根据 vt1 表的结果进行筛选过滤，得到虚拟表 vt2。 然后进入第三步和第四步，也就是 GROUP 和 HAVING 阶段。在这个阶段中，实际上是在虚拟表 vt2 的基础上进行分组和分组过滤，得到中间的虚拟表 vt3 和 vt4。 当我们完成了条件筛选部分之后，就可以筛选表中提取的字段，也就是进入到 SELECT 和 DISTINCT 阶段。 首先在 SELECT 阶段会提取想要的字段，然后在 DISTINCT 阶段过滤掉重复的行，分别得到中间的虚拟表 vt5-1 和 vt5-2。 当我们提取了想要的字段数据之后，就可以按照指定的字段进行排序，也就是 ORDER BY 阶段，得到虚拟表 vt6。 最后在 vt6 的基础上，取出指定行的记录，也就是 LIMIT 阶段，得到最终的结果，对应的是虚拟表 vt7。 当然我们在写 SELECT 语句的时候，不一定存在所有的关键字，相应的阶段就会省略。 使用正则表达式查询正则表达式通常被用来检索或替换那些符合某个模式的文本内容，根据指定的匹配模式匹配文本中符合要求的特殊字符串。例如，从一个文本文件中提取电话号码，查找一篇文章中重复的单词或者替换用户输入的某些敏感词语等，这些地方都可以使用正则表达式。正则表达式强大而且灵活，可以应用于非常复杂的查询。 MySQL中使用REGEXP关键字指定正则表达式的字符匹配模式。下表列出了REGEXP操作符中常用字符匹配列表。 1. 查询以特定字符或字符串开头的记录字符‘^’匹配以特定字符或者字符串开头的文本。 在fruits表中，查询f_name字段以字母‘b’开头的记录，SQL语句如下： 1SELECT * FROM fruits WHERE f_name REGEXP &#x27;^b&#x27;; 2. 查询以特定字符或字符串结尾的记录字符‘$’匹配以特定字符或者字符串结尾的文本。 在fruits表中，查询f_name字段以字母‘y’结尾的记录，SQL语句如下： 1SELECT * FROM fruits WHERE f_name REGEXP &#x27;y$&#x27;; 3. 用符号”.”来替代字符串中的任意一个字符字符‘.’匹配任意一个字符。在fruits表中，查询f_name字段值包含字母‘a’与‘g’且两个字母之间只有一个字母的记录，SQL语句如下： 1SELECT * FROM fruits WHERE f_name REGEXP &#x27;a.g&#x27;; 4. 使用”*”和”+”来匹配多个字符星号‘*’匹配前面的字符任意多次，包括0次。加号‘+’匹配前面的字符至少一次。 在fruits表中，查询f_name字段值以字母‘b’开头且‘b’后面出现字母‘a’的记录，SQL语句如下： 1SELECT * FROM fruits WHERE f_name REGEXP &#x27;^ba*&#x27;; 在fruits表中，查询f_name字段值以字母‘b’开头且‘b’后面出现字母‘a’至少一次的记录，SQL语句如下： 1SELECT * FROM fruits WHERE f_name REGEXP &#x27;^ba+&#x27;; 5. 匹配指定字符串正则表达式可以匹配指定字符串，只要这个字符串在查询文本中即可，如要匹配多个字符串，多个字符串之间使用分隔符‘|’隔开。 在fruits表中，查询f_name字段值包含字符串“on”的记录，SQL语句如下： 1mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;on&#x27;; 在fruits表中，查询f_name字段值包含字符串“on”或者“ap”的记录，SQL语句如下： 1mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;on|ap&#x27;; 之前介绍过，LIKE运算符也可以匹配指定的字符串，但与REGEXP不同，LIKE匹配的字符串如果在文本中间出现，则找不到它，相应的行也不会返回。REGEXP在文本内进行匹配，如果被匹配的字符串在文本中出现，REGEXP将会找到它，相应的行也会被返回。对比结果如下所示。 在fruits表中，使用LIKE运算符查询f_name字段值为“on”的记录，SQL语句如下： 12mysql&gt; SELECT * FROM fruits WHERE f_name like &#x27;on&#x27;;Empty set(0.00 sec) 6. 匹配指定字符中的任意一个方括号“[]”指定一个字符集合，只匹配其中任何一个字符，即为所查找的文本。 在fruits表中，查找f_name字段中包含字母‘o’或者‘t’的记录，SQL语句如下： 1mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;[ot]&#x27;; 在fruits表中，查询s_id字段中包含4、5或者6的记录，SQL语句如下： 1mysql&gt; SELECT * FROM fruits WHERE s_id REGEXP &#x27;[456]&#x27;; 7. 匹配指定字符以外的字符“[^字符集合]”匹配不在指定集合中的任何字符。 在fruits表中，查询f_id字段中包含字母ae和数字12以外字符的记录，SQL语句如下： 1mysql&gt; SELECT * FROM fruits WHERE f_id REGEXP &#x27;[^a-e1-2]&#x27;; 8. 使用{n,}或者{n,m}来指定字符串连续出现的次数“字符串{n,}”表示至少匹配n次前面的字符；“字符串{n,m}”表示匹配前面的字符串不少于n次，不多于m次。例如，a{2,}表示字母a连续出现至少2次，也可以大于2次；a{2,4}表示字母a连续出现最少2次，最多不能超过4次。 在fruits表中，查询f_name字段值出现字母‘x’至少2次的记录，SQL语句如下： 1mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;x&#123;2,&#125;&#x27;; 在fruits表中，查询f_name字段值出现字符串“ba”最少1次、最多3次的记录，SQL语句如下： 1mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;ba&#123;1,3&#125;&#x27;;","categories":[{"name":"数据分析","slug":"数据分析","permalink":"http://yinzhm.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}],"tags":[{"name":"数据分析","slug":"数据分析","permalink":"http://yinzhm.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yinzhm.gitee.io/tags/MySQL/"}]},{"title":"《用数据讲故事》读后感","slug":"用数据讲故事","date":"2023-03-10T12:47:47.000Z","updated":"2023-03-28T14:26:14.983Z","comments":true,"path":"2023/03/10/用数据讲故事/","link":"","permalink":"http://yinzhm.gitee.io/2023/03/10/%E7%94%A8%E6%95%B0%E6%8D%AE%E8%AE%B2%E6%95%85%E4%BA%8B/","excerpt":"","text":"用数据讲故事我们要的不是数据，而是数据告诉我们的事实 对象、内容、方式 首先，你在跟谁沟通？深入了解你的受众是谁以及他们如何看待你非常重要。这可以帮助你发现你与受众的共识，从而确保他们能够听懂你的信息。 其次，你希望受众了解哪些内容或者做什么？你应该明确你希望受众如何反应，并考虑你的沟通方式以及整体基调。 对象你的受众你的受众越具体，你就越能成功地进行沟通。你对受众了解得越多，就越能准确理解如何与之产生共鸣，如何在沟通中满足双方的需求。 你自己这次沟通是你们首次见面，抑或双方已经相识？对方已经视你为可以信赖的专家，抑或你还需要努力树立威信？这些考虑对于如何组织沟通的结构以及是否及何时使用数据都非常重要，并且会影响你所讲的整个故事的顺序和信息量。 内容行为你需要受众了解或者做什么？你应该通过这个问题想明白如何使沟通对受众有意义，并就他们为何要关心你说的话建立一个清晰的认识。你应该每时每刻都有一个目标，并希望受众了解或者完成它。如果你不能简洁而清楚地表达这个目标，那就应该首先重新审视是否需要沟通。 人们通常认为受众比演讲者更了解话题，因此应该是受众选择是否以及如何对展示的信息作出反应，但这样的假设是错误的。当你分析数据并进行沟通时，你很有可能是最了解数据的人——你是该主题的专家。因此你才是解读数据并帮助人们理解和作出反应的人。总之，基于分析作出具体的观察和推荐时，用数据进行沟通的人需要更为自信。 如果真的不适合针对行为提出明确的建议，发起讨论也是值得鼓励的。对候选行为提出建议是让交流继续下去的明智之举，因为这会让受众有东西可以参照而非从空白开始。如果你只简单地展示数据，受众很容易在说一句“真有趣”之后转入下一件事情。但如果你要求他行动，他就得决定是否回应。这就引出了更有建设性的反馈，从而让对话也更有建设性——而如果你最开始不针对行为提出建议，或许一直都在原地踏步。 当你决定想让受众采取什么行动时，可以参考以下表示行为的词语： 接受|同意|开始|相信|改变|协作|着手|创建|辩护|想要|分辨|行动|移情|授权|鼓励|参与|建立|检查|促进|熟悉|形成|实现|包括|影响|投入|鼓舞|了解|学习|喜欢|劝说|计划|提升|追求|推荐|接收|记住|报告|答复|促成|支持|简化|启动|尝试|理解|验证 机制你会如何与受众沟通？与受众沟通的方法会对以下因素产生影响：对受众如何消化信息的可控程度和信息披露的详细程度。 你作为演讲者对演讲有完全的控制权。你决定了受众看到的内容以及何时看到。你可以针对现场的种种迹象进行调整：加快、减慢或者针对某一点调整详细程度。不是所有的细节都需要直接包含在幻灯片或者展示文件中，因为你作为主题专家可以现场回答演示过程中的提问，而且不管涉及的细节是否呈现在演示当中，你都应该做好回答的准备。 别把幻灯片当作提词器——不要在演示的时候大声阅读每一页幻灯片，这对受众而言是很糟糕的体验。你需要熟悉演讲的内容才能做好演示，这意味着练习、练习再练习。保持幻灯片内容简洁，只呈现能够强化演讲的内容。你要借助幻灯片想起下一个话题，但不应该把它当作讲稿。 方式最终，只有在明确了受众是谁以及希望他们了解或做什么之后，我们才能针对数据问出下面的问题：究竟有什么样的数据可以用来表达观点？数据成为了你所讲述的故事的支撑性依据。 询问上下文：实用问题通常沟通都是为了完成别人的请求：客户、利益相关者或者你的老板。这代表你可能无法掌握全部的上下文，需要询问请求者从而完全了解情况。有时请求者脑中还有额外的上下文，但是误以为是已知信息或者不想说出来。下面是一些可以帮助你梳理出上下文的问题。如果你是请求的一方，可以提前思考如何回答这些问题。 有哪些至关重要的背景信息？ 受众和决策者都是谁？对他们有什么了解？ 受众可能对话题存在什么样的正面或者负面偏见？ 有什么样的数据可以支撑这个案例？这些数据是受众所熟悉的还是新的？ 有什么风险？什么因素会弱化案例？我们是否需要主动提出来？ 成功的产出是什么样的？ 如果时间有限或者只能用一句话告诉受众需要做什么，你会说什么？ 三分钟故事和中心思想这两个概念背后的理念就是将沟通提炼成一小段话并最终精炼出一句简洁的陈述。你必须非常了解情况——知道什么是最重要的点，什么在最精炼的版本中无足轻重。虽然听起来容易，但简洁往往比详细更有挑战性。 如果你只有三分钟的时间把必要的信息告诉受众，你会讲什么？这是确保你对所要讲的故事理解得清晰透彻的好办法。能做到这一点，你在演讲时就可以摆脱对幻灯片或者图表的依赖。这在很多场景下都很实用：老板问你正在忙什么时；与利益相关方同在一部电梯里，想要快速做一个简短的汇报时；日程上定好的半小时缩短到十分钟乃至五分钟时。如果你非常清楚需要沟通什么，就能适应任何时间空档，即便与你之前准备的不同。 中心思想包含三个组成部分： 必须能陈述你独特的观点； 必须切中要害； 必须是一个完整的句子。 故事板故事板大概是你为确保沟通切题所能提前做的最重要的一件事了。它能确立沟通的结构，是打算创建的内容的可视化大纲。尽管故事板会随着你深入细节而改变，但尽早确定结构将带你走向成功。如果可以，尽量在这一步获得客户或利益相关者的认同。这有助于你确保你的计划是与需求一致的。 提到故事板，我最大的建议是不要从幻灯片软件开始。很容易还没想清楚如何组织各个部分就陷入到制作幻灯片的模式中去，最终只留下一套臃肿却言之无物的幻灯片。而且当我们开始用电脑编写内容时，演讲就多了一个附属品——即便明知道做出来的东西偏题了或是需要修改、丢弃，我们有时也会因为付出了心血而拒绝这样做。 我们可以用低科技的方式避免这种不必要的附属品（和工作），例如白板、便利贴或是白纸。将想法在纸上写成一句话显然要简单得多，回收一张便利贴也不会像在电脑上删除大作那样有失落感。我喜欢用便利贴做故事板，因为可以简单地重排（同时增删）这些便利贴来探索不同的叙述流程。 识别并消除杂乱认知负荷每当接收信息时，我们就会感受到认知负荷。可以认为认知负荷是学习新知识所需的脑力。使用计算机工作时，我们依赖的是计算机的处理能力。让受众采取行动时，我们依赖的是他们的脑力。这就是认知负荷。人脑的这种处理能力是有限的。作为信息的设计师，我们希望更合理地使用受众的脑力。 视觉认知的格式塔原则临近原则我们倾向于认为物理上临近的物体属于同一个群体。 相似原则拥有相似颜色、形状、大小或者方向的物体会被视作相关或从属于一个群体。 包围原则我们会认为物理上包围在一起的物体从属于同一个群体。 闭合原则闭合的概念是指人们希望事情能够简化并符合脑海中已经存在的结构。因此人们倾向于将一系列个体元素看作一个可识别的形状——当部分缺失时，我们的视觉会帮助填充。 连续原则连续原则与闭合原则类似：当我们观察物体时，尽管没有显式的路径，但我们的眼睛倾向于寻找最平稳的路径并自然地创造出连续性。 连接原则我们倾向于将物理连接的物体视作一个群体。连接属性通常比相似的颜色、大小和形状有更强的关联价值。 对齐在没有其他视觉上的提示时，受众通常会从页面或者屏幕的左上方开始，按“之”字形（或者多个“之”字形，取决于布局）移动视线并消化信息。因此，当涉及表格和图形时，我偏爱将文字（标题、坐标轴标签、图例等）按左上角对齐。这意味着受众会先看到有关如何阅读图表的细节，然后再看到数据本身。 留白视觉沟通中的留白和公众演讲时的暂停一样重要。或许你曾经听过一场缺少暂停的演讲。就像这样：一个演讲者站在你面前或许是紧张或许是为了在有限的时间里尽量传达更多的信息他以超音速演讲你甚至怀疑他要如何呼吸你想提问但演讲者已经讲到下一个主题仍然没有停留足够的时间让你提问。这种不舒服的经历就和你在阅读前面这段连续不间断的长句的感觉一样糟糕。 有策略地使用留白也会为你的视觉沟通带来同样强大的效果。而缺少留白——就和演讲中缺少停顿一样——会让受众感到不适。受众对视觉沟通的设计感到不适，这是我们应该极力避免的。有策略地留白正可以将受众的注意力吸引到页面中那些没有留白的部分。 对于留白，以下是一些基本准则。 边界处避免出现文字和图表。 抵制住想要拉伸图表撑满可用空间的欲望，根据内容多少决定图表的合适大小。 除此之外，考虑如何有策略地使用留白来进行强调。如果有一件事非常重要，那就考虑让这件事成为页面当中唯一的内容，有些时候可能只是一句话甚至一个数字。 聚焦受众的视线前注意属性当我们面对一段文字时，如果没有任何视觉线索，唯一的办法是阅读。但使用少量前注意属性可以迅速改变这一点。 有研究表明，我们有 38 秒的时间，让受众决定是继续看面前的东西还是把注意力转移到别的地方。如果明智地使用前注意属性，即便只有 38 秒，我们也能够传达给受众我们想要表达的要点。 大小相对大小代表了相对重要性。如果你需要展示几件重要性相同的事情，请使用相似的大 小。相反，如果有一件事情尤其重要，那么用大小来体现这一点：将它变大！ 颜色在少量使用时，颜色是吸引受众注意的最强大的工具之一。请克制住为了丰富多彩而使用颜色的冲动。相反，有选择、有策略地使用颜色这一工具突出图表中的重要部分。颜色的使用应该永远是特意作出的决定，千万别让工具为你作出这个重要的决定。 在设计图表时，我通常选用灰色作为阴影，再挑选一个大胆的颜色来吸引注意。颜色基调是灰色而不是黑色，是因为其他颜色相对灰色要比黑色更突出。 少量使用颜色很容易从一群鸽子中找到一只老鹰，但随着鸟的种类增加，想找到老鹰会越来越难。只有少量地使用颜色才能确保有效性。种类太多会导致没有哪一种显得突出。需要足够的对比才能吸引受众的注意。 一致性颜色的变化只能说明一点——变化。所以，当你因为某些原因希望受众感觉到变化时，可以利用这一点，但千万不要仅仅因为新颖性而使用。如果你在设计图表时使用灰色的阴影，并且用一种单色吸引注意，请在整个沟通中使用同样的原理。例如，受众很快了解到蓝色表示他们应该最先注意的内容，并且可以在阅读后续的图表时利用这个结论。而如果你希望表达主题或者语气的明显变化，颜色切换是在视觉上强调这一点的方法之一。 有些情况下，颜色的使用一定要一致。受众通常会花时间熟悉颜色代表的含义，然后假设同样的细节在后续的沟通中都适用。例如，如果你在图表的四个区域展示数据，每个区域有各自的颜色，那么请确保在幻灯片或报告的剩余部分保持同样的设计（尽可能避免将这几种颜色用于别的目的）。不要改变颜色的使用，否则会让受众感到困扰。 突出重要的内容 不是所有的数据都同样重要。合理使用页面空间以及受众的注意力，消除不重要的数据或者元素。 当不需要细节时，请总结。你应该熟悉细节，但这不代表受众也同样需要。思考是否应该进行总结。 扪心自问：去掉这个会有什么变化？不会？那就去掉吧！抵制住因为某些内容可爱或者花费了心血而保留它们的诱惑。如果不能论证内容，那它们就与沟通的目的不符。 将必要但不直接影响内容的元素融入背景。使用关于前注意属性的知识进行弱化。浅灰色的效果就不错。 消除干扰“一个完美的设计，不是因为它没有多余的东西可以添加，而是因为没有多余的部分可以删减。” 对于数据可视化的设计完美性，决定删减或者弱化什么，可能比决定添加或者突出什么更重要。 为了识别干扰，要同时考虑杂乱和上下文。我们之前讨论过杂乱：一些占用空间却不传达信息的元素。上下文则需要展示给受众，用以使想要沟通的内容有意义。对于上下文，注意保持合适的量——别太多，也别太少。全面考虑哪些信息很重要而哪些相反。识别出不必要、外来的或者无关的东西或者信息。确定这些信息是否对主要内容来说是干扰。所有的这些都是用以消除的候选。 以下是一些具体的、有助于识别潜在干扰的注意事项。 不是所有的数据都同样重要。合理使用页面空间以及受众的注意力，消除不重要的数据或者元素。 当不需要细节时，请总结。你应该熟悉细节，但这不代表受众也同样需要。思考是否应该进行总结。 扪心自问：去掉这个会有什么变化？不会？那就去掉吧！抵制住因为某些内容可爱或者花费了心血而保留它们的诱惑。如果不能论证内容，那它们就与沟通的目的不符。 将必要但不直接影响内容的元素融入背景。使用关于前注意属性的知识进行弱化。浅灰色的效果就不错。 每一步消除和弱化都使得留下来的内容更为突出。如果你不确定是否保留正在考虑删减的细节，想想可否在不稀释主要内容的前提下保留这些细节。例如在幻灯片中，你可以将内容移到附录中供需要时使用，而且不会干扰你的主要观点。 故事与写作开头首先要做的是介绍情节，为受众建立情境。把这作为第一步。其中，我们设立故事的必要元素（设定、主角、未解决的问题及期望的结果），保证大家达成共识，这样故事才能继续。我们应该让受众参与，激发他们的兴趣，回答他们脑海中潜在的问题：我为什么要关注？对于我而言有什么意义？ 寻找你关心的主题。在你的风格中，最吸引人的元素是真正关心的问题，而非玩弄文字的手法。 不要乱说。 保持简单。主题最深刻时，大师的句子最简单，如同孩童写的一样。莎士比亚笔下的哈姆雷特问过“To be or not to be?”。这当中最长的单词不过三个字母。 敢于删减。如果一句话无法以新的或者有用的方式呼应你的主题，无论多好，请删掉它。 发自内心。我发现当我的文章像出自一个印第安纳波利斯人之手时，我最为相信自己的文字，别人也有同感。事实上，我正是来自印第安纳波利斯。 按规矩说话。如果我违背所有标点的使用规则，按我所想的含义去使用文字并把它们随意串起来，则没人能理解我。 (7) 心怀读者。受众希望我们是有同情心和耐心的老师，永远愿意简化和澄清。 冲突和戏剧性的紧张是故事的关键部分。一个天下太平一帆风顺的故事是无趣的，无法吸引注意和激发行动。把冲突和紧张当作讲故事的工具——在失衡和平衡之间，或者在你所关注的问题上——它能帮助你吸引受众。将你的故事套上他们（受众）的问题，这样他们将立刻参与到问题的解决之中。 中间一旦设定了舞台，可以说未来沟通的大部分都在于发现“演变”，旨在说服受众采取必要的行动。通过说明如何解决你引入的问题，你能够将受众的注意力保持在故事的这个部分。你需要努力说服他们为什么应该接受你提出的解决方案或者按你建议的方式采取行动。 具体内容会根据实际情况采取不同的形式。在构建故事并说服受众采纳时，以下是一些可以涵盖的内容。 覆盖相关背景，进而推动情况和问题进一步发展 结合外部上下文和对比点 举例说明问题 包括能够说明问题的数据 阐述如果不采取行动或者不发生变化会怎样讨论解决问题的潜在选择 说明建议方案的优势 向受众明确为什么他们会处在这一决策的位置 当考虑在沟通中包含什么内容时，将受众放在首位。考虑什么能够与他们产生共鸣并激励他们。例如，受众的动力是否来源于赚钱、赢得竞争、获得市场份额、节省资源、裁撤冗员、创新、学习新技能或者别的什么？如果你能识别出什么可以激励受众，不妨考虑以此构建故事并号召行动。同时还要考虑数据能否以及何时强化故事，将其整合进来，使其有意义。在沟通过程中，让信息具体并与受众相关。整个故事也要与他们相关，而非与你相关。 结尾最终，故事必须结束。以呼吁行动结束：让受众完全清楚地了解，你希望他们如何利用你传授的新知识。结束故事的经典方法之一是呼应开头。在故事开头，我们设定了情节，引入了戏剧性的紧张。为了总结，你可以考虑回顾这个问题以及对行动的需求，重申紧迫性，让受众准备采取行动。 叙述结构想想你希望受众体验故事的顺序。他们是不是繁忙的受众，会感激你开门见山地提出对他们的要求？或者他们是新的受众，你需要先建立信任？他们关心过程还是只需要答案？这是一个需要他们参与的协作过程吗？你希望他们做决定还是采取行动？你要怎样说服他们以你所期望的方式行动？这些问题的答案有助于决定何种叙述流最适用于你的具体情况。 这里有一个重要的基本点，就是你的故事需要有顺序。只有关于特定主题的一系列数字和文字，而没有结构组织赋予其含义是没有用处的。叙述流正是你在演讲或沟通过程中口头或书面引导受众的路线。这条路线你自己应该清楚。否则，你肯定没有办法让受众弄清楚。 组织故事的顺序之一——通常最自然的——是时间顺序。例如，如果我们考虑一般的分析过程，它看起来像这样：我们发现一个问题，收集数据以更好地了解情况，分析数据（以一种或另一种方式看数据，联系其他事物看是否有影响等），得出结论或解决方案，在此基础上得出建议的行为。而在沟通中，将信息传达给受众的方法之一就是遵循同样的路径，让受众经历与我们相同的过程。如果你需要与受众建立信任，或者你知道受众关心这一过程，这种方法会很有成效。但时间顺序并不是你唯一的选择。 另一种策略是从结尾开始。先从呼吁行动开始：你需要受众了解或者做什么。然后回到支撑故事的关键部分。如果你已经与受众建立了信任，或者你知道他们对“结果”更感兴趣而不太在乎你的方式，这一策略则更适用。以呼吁行动开始有额外的好处：可以使受众立刻清楚他们应该扮演什么角色，或者应该用什么视角考虑接下来的演讲或者沟通，以及为什么他们应该继续听下去。 案例分析折线图图中展示了今年募集活动的当前进度。 首先，文字的合理使用。所有内容都有标题和标记，因此对于我们正在看什么没有任何疑问。图表、纵坐标轴、横坐标轴都有标题。图中各条线都直接进行了标记，因此无需在图例和数据之间来回切换以解读图表的内容。文字的合理使用使得图表理解无障碍 我几乎总是用深灰色作为图表标题的颜色。这保证了标题的突出，但又不会像纯黑文字在白底上那样对比强烈（但是在不使用其他颜色时，我也会用黑色作为强调色）。图中使用了一些前注意属性来将注意力引导到“当前进度”的趋势线上：颜色、线条加粗、数据标记和终点的标签，以及相应文字的大小。 对于更宽泛的上下文，图中包含了一些对比的点，但是进行了弱化，使得图表不会变得过于臃肿。图中标记了 5 万美元的募集目标用以参考，但只绘制了一条细线使其融入背景，并且细线和文字都使用了与图表中其他细节相同的灰色。图中也包含了去年的募集趋势，但同样使用了更细的折线以及浅蓝色进行弱化（在视觉上与今年的进度保持联系，但不会竞争注意力）。 在坐标轴标签上，图中有一些深思熟虑后做出的决定。对于竖直的 y轴，你可以考虑将数字四舍五入到千位——这样坐标轴范围就变为 0 到60，坐标轴标题也会改为“募得资金（千美元）”。如果数额达到了几百万的数量级，我可能会考虑这样做。但是对我而言，按千来考虑数字不够直观，所以我选择保留 y 轴标签中数字末尾的 0。 对于水平 x 轴，我们不需要将每一天都标记出来，因为我们更关心整体的趋势，而非某一特定日期的情况。由于我们有 30 天中第 10 天的数据，我选择在 x 轴上按每 5 天进行标记（考虑到我们谈论的是天，另一种潜在的解决方案是按每 7 天进行标记，或者添加第一周、第二周等超类）。这就是没有唯一正确答案的情况之一：你应该考虑到上下文和数据，以及你希望受众如何使用图表，并最终做出深思熟虑的决定。 注释预测类折线图图中展示了一幅关于实际及预测年销量的注释折线图。 该图中，除了标题、文本框中的日期、数据（折线）、精选的数据标记以及 2014 年以后的数值标签，其他内容都通过灰色字体和元素融入背景。当我们考虑元素的视觉层次时，我的眼睛首先看到左上角的图表标题（由于其位置以及前一示例中讨论过的大号深灰色文字），然后看到文本框中的蓝色日期，在此停留并阅读相应的上下文，此后继续向下移动到相应的数据或是趋势。数据标记仅针对注释中提到的那些数据点，这使得能够快速查看哪部分数据对应哪条注释。（原本数据标记是实心蓝点，但我改为了蓝色边框的白点，这使得它们以我喜欢的方式更突出一些；预测数据的标记是小一些的实心蓝点，因为蓝色边框的白点在虚线上看起来很凌乱。） $1080 的数据标签使用了粗体。这是有意进行强调的，因为它是实际数据的最后一点，又是预测数据的锚点。历史数据点并未进行标记。相反，我们保留了 y 轴以提供整体幅度的感觉，因为我们希望受众集中在相对趋势而非精确数值上。预测的数据点包含了数值标签，从而使受众对前瞻性预期有一个清晰的理解。 图中的所有文字都使用了同样的大小，除非有意决定进行改变。图表标题字号更大，脚注则使用小号的字体以及图表底部这一低优先级的位置进行了弱化，以便它在需要时帮助解读，而又不会引起注意。 100%堆叠条形图图中的堆叠条形图是来自咨询界的一幅示例图表。每个咨询项目都有相应的具体目标。针对这些目标的进展会按季度进行评估，并指定为“未达预期”“达到预期”或者“超出预期”。该堆叠条形图展示了全体项目中这三类的占比随时间的变化趋势。如前面的示例一样，不用过于担心这里的细节，而是思考可以从绘制这些图表的设计考虑中学到什么。 让我们首先考虑该图中的元素对齐。图表标题、图例和竖直 y 轴都向左上角对齐。这意味着受众在看到数据之前会看到如何阅读图表。在左侧，图表标题、图例、y 轴标题和脚注都是对齐的，在图表的左侧形成了清晰的界线。在右侧，顶部的文字是右对齐的，并与包含了所描述数据点的最后一个条形图对齐（利用了格式塔邻近原则）。这一文本框竖直方向上也与图例对齐。 对于聚焦受众的注意，图中使用红色作为唯一吸引注意的颜色（正红色对我而言太刺眼，所以我常用暗红色代替，这里也一样）。其余都使用了灰色。图中还在希望受众注意的数据点上使用了数值标签——白色相对红色的突出对比以及大号的文字构成了额外的重要性的视觉提示：未达预期的项目数占比增加。其余数据作为上下文得以保留，但都融入背景从而不会对受众的注意产生竞争。针对这些数据，我们使用了程度略有不同的灰色阴影，这样你仍然可以一次针对一系列数据进行聚焦，但这不会对红色数据的清晰强调造成干扰。 项目类别从“未达预期”到“超出预期”，并在堆叠条形图中按从下向上的顺序进行绘制。“未达预期”这一级别最接近 x 轴，相对同一起点（x轴）的对齐使我们容易看出其随时间的变化。“超出预期”类别随时间的变化也同样容易看出，因为它们都相对图表顶端进行了一致对齐。由于在图表的顶端或者底部都没有一致的基线，“达成预期”占比变化难以看出，但考虑到这是一项低优先级的比较，所以也能够接受。 文字使图表理解无障碍。图表和 y 轴都有标题，x 轴则利用超类（年份）减少冗余的标签，使数据更易阅读。右上角的文字强调了我们应该关注的点（我们会在第 7 章讲故事的上下文中更多地讨论文字）。脚注包含了对项目总数随时间变化的说明，这同样是重要的上下文，因为无法从 100% 堆叠条形图中直接获取这一信息。 正负堆叠条形图图中展示的是人力资源分析方面的一个示例，可以用于了解对高级人才的预期需求并确定缺口，从而可以主动应对。在该示例中，并购引入以及升职会为总监池带来预期增长，而人员流失（离职）会导致总监缺口扩大。 如果我们考虑图中视线移动的路径，我的视线先扫过标题，然后直接移向大号、粗体、黑色的数字并随着它们一直向右，直到文字告诉我这代表了“未满足的需求（缺口）”。然后我的视线向下，阅读了文字并瞥了左侧所描述的数据，最后我看到了底部最后一系列数据“流失”。此时，我的视线在“流失”和“未满足的需求（缺口）”部分之间来回切换，注意到从左向右看时，随着时间推移，总监的总需求数有所增加（可能由于公司整体的扩大，对高级人才的需求也因此增长），但未满足需求的绝大部分原因是由于当前总监池的流失。 对于图表中颜色的使用，我们有意做出了选择。“目前的总监”用我标准的正蓝色显示，退出的总监（流失）则用饱和度略低的相同颜色，以从视觉上将两者联系起来。随着时间推移，你会看到坐标轴上方的蓝色越来越少，而随着越来越多的总监离开，落在坐标轴下方的比例越来越大。负方向的“流失”数据强调了这部分代表着总监池的减少。通过收购和升职增加的总监用绿色显示（带有正面的内涵）。未满足的需求则只以边框描绘，从视觉上显示出空白，强调这代表着缺口。每条右侧的文字标签都使用与所描绘数据相同的颜色，而“未满足的需求（缺口）”除外，它同样也使用了大号、加粗、黑色的文字作为数据标签。 各类数据在堆叠直方图中的顺序也是有意为之。“目前的总监”是基础，因此在水平 x 轴上方一开始显示。如我之前所提，负面的“流失”数据则落在 x 轴下方的负方向上。在“目前的总监”之上是增加的部分：升职和并购引入。最终，在堆叠直方图的顶端（我们的眼睛先看到这里，然后才是数据），我们看到了“未满足的需求（缺口）”。 我们保留了 y 轴，使读者能够对整体的幅度有一个认识（正负两方面），但使用了灰色的文字将其融入背景。只有那些我们应该关注的数据点——“未满足需求（缺口）”——才直接用数值加以标记。 除了决定进一步强调或者弱化的元素，图表中文字都使用了同样的字号。图表标题的字号更大。坐标轴标题“总监人数”字号略大，以便于读者阅读旋转后的文字。“未满足需求（缺口）”的文字和数字比图表中的其他内容都要更大更粗，因为这是我们希望读者关注的地方。脚注则用了小号的字体，所以它根据需求存在而又不引人注意。通过灰色和图表底部的最低优先级的位置，我们进一步弱化了脚注。 水平堆叠条形图图中显示了一个发展中国家对于各方面发展的相对优先级的问卷调查结果。这其中包含了很多信息，但通过有策略地强调和弱化元素，可以使图表在视觉上不会显得很杂乱。 考虑到绘制的内容，堆叠条形图在这里是合适的：最高优先级（排在第一位，最深的阴影）、第二优先级（排在第二位，使用同色但略浅的阴影）和第三优先级（排在第三位，使用同色但更浅的阴影）。将图表水平方向放置意味着左侧的类别名称在水平方向，易于阅读。 各种类别按“占全部的百分比”降序竖直排列，为受众解读数据时提供了清晰的结构。占比最大的类别在图表的顶部，所以我们首先看到这个类别。优先级前三的类别通过颜色的使用进行特别强调（该图表原始版本中的描述主要集中在这一方面）。颜色的使用覆盖了类别名称、占全部的百分比以及数据的堆叠条形图。这种颜色一致性从视觉上将元素联系在一起。 我们在绘制图表时有一个决策点在于是保留坐标轴、直接标记数据点（或者其中的一部分），还是两者都做。在该例中，条形图中的数值标签保留了，但使用了小号的字体进行弱化（靠左对齐，形成了清晰的界线，使得你可以一眼扫过数据标签得出“最重要的”，这比靠右或者居中对齐导致标签位置不一更为整齐）。数据标签还通过颜色进行了进一步的弱化：浅蓝或者浅灰色不像有色条形图背景上的白色标签那么对比鲜明。x 轴直接被省略了。这里，我们隐式假设具体数据足够重要，需要明确标记。别的场景可能需要不同的处理办法。 正如我们在前面一些例子中注意到的，该图表中的文字使用得很好。所有内容都有标题和标签。用于解读条形图的图例紧贴着第一个数据条的上方，“最”“第二”和“第三”这些关键词加粗以进行强调。其他细节在脚注中进行了描述。 快速回顾(1) 理解上下文。清楚地理解你正在沟通的对象，你需要他们了解或者做什么，你将如何与他们沟通，以及你拥有什么数据来支持你的故事。利用三分钟故事、中心思想和故事板等方法组织你的故事，计划所需的内容和流程。 (2) 选择合适的图形表达。当突出一两个数字时，简单文本是最好的。折线图通常适用于连续的数据。条形图适用于分类数据，而且必须要有零点的基线。根据你希望展现的关系选择图表类型。避免使用饼图、甜甜圈图、3D 图表或者次要 y 轴，因为难以从视觉上进行解读。 (3) 消除杂乱。识别出没有信息价值的元素，从图表中将其删除。利用格式塔原则理解人们如何阅读，并识别潜在的消除对象。有策略地使用对比。对齐图表的元素，保持一定的留白，有助于使受众的解读过程更舒适自然。 (4) 集中注意。利用前注意属性，如颜色、大小和位置等，提示重要的内容。用这些策略性的属性将受众的注意吸引到你希望的地方，引导受众解读图表。通过应用“你的视线被吸引到哪里”测试来评估图表中前注意属性是否有效。 (5) 像设计师一样思考。为受众提供视觉可供性作为如何交互的提示：突出重要的内容，消除干扰，并建立信息的视觉层次。通过避免过度复杂，利用文字进行标记和解释，使你的设计理解无障碍。让你的图表更美观，以增加受众对设计问题的容忍度。努力使你的图表设计为受众所接受。 (6) 讲述一个故事。创造一个有着清晰的开头（情节）、中间（起伏）和结尾（呼吁行动）的故事。利用冲突和紧张吸引并保持受众的注意。考虑叙述的顺序和方式。利用重复的力量让故事牢牢印在受众的记忆里。利用竖直和水平的逻辑关系、反向故事板、寻求新的视角等策略，确保你的故事在沟通中能够清晰呈现。","categories":[{"name":"读后感","slug":"读后感","permalink":"http://yinzhm.gitee.io/categories/%E8%AF%BB%E5%90%8E%E6%84%9F/"}],"tags":[{"name":"数据分析","slug":"数据分析","permalink":"http://yinzhm.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"读后感","slug":"读后感","permalink":"http://yinzhm.gitee.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"}]},{"title":"Tableau知识点大全","slug":"Tableau常用函数","date":"2023-02-16T06:35:57.000Z","updated":"2023-03-28T14:39:00.239Z","comments":true,"path":"2023/02/16/Tableau常用函数/","link":"","permalink":"http://yinzhm.gitee.io/2023/02/16/Tableau%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/","excerpt":"","text":"数字函数ZN(expression) 如果&lt;表达式&gt;不为null，则返回它，否则返回零。 示例：ZN([Profit])CEILING(number) 将数字舍入为等于或大于值的最接近整数。 示例：CEILING(3.14) = 4FLOOR(number) 将数字舍入为等于或小于值的最接近整数。 示例：FLOOR(3.14) = 3ROUND(number, [decimals]) 将数字舍入为最接近的整数或指定小数位数。 示例：ROUND(3.14,1) = 3.1POWER(number, power) 返回数字的给定幂的结果。 示例：POWER(5,2) = 5^2 = 25SQRT(number) 返回给定数字的平方根。 示例：SQRT(25) = 5SQUARE(number) 返回给定数字的平方。 示例：SQUARE(5) = 25聚合函数AVG(expression) 返回表达式中所有值的平均值。AVG 只能用于数字段。会忽略 Null 值。 示例：AVG([Profit])COUNT(expression) 返回组中的项目数。不对 Null 值计数。 示例：COUNT([Customer ID])COUNTD(expression) 返回组中不同项目的数量。不对 Null 值计数。 示例：COUNTD([Region])MIN(number, number) 和 MAX(number, number) Max(expression)或Max(expr1, expr2) 返回单个表达式在所有记录间的最大值/最小值，或两个表达式对于每个记录的最大值/最小值。 示例：MAX([sales])MEDIAN(expression) 返回表达式在所有记录中的中位数。中位数只能用于数字字段。会忽略 Null 值。 示例：MEDIAN([Profit])PERCENTILE(expression, number) 从给定表达式返回与指定数字对应的百分位处的值。数字必须介于 0 到 1 之间（含 0 和 1），例如 0.66，并且必须是数值常量。 示例：PERCENTILE([Sales], 0.9)SUM(expression) 返回表达式中所有值的总计。SUM 只能用于数字字段。会忽略 Null 值。 示例：SUM([Profit]){FIXED [dim1[,dim2]…]:aggregate-expression} FIXED 详细级别表达式使用指定的维度计算值，而不引用视图中的维度。 示例：{FIXED [客户名称]: MIN(订单日期)} 示例：{FIXED [Region]: SUM([Sales])}，此详细级别表达式（名为 [Sales by Region]）日期函数DATE(expression) 将字符串和数字表达式转换为日期的类型转换函数，只要它们是可识别的格式。 示例：DATE([Employee Start Date]) 示例：DATE(“September 22, 2018”) 示例：DATE(“9/22/2018”) 示例：DATE(#2018-09-22 14:52#)DATEADD(date_part, interval, date) 将指定数量的日期部分（月、日等）添加到开始日期。 示例：DATEADD(‘month’, 3, #2004-04-15#) = 2004-07-15DATEDIFF(date_part, date1, date2, [start_of_week]) 返回两个日期之间的日期部分（周、年等）的数量。 示例：DATEDIFF(‘month’, #2004-07-15#, #2004-04-03#,’sunday’) = -3DATEPARSE(date_format, [date_string]) 以日期形式返回特定格式的字符串。 示例：DATEPARSE(“dd.MMMM.yyyy”, “15.April.2004”) = 2004-04-15DATEPART(date_part, date, [start_of_week]) 以整数形式返回指定日期部分的名称。 示例：DATEPART(‘month’, #1986-03-25#) = 3DAY(date) 以整数的形式返回给定日期的天。 示例：Day(#September 22, 2018#) = 22MONTH(date) 以整数的形式返回给定日期的月份。 示例：MONTH(#1986-03-25#) = 3QUARTER(date) 以整数的形式返回给定日期的季度。 示例：QUARTER(#1986-03-25#) = 1YEAR(date) 以整数的形式返回给定日期的年份。 示例：YEAR(#1986-03-25#) = 1986TODAY() 返回当前本地系统日期。 示例：TODAY() = 2023-02-16MAKEDATE(year, month, day) 返回一个依据指定年份、月份和日期构造的日期值。 示例：MAKEDATE(1986,3,25) = #1986-03-25#","categories":[{"name":"数据分析","slug":"数据分析","permalink":"http://yinzhm.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}],"tags":[{"name":"数据分析","slug":"数据分析","permalink":"http://yinzhm.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"Tableau","slug":"Tableau","permalink":"http://yinzhm.gitee.io/tags/Tableau/"}]},{"title":"《乌合之众》读后感","slug":"乌合之众","date":"2022-04-03T13:21:58.000Z","updated":"2023-03-28T14:26:14.313Z","comments":true,"path":"2022/04/03/乌合之众/","link":"","permalink":"http://yinzhm.gitee.io/2022/04/03/%E4%B9%8C%E5%90%88%E4%B9%8B%E4%BC%97/","excerpt":"","text":"群体的一般特征聚集成群的人，他们的感情和思想全都转到同一个方向，他们自觉的个性消失了，形成了一种集体心理。 构成这个群体的个人不管是谁，他们的生活方式、职业、性格或智力不管相同还是不同，他们变成了一个群体这个事实，便使他们获得了一种集体心理，这使他们的感情、思想和行为变得与他们单独一人时的感情、思想和行为颇为不同。若不是形成了一个群体，有些闪念或感情在个人身上根本就不会产生，或不可能变成行动。 在集体心理中，个人的才智被削弱了，从而他们的个性也被削弱了。异质性被同质性所吞没，无意识的品质占了上风。 心理群体中的个人在某种暗示的影响下，他会因为难以抗拒的冲动而采取某种行动。因为暗示对群体中的所有个人有着同样的作用，相互影响使其力量大增。在群体中，具备强大的个性、足以抵制那种暗示的个人寥寥无几，因 此根本无法逆流而动。有意识人格的消失，无意识人格的得势，思想和感情因暗示和相互传染作用而转向一个共同的方向，以及立刻把暗示的观念转化为行动的倾向，是组成群体的个人所表现出来的主要特点。他不再是他自己，他变成了一个不再受自己意志支配的玩偶。群体的感情和道德观群体的冲动、易变和急躁 孤立的个人具有主宰自己的反应行为的能力，群体则缺乏这种能力。 群体根本不会做任何预先策划。他们可以先后被最矛盾的情感所激发，但是他们又总是受当前刺激因素的影响。 群体不仅冲动而多变。就像野蛮人一样，它不准备承认，在自己的愿望和这种愿望的实现之间会出现任何障碍，它没有能力理解这种中间障碍，因为数量上的强大使它感到自己势不可挡。 群体的易受暗示和轻信 群体通常总是处在一种期待注意的状态中，因此很容易受人暗示。最初的提示，通过相互传染的过程，会很快进入群体中所有人的头脑，群体感情的一致倾向会立刻变成一个既成事实。 正如所有处在暗示影响下的个人所示，进入大脑的念头很容易变成行动。一切都取决于刺激因素的性质，而不再像孤立的个人那样，取决于受到暗示的行动与全部理由之间的关系，后者可能与采取这种行动极为对立。 群体对自己看到的事件进行歪曲的方式，好像既多且杂，各不相同，因为组成群体的个人有着非常不同的倾向。但是情况并非如此。作为相互传染的结果，受到的歪曲是一样的，在群体中所有个人表现出同样的状态。 群体中的某个人对真相的第一次歪曲，是传染性暗示过程的起点。暗示的起点一般都是某个人多少有些模糊的记忆所产生的幻觉，在这一最初的幻觉得到肯定之后，就会引起相互传染。 群体情绪的夸张与单纯 群体中的个人不能作出细致的区分，他把事情视为一个整体，看不到它们的中间过渡状态。群体情绪的简单和夸张所造成的结果是，它全然不知怀疑和不确定性为何物。 不幸的是，群体的这种夸张倾向，常常作用于一些恶劣的感情。它们是原始人的本能隔代遗传的残留，孤立而负责的个人因为担心受罚，不得不对它们有所约束。因此群体很容易干出最恶劣的极端勾当。 群体因为夸大自己的感情，因此它只会被极端感情所打动。 群体的偏执、专横和保守 群体只知道简单而极端的感情；提供给他们的各种意见、想法和信念，他们或者全盘接受，或者一概拒绝，将其视为绝对真理或绝对谬论。 对何为真理何为谬误不容怀疑，另一方面，又清楚地意识到自己的强大， 群体便给自己的理想和偏执赋予了专横的性质。 专横和偏执是一切类型的群体的共性，但是其强度各有不同。在这个方面，支配着人们感情和思想的基本的种族观念，会一再表现出来。 专横和偏执是群体有着明确认识的感情，他们很容易产生这种感情，而且只要有人在他们中间煽动起这种情绪，他们随时都会将其付诸实践。 对一切传统的迷恋与崇敬是绝对的；对一切有可能改变自身生活基本状态的新事物，有着根深蒂固的无意识恐惧。 群体的道德 孤立的个人在生活中满足野蛮和破坏性的本能是很危险的，但是当 他加入一个不负责任的群体时，因为很清楚不会受到惩罚，他便会彻底放纵这种本能。 群体可以无恶不作，但是也能表现出极崇高的献身、牺牲和不计名利的举动，即孤立的个人根本做不到的极崇高的行为。 以名誉、光荣和爱国主义作为号召，最有可能影响到组成群体的个人，而且经常可以达到使他慷慨赴死的地步。 群体的观念、推理与想象力 观念可以分为两类。一类是那些因一时的环境影响来去匆匆的观念，譬如那些只会让个人或某种理论着迷的观念。另一类是基本观念，它们因为环境、遗传规律和公众意见而具有极大的稳定性。过去的宗教观念，以及今天的社会主义和民主观念，都属于这类观念。 给群体提供的无论是什么观念，只有当它们具有绝对的、毫不妥协的和简单明了的形式时，才能产生有效的影响。 当观念通过不同的方式，终于深入到群体的头脑之中并且产生了一系列效果时，和它对抗是徒劳的。 群体推理的特点，是把彼此不同，只在表面上相似的事物搅在一起，并且立刻把具体的事物普遍化。 正像缺乏推理能力的人一样，群体形象化的想像力不但强大 而活跃，并且非常敏感。虚幻的因素对他们的影响几乎像现实一样大。他们有着对两者不加区分的明显倾向。 群体并不进行推理，它对观念或是全盘接受，或是完全拒绝；对它产生影响的暗示，会彻底征服它的理解力，并且使它倾向于立刻变成行动。 总结 不要轻易成为集体的一份子，这样很容易被别有用心的人利用，即使你以为自己只不过是随声附和了一下而已，实际上你已经成了帮凶。 人一到群体中，智商就严重降低，为了获得认可，个体愿意抛弃是非，用智商去换取那份让人倍感安全的归属感。 我们始终有一种错觉，以为我们的感情源自于我们自己的内心。 群体只会干两件事-锦上添花或落井下石。 个人一旦成为群体的一员，他的所作所为就不会再承担责任，这时每个人都会暴露出自己不受到约束的一面。群体追求和相信的从来都不是什么真相和理性，而是盲从、残忍、偏执和狂热，只知道简单而极端的感情。 我们以为自己是理性的，我们以为自己的一举一动是有其道理的。但事实上，我们的绝大多数日常行为，都是一些我们自己根本无法了解的隐藏动机 的结果。 所谓的信仰，它能让一个人变得完全受自己的梦想奴役。 在于理性永恒的冲突中，感情从未失过手。 群众没有真正渴求过真理，面对那些不合口味的证据，他们会充耳不闻；凡是能向他们提供幻觉的，都可以很容易地成为他们的主人；凡是让他们幻灭的，都会成为他们的牺牲品。 数量，即是正义 掌握了影响群众想象力的艺术，也就掌握了统治他们的艺术。","categories":[{"name":"读后感","slug":"读后感","permalink":"http://yinzhm.gitee.io/categories/%E8%AF%BB%E5%90%8E%E6%84%9F/"}],"tags":[{"name":"心理学","slug":"心理学","permalink":"http://yinzhm.gitee.io/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"},{"name":"读后感","slug":"读后感","permalink":"http://yinzhm.gitee.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"}]},{"title":"运营知识总结","slug":"运营知识总结","date":"2022-03-20T08:52:36.000Z","updated":"2023-03-29T11:37:59.291Z","comments":true,"path":"2022/03/20/运营知识总结/","link":"","permalink":"http://yinzhm.gitee.io/2022/03/20/%E8%BF%90%E8%90%A5%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","excerpt":"","text":"运营和市场 做运营，永远要向迭代去要数据，也要依据数据去做迭代。 用户认知（品牌定位、塑造、传播）→ 用户转化（场景搭建）→ 用户使用（运营手段）→ 用户付费&amp;其他（场景搭建+运营手段） 通常，用户认知这个环节下的品牌传播、塑造、定位，加上产品“无形价值”的塑造，基本会是市场部更应该关注的工作。 而用户转化、用户使用，以及用户行为的促进和引导，都是运营更应该关注的事情，运营需要在所有这些环节中去具体考虑用户的使用场景，并把一个足以引导用户完成转化的场景成功搭建起来。 市场所做的一切，都应该瞄准着扩大品牌、产品的用户认知和提升产品的无形价值，比如，发了一篇介绍品牌的软文，被浏览了10万次，但没有形成任何转化，这个事情在市场的角度来看，是有意义的——这确保了这10万个看到文章的用户在下一次具体触碰到可能会使用你产品的场景时，有更大的可能性会想到你。 而运营所做的一切，都应该瞄准着具体的用户使用场景或转化场景，所做的一切，也更多都是引导和铺垫，最终目的也往往是为了更好地实现用户转化，提升具体的产品数据。 运营和产品 在一家互联网公司内部，产品和运营之间的关系，是很微妙的。 产品负责界定和提供长期用户价值，运营负责创造短期用户价值+协助产品完善长期价值。 很多产品的长期价值并不是用户一眼就能感知出来的，而是需要经过一段时间的使用和体验才能感知到的。所以，为了让用户得到这个长期价值，我们需要通过运营先去创造出来一些短期价值，以刺激用户愿意先去尝试使用它。 很多产品的长期价值不是一蹴而就的，而是必须借由用户的持续使用和反馈，经过长期优化迭代后才能成立的。所以，要是没有用户的使用和反馈，产品很可能永远无法形成真正的长期价值。因而，在产品的长期价值还不是那么确定的时候，运营需要先通过创造一系列的短期价值让用户能够先使用你的产品。 什么是运营 运营是连接产品和用户的桥梁。再进一步讲，这里又存在两个目的：一是能够获取用户并实现用户付费；二是能够更好地维系住这些用户，令他们愿意与你保持长久的关系。 运营工作中的很大一个组成部分就是如何通过不断思考、判断和执行，找到投入产出比较优的路径和方法，来达成你想要的结果。 有些事情创造用户价值，但不一定一眼看得到回报；有些事情消费用户价值，但很容易带来成交和转化。 把我可能得到的潜在回报先丢到一边，只专注于为用户们去创造出来一些令他们惊喜的价值，真正把你的用户作为你身边真实的朋友来对待——这样的行事方式终会为你赢得更多的回报。 “回报后置”式的逻辑。它更加强调我们专注于给用户创造价值，并相信，当你创造的价值足够多的时候，用户一定会愿意给予你无条件的认可和回报，且这种回报，有时甚至会超出你的预期。 在我们日常的运营工作中，带着“找出最核心的不确定要素”和“先以最小成本搭建起来一个真实应用场景”的思维去工作，很多时候，能帮我们节省下来巨大的成本，无论是沟通方面的成本，还是实际工作中的投入时间、物质等成本。 如今市场同类型产品日益增多，意味着用户面临更多的选择，如何让用户选择我并且保持良好的用户粘性，就是运营需要考虑的事情。 做运营的3个底层工作方法 拥有对于新鲜事物的高度敏感养成一个习惯，但凡在朋友圈、微信群等地方看到有超过3个人都在提一个你此前从来没听过的概念，可以专门抽出来至少30～50分钟的时间，去把这个从来没听说过的东西彻头彻尾搞清楚。无论对于产品还是运营，最重要的核心能力，都是“学习能力”。 拥有对于用户的洞察力尽可能把自己变成一个真正的典型用户，让自己大量置身于真实用户的真实体验场景下，这样久而久之，你自然会慢慢拥有一种对于你的用户们的“洞察力”。而这样的洞察力，很多时候也会成为一个优秀运营身上不可替代的核心价值。 拥有打动力和说服力的表达假如你需要短时间内获得对方的注意力，那你可能需要先抛出一个可以让对方大吃一惊、瞠目结舌或十分好奇的观点和结论，瞬间击中对方，然后再去逐一论证你的观点是否可以成立。而假如你面临着的问题是要说服对方接受一个你的观点，那么你可能更需要先从大量事实和一些细节的刻画出发，通过事实和细节引发出对方的感知、共鸣和认同，再逐步引申出你的结论。 4个关键性“运营思维”（一）流程化思维 界定清楚我想要的目标和结果； 梳理清楚，这个问题从起始到结束的全流程是怎样的，会经历哪些主要的环节； 在每一个环节上，我们可以做一些什么事情，给用户创造一些不同的体验，以有助于我们最终达成期望实现的结果。 （二）精细化思维 你必须要能够把自己关注的一个大问题拆解为无数细小的执行细节，并且要能够做到对于所有的这些小细节都拥有掌控力。 你的用户可以被分成哪些类别，对于每一类，在每一个体验点上我们可以使用哪些不同的运营策略和运营手段，当把诸如此类的这些事情切分和做到极致之后，你的运营指标的拉升，其实是自然而然的结果。 （三）杠杆化思维 好的运营，其实是有层次感的，你总是需要先做好做足某一件事，然后再以此为一个核心杠杆点，去撬动更多的事情和成果发生。一个优秀的运营，脑子里也一定要时刻保持对于这个问题的思考：围绕着我想要达成的结果，当前可能有哪些东西可以成为我的杠杆点？ （四）生态化思维 好的运营，其实无非就是在不断“做局”和“破局”。 而“做局”这件事，其实很多时候，就是在搭建一个生态。所谓生态，其实就是一个所有角色在其中都可以互为价值、和谐共存、共同驱动其发展和生长的一个大环境。好比，一个几百人的微信群，要是大家在其中都很活跃，彼此也都能给其他人多少提供和创造一些价值，让这个群可以自然良性发展下去，它就已经是一个小生态了。 而且，互联网运营与传统运营的一个很大的差异点，就是你会有更大的空间和机会，基于线上去搭建起来一个可良性循环的生态。 而能否成功搭建起来生态，最重要的事情，就是你要能够梳理清楚并理解一个生态间的各种价值关系，或者说，脑子里要先有一些生态的概念和模型。 运营的一些核心技能&amp;工作方法一个特别特别靠谱的运营在着手解决问题、开展工作的时候，会尽力让70%以上的事情变得对自己是可知可控的，只留下30%的不确定。而一个靠谱程度还没那么高的运营，则有可能正好相反——他会把70%的事情付诸于不确定。当你拿到一个目标或运营指标的时候，你都应该遵照如下几个步骤来进行思考，并最终落地。（要把围绕着一个大目标的所有工作任务都拆分到极细、极具体。） 第一，你要界定一下，这个指标是由哪些分支指标或哪些要素构成的。你需要把你的目标指标和这些要素间的关系界定出来，最好变成一个公式的样子。 第二，这些被你提炼出来的分支指标或要素现在是否还存在可以提升的空间？ 第三，具体来思考，如果要提升某个分支指标，我们需要将其拆分和落实为哪些具体的运营手段？比如是优化几个文案，还是做几个活动送点礼品，还是再多发几篇微信图文、多发几篇微博？ 运营必须具备的数据分析方法和意识逻辑能力较强的人语言表达方面往往是有组织的，其说话表达往往有框架有条理，思路清晰。比如，在回答问题时他会喜欢用“起因-经过-结果”、“案例-问题-分析原因-解决方法”等框架来进行回答。框架不是为了束缚思维，而是用来整理思路。 1、数据可以客观反映出一款产品当前的状态好坏和所处阶段。2、假如做完了一件事但效果不好，数据可以告诉你，你的问题出在哪里。3、假如你想要实现某个目标，数据可以帮助你找到达成目标的最佳路径。4、极度精细的数据分析可以帮助你通过层层拆分，对用户更了解，也对整个站内的生态更有掌控力。5、数据当中可能隐藏着一些潜在的能让你把一件事情变得更好的线索和彩蛋，有待于你去发现和挖掘。 运营背后的客观规律规律一：带着短视的线性思维投入运营工作中，往往很难做好运营。什么是线性思维？即：只考虑单一结果导向的思维。 比如说，销售类的工作，无论老板还是员工，都只看销售订单数和销售额。再比如，推广类工作，我们也只会看你投放了多少钱，拉到了多少个用户。这也恰恰是传统行业与互联网世界的鸿沟所在：传统行业讲简单粗暴、讲成本收入比，他们更习惯的逻辑是——我在谁面前做了哪些事，他就会愿意给我付钱。这个时候，只要他付给我的钱大于我所付出的成本，我持续找到这样的人以可控的成本让他们愿意给我付钱，商业逻辑即可成立。 这样的逻辑，称为一维、线性的逻辑。在这样的逻辑下，我做的所有事情，必然需要给我带来某些实际、具体的回报。假如我做了A，却不能确保给我带来B的回报，这样的事我不会考虑。 然而，在互联网世界中，逻辑很可能远非如此简单，需要考虑的结果维度会更多。比如说，一个互联网产品的商业逻辑很可能是这样的：我先做了一件事，让A愿意持续使用我；因为A的使用，引来了B的关注；我要做更多的事情把A和B都持续留在我这里；因为我这里有大量的A和B，此时C突然跑了出来，说愿意给我付钱，目的是让A和B都能够关注他，认识他。 规律二：一款产品在其早期过于关注用户增长，甚至出现“爆红”等现象，往往反而会加速其死亡。 我们并不是说用户增长不重要，而是一款产品，如果在它自身的核心用户价值点还未明确、产品体验也还不够完善的时候，就要贸然去追求大量的用户增长，这对产品往往是一剂毒药。 规律三：早期产品的运营，一定要围绕着“口碑”来进行。 一款刚刚上线的早期产品，可能会面临什么情况？产品体验很烂，产品功能不完善，甚至产品的主要操作都保证不了，这些都是再常见不过的事情。假如一大群用户使用后，纷纷得不到良好体验，然后他们对你又没什么感情、没什么牵挂，他们一定迅速跑掉，而且跑掉还不算结束，他们很可能还会跑掉后满世界去骂，从而带动其他人对你的产品也形成负面认知。 所以，一款产品的早期，核心目的一定不应该是增长和用户规模，而是口碑。有了口碑，表示现有用户已经充分认可了你，表示你的产品基本体验已经足够完善，也表示你已经拥有了更好的服务能力去服务更大体量的用户了。最为重要的是，有了口碑，你的新用户获取成本会大大降低。 那么，早期产品的体验如果很糟糕，口碑应该从哪里来？答案是：运营对于用户的感染力、服务态度、你的产品理念、你的产品迅速改进优化的速度和能力，你在其他方面给这群用户创造的价值（例如总是送给用户一些意外之喜）等，是这一系列事情支撑起了早期产品的口碑。 只有在你的产品已经拥有了很扎实的口碑后，你才能把“增长”作为你的目标来看待。 数据分析模型AARRR模型AARRR是一个用于研究用户增长的数据分析模型，是Acquisition、Activation、Retention、Revenue、Refer，这个五个单词的缩写，分别对应用户生命周期中的用户获取、用户激活、用户留存、获得收益、推荐传播这5个重要环节。 PEST模型PEST分析是指宏观环境的分析，宏观环境又称一般环境，是指一切影响行业和企业的宏观因素。对宏观环境因素作分析，不同行业和企业根据自身特点和经营需要，分析的具体内容会有差异，但一般都应对政治（Political）、经济（Economic）、社会（Social）和技术（Technological）这四大类影响企业的主要外部环境因素进行分析。 RFM模型RFM 分析就是通过三个关键指标对客户进行观察和分类，判断每类细分用户的价值。针对不同的特征的客户进行相应的营销策略。客户数据库中有3个神奇的要素，这3个要素构成了数据分析最好的指标：最近一次消费 (Recency)、消费频率 (Frequency)、消费金额 (Monetary)。 最近一次消费时间 (Recency)：客户距离最近的一次采购时间的间隔。 最近一段时间内消费频次 (Frequency)：指客户在限定的期间内所购买的次数。 最近一段时间内消费金额 (Monetary)：客户的消费能力，通常以客户单次的平均消费金额作为衡量指标。 SWOT模型（strengths）是优势、W （weaknesses）是劣势、O （opportunities）是机会、T （threats）是威胁。按照企业竞争战略的完整概念，战略应是一个企业“能够做的”（即组织的强项和弱项）和“可能做的”（即环境的机会和威胁）之间的有机组合。 5W2H模型对选定的项目、工序或操作，都要从原因（何因Why）、对象（何事What）、地点（何地Where）、时间（何时When）、人员（何人Who）、方法（何法How）等多个方面提出问题进行思考。 What：是什么？明确具体做什么？ Who：谁来做？关键人物是谁？ When: 何时完成？什么时机最适宜？时间节点是？ Where: 在哪里做？从哪里入手？ Why: 为什么做？有没有替代方案？ How: 怎么做？怎么样？如何实施？如何提高效率？ How much: 做到什么程度？要花多少钱？ ABC分析(帕累托)ABC 分类法全称应为 ABC 分类库存控制法。又称帕累托分析法或巴雷托分析法、柏拉图分析、主次因分析法 、ABC分析法、ABC 管理法，平常也称之为「80 对 20」规则。在ABC分析法的分析图中，有两个纵坐标，一个横坐标，几个长方形，一条曲线，左边纵坐标表示频数，右边纵坐标表示频率，以百分数表示。横坐标表示影响质量的各项因素，按影响大小从左向右排列，曲线表示各种影响因素大小的累计百分数。一般地，是将曲线的累计频率分为三级，与之相对应的因素分为三类： A类因素，发生累计频率为0%~80%，是主要影响因素。 B类因素，发生累计频率为80%~90%，是次要影响因素。 C类因素，发生累计频率为90%~100%，是一般影响因素。 KANO模型KANO模型是对用户需求分类和优先排序的有用工具，以分析用户需求对用户满意的影响为基础，体现了产品性能和用户满意之间的非线性关系。按照卡诺模型，会将需求分解为基本需求，期望需求，兴奋需求，无差异需求，和反期望需求五个部分。","categories":[{"name":"运营","slug":"运营","permalink":"http://yinzhm.gitee.io/categories/%E8%BF%90%E8%90%A5/"}],"tags":[{"name":"运营","slug":"运营","permalink":"http://yinzhm.gitee.io/tags/%E8%BF%90%E8%90%A5/"}]},{"title":"《金字塔原理》读后感","slug":"金字塔原理","date":"2022-03-17T14:28:43.000Z","updated":"2023-03-29T11:37:49.907Z","comments":true,"path":"2022/03/17/金字塔原理/","link":"","permalink":"http://yinzhm.gitee.io/2022/03/17/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86/","excerpt":"","text":"金字塔结构 归类分组，将思想组织成金字塔 找出逻辑关系，抽象概况 自上而下表达，结论先行 自下而上思考，总结概况 金字塔中的思想以3种方式互相关联-向上、向下和横向。位于一组思想的上一个层次的思想是对这一组思想的概况，这一组思想则是对其上一层次思想的解释和支持。每组的思想必须按照逻辑顺序组织：演绎顺序（大前提、小前提、结论）、时间（步骤）顺序、结构（空间）顺序、程度（重要性）顺序。 如何构建金字塔自上而下法 提出主题思想 设想受众的主要疑问 写序言：背景(situation)-冲突(Complication)-疑问(Question)-回答(Answer) 与受众进行疑问/回答式对话。 对受众的新疑问，重复进行疑问/回答式对话。自下而上法 列出想要表达的所有思想要点 找出各要点之间的逻辑关系 得出结论注意事项 先搭结构，先尝试自上而下法 序言先写背景，将背景作为序言的起点 先多花时间思考序言，不要省略 将历史背景放在序言中 在关键句层次中，更适宜选择归纳推理法而非演绎论证法 序言的具体写法 序言要用讲故事的形式，因为读者只有在感受到强烈的吸引力时，才会愿意暂时放弃其他思想，专注于你提供的信息，为达到这一目的，可以利用未讲完的故事所产生的悬念效果。 引入“背景”的时机，就是你能够作出关于文章主题独立的、无争议的表述的时候。 序言必须采取“背景-冲突-疑问-解决方案”的结构。但是，各部分的顺序可以有所变化。","categories":[{"name":"读后感","slug":"读后感","permalink":"http://yinzhm.gitee.io/categories/%E8%AF%BB%E5%90%8E%E6%84%9F/"}],"tags":[{"name":"读后感","slug":"读后感","permalink":"http://yinzhm.gitee.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"}]},{"title":"时间管理方法","slug":"时间管理方法","date":"2022-03-16T14:03:44.000Z","updated":"2022-12-27T05:56:15.803Z","comments":true,"path":"2022/03/16/时间管理方法/","link":"","permalink":"http://yinzhm.gitee.io/2022/03/16/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95/","excerpt":"","text":"1、ALPEN方法ALPEN 是经济学家、时间管理专家Prof. Lothar J. Seiwert. 发明的，用于日常的事项管理和优先级排序，帮助你提升学习工作的效率。 A 定义任务： 依次列出今日的各项工作 L 评估用时： 评估完成每项工作需要完成的时间 P 评估弹性时间： 评估自己今天的弹性时间，预留出冗余时间 E 评估优先级： 判断哪个事项需要优先完成，哪个事项可以延后完成 N 评估结果： 评估今日计划的完成度，进行复盘总结 这个方法可以让你的注意力集中在重要的工作上面，当一天的工作开始，你就会确切的知道需要做什么。哪项工作需要其他人配合或是需要延期，可以及时掌握调整。 2、艾森豪威尔矩阵以前美国有一位总统叫艾森豪威尔，创造了艾森豪威尔矩阵，支持我们按照紧急性和重要性来为任务排优先级。 艾森豪威尔矩阵划分了四个象限，从而有四种不同的工作策略。时间管理最重要的任务是让事情尽可能都分布在“重要不紧急”这个象限，并且积极合理的安排时间去完成他们。 当一个人的任务大多数是重要但不紧急的，意味着他既有明确的目标，又有合理的规划。 艾森豪威尔矩阵最大的价值，是帮助我们尽可能多的把时间花在“重要但不紧急”的第二象限，把工作任务和时间安排调整到理想状态。 3 SMART原则SMART原则是目标管理中的一种方法，由管理学大师彼得·杜拉克于1954年首次提出。目的是为了有效地进行成员的组织与目标的制定和控制，以达成更好的工作绩效，目前在企业界有广泛的应用。S - Specific 简单、明确、具体、有意义：你的目标必须是明确的，你没有办法去完成一个模糊的目标。 M - Measurable 可测量，可自我驱动 ：可衡量的目标让你能够跟进进度，不会丧失动力，会为接近目标感到高兴。 A - Achievable 可达成，是合理现实的 ：你的目标必须是你可以达到的，你需要正确的评估现在的自己，以及你的能力。 R - Relevant 相关性 ：检查该目标是否和其他目标具有相关性，如果两者本身冲突，需要改变其中一个目标。 T - Time-bound 有时间限制 ：任何目标都需要时间限制，时间限制可以帮你分解目标，让你跟上进度。 通过 SMART 方法，你的一个模糊的目标，就变成了一个明确的、可执行的具体任务，这样就会帮助你有效完成这个目标。","categories":[],"tags":[]},{"title":"数据分析知识总结","slug":"数据分析","date":"2022-02-20T08:52:36.000Z","updated":"2023-03-29T11:38:50.520Z","comments":true,"path":"2022/02/20/数据分析/","link":"","permalink":"http://yinzhm.gitee.io/2022/02/20/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/","excerpt":"","text":"数据分析整体流程明确问题：先把问题定义清除 搭建框架：再把问题考虑全面，找到主线 数据提取：MySQL、Hive为主 数据处理：Excel、R、Python为主 数据分析：数据分析方法论为主 数据展现：Tableau、Excel、R、Python 撰写报告：考验文笔功底，整体逻辑性 报告演讲：沟通能力、表达能力、被提问能力 报告闭环：最难也是最大价值体现 流量波动模型 常识判断（是否是重要的节假日） 竞品数据（同行数据是否有变化） 外部事件（社会负面新闻对品牌有影响） 产品变化（产品发布新版本、功能有缺陷） 用户行为（订单区域分布是否有变化） 数据问题（数据采集口径是否有变化） 数据分析模型AARRR模型AARRR是一个用于研究用户增长的数据分析模型，是Acquisition、Activation、Retention、Revenue、Refer，这个五个单词的缩写，分别对应用户生命周期中的用户获取、用户激活、用户留存、获得收益、推荐传播这5个重要环节。 PEST模型PEST分析是指宏观环境的分析，宏观环境又称一般环境，是指一切影响行业和企业的宏观因素。对宏观环境因素作分析，不同行业和企业根据自身特点和经营需要，分析的具体内容会有差异，但一般都应对政治（Political）、经济（Economic）、社会（Social）和技术（Technological）这四大类影响企业的主要外部环境因素进行分析。 RFM模型RFM 分析就是通过三个关键指标对客户进行观察和分类，判断每类细分用户的价值。针对不同的特征的客户进行相应的营销策略。客户数据库中有3个神奇的要素，这3个要素构成了数据分析最好的指标：最近一次消费 (Recency)、消费频率 (Frequency)、消费金额 (Monetary)。 最近一次消费时间 (Recency)：客户距离最近的一次采购时间的间隔。 最近一段时间内消费频次 (Frequency)：指客户在限定的期间内所购买的次数。 最近一段时间内消费金额 (Monetary)：客户的消费能力，通常以客户单次的平均消费金额作为衡量指标。 SWOT模型（strengths）是优势、W （weaknesses）是劣势、O （opportunities）是机会、T （threats）是威胁。按照企业竞争战略的完整概念，战略应是一个企业“能够做的”（即组织的强项和弱项）和“可能做的”（即环境的机会和威胁）之间的有机组合。 5W2H模型对选定的项目、工序或操作，都要从原因（何因Why）、对象（何事What）、地点（何地Where）、时间（何时When）、人员（何人Who）、方法（何法How）等多个方面提出问题进行思考。 What：是什么？明确具体做什么？ Who：谁来做？关键人物是谁？ When: 何时完成？什么时机最适宜？时间节点是？ Where: 在哪里做？从哪里入手？ Why: 为什么做？有没有替代方案？ How: 怎么做？怎么样？如何实施？如何提高效率？ How much: 做到什么程度？要花多少钱？ ABC分析(帕累托)ABC 分类法全称应为 ABC 分类库存控制法。又称帕累托分析法或巴雷托分析法、柏拉图分析、主次因分析法 、ABC分析法、ABC 管理法，平常也称之为「80 对 20」规则。在ABC分析法的分析图中，有两个纵坐标，一个横坐标，几个长方形，一条曲线，左边纵坐标表示频数，右边纵坐标表示频率，以百分数表示。横坐标表示影响质量的各项因素，按影响大小从左向右排列，曲线表示各种影响因素大小的累计百分数。一般地，是将曲线的累计频率分为三级，与之相对应的因素分为三类： A类因素，发生累计频率为0%~80%，是主要影响因素。 B类因素，发生累计频率为80%~90%，是次要影响因素。 C类因素，发生累计频率为90%~100%，是一般影响因素。 KANO模型KANO模型是对用户需求分类和优先排序的有用工具，以分析用户需求对用户满意的影响为基础，体现了产品性能和用户满意之间的非线性关系。按照卡诺模型，会将需求分解为基本需求，期望需求，以及兴奋需求，无差异需求，和反期望需求五个部分。","categories":[{"name":"数据分析","slug":"数据分析","permalink":"http://yinzhm.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}],"tags":[{"name":"数据分析","slug":"数据分析","permalink":"http://yinzhm.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}]},{"title":"2021听歌列表","slug":"2021听歌列表","date":"2022-01-16T10:43:14.000Z","updated":"2022-01-16T13:35:47.230Z","comments":true,"path":"2022/01/16/2021听歌列表/","link":"","permalink":"http://yinzhm.gitee.io/2022/01/16/2021%E5%90%AC%E6%AD%8C%E5%88%97%E8%A1%A8/","excerpt":"","text":"2021国内歌单 var options = {\"narrow\":false,\"autoplay\":false,\"showlrc\":3,\"listmaxheight\":\"1500px\",\"music\":[{\"title\":\"搁浅\",\"author\":\"杨丞琳\",\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2021@master/music/gq.mp3\",\"pic\":\"https://img4.kuwo.cn/star/albumcover/500/78/89/2187092529.jpg?param=300x300\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2021@master/music/gq.lrc\"},{\"title\":\"不舍\",\"author\":\"徐佳莹\",\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2021@master/music/bs.mp3\",\"pic\":\"https://img3.kuwo.cn/star/albumcover/500/51/90/1219306274.jpg?param=300x300\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2021@master/music/2.lrc\"},{\"title\":\"孤勇者\",\"author\":\"陈奕迅\",\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2021@master/music/gyz.mp3\",\"pic\":\"https://img3.kuwo.cn/star/albumcover/500/49/79/1011385325.jpg?param=300x300\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2021@master/music/1.lrc\"},{\"title\":\"这世界那么多人\",\"author\":\"莫文蔚\",\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2021@master/music/zsj.mp3\",\"pic\":\"https://img1.kuwo.cn/star/albumcover/500/36/95/3659539568.jpg?param=300x300\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2021@master/music/zsj.lrc\"},{\"title\":\"到此为止\",\"author\":\"徐佳莹\",\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2021@master/music/dcwz.mp3\",\"pic\":\"https://img3.kuwo.cn/star/albumcover/500/55/9/1054468429.jpg?param=300x300\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2021@master/music/dcwz.lrc\"},{\"title\":\"失落沙洲\",\"author\":\"徐佳莹\",\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2021@master/music/slsz.mp3\",\"pic\":\"https://img4.kuwo.cn/star/albumcover/500/61/37/2297132086.jpg?param=300x300\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2021@master/music/slsz.lrc\"}]}; options.element = document.getElementById(\"aplayer-fbiWtaVR\"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 2021国外歌单 var options = {\"narrow\":false,\"autoplay\":false,\"showlrc\":3,\"listmaxheight\":\"1500px\",\"music\":[{\"title\":\"GL\",\"author\":\"LiSA\",\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2021@master/music/GL.mp3\",\"pic\":\"https://img2.kuwo.cn/star/albumcover/500/16/17/981262670.jpg?param=300x300\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2021@master/music/GL.lrc\"},{\"title\":\"Letters to ME\",\"author\":\"LiSA\",\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2021@master/music/letterstome.mp3\",\"pic\":\"https://img2.kuwo.cn/star/albumcover/500/16/17/981262670.jpg?param=300x300\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2021@master/music/letters.lrc\"},{\"title\":\"ever after\",\"author\":\"Aimer\",\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2021@master/music/everafter.mp3\",\"pic\":\"https://img1.kuwo.cn/star/albumcover/500/34/89/883343343.jpg?param=300x300\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2021@master/music/everafter.lrc\"},{\"title\":\"第六感\",\"author\":\"Reol\",\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2021@master/music/dlg.mp3\",\"pic\":\"https://img1.kuwo.cn/star/albumcover/500/29/12/2697189908.jpg?param=300x300\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2021@master/music/dlg.lrc\"},{\"title\":\"怪物\",\"author\":\"YOASOBI\",\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2021@master/music/gw.mp3\",\"pic\":\"https://img1.kuwo.cn/star/albumcover/500/2/75/2444083662.jpg?param=300x300\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2021@master/music/gw.lrc\"},{\"title\":\"STAY\",\"author\":\"The Kid LAROI,Justin Bieber\",\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2021@master/music/stay.mp3\",\"pic\":\"https://img4.kuwo.cn/star/albumcover/500/81/80/3255783507.jpg?param=300x300\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2021@master/music/stay.lrc\"},{\"title\":\"残響散歌\",\"author\":\"Aimer\",\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2021@master/music/cxsg.mp3\",\"pic\":\"https://img1.kuwo.cn/star/albumcover/500/58/80/4212154763.jpg?param=300x300\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2021@master/music/cxsg.lrc\"},{\"title\":\"おもかげ\",\"author\":\"Milet,Aimer,幾田りら\",\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2021@master/music/o.mp3\",\"pic\":\"https://img3.kuwo.cn/star/albumcover/500/73/6/2151048686.jpg?param=300x300\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2021@master/music/o.lrc\"},{\"title\":\"もう少しだけ\",\"author\":\"YOASOBI\",\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2021@master/music/m.mp3\",\"pic\":\"https://img4.kuwo.cn/star/albumcover/500/27/13/3338509315.jpg?param=300x300\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2021@master/music/m.lrc\"},{\"title\":\"優しい彗星\",\"author\":\"YOASOBI\",\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2021@master/music/hx.mp3\",\"pic\":\"https://img4.kuwo.cn/star/albumcover/500/62/20/2764088116.jpg?param=300x300\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2021@master/music/hx.lrc\"}]}; options.element = document.getElementById(\"aplayer-BpYdriQO\"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);","categories":[{"name":"音乐","slug":"音乐","permalink":"http://yinzhm.gitee.io/categories/%E9%9F%B3%E4%B9%90/"}],"tags":[{"name":"音乐","slug":"音乐","permalink":"http://yinzhm.gitee.io/tags/%E9%9F%B3%E4%B9%90/"}]},{"title":"人生几大准则","slug":"人生三大准则","date":"2021-01-15T15:49:08.000Z","updated":"2023-03-28T14:43:16.731Z","comments":true,"path":"2021/01/15/人生三大准则/","link":"","permalink":"http://yinzhm.gitee.io/2021/01/15/%E4%BA%BA%E7%94%9F%E4%B8%89%E5%A4%A7%E5%87%86%E5%88%99/","excerpt":"","text":"永远不要对别人或事抱有过高的期望值 期望越大，失望越大。可以相信别人，但别指望别人。 沉默是金，少说话能少得罪人，也能避免很多不必要的麻烦 该说的时候说，该哑的时候哑，该装傻的时候就装傻。 不要轻易将自己的优缺点暴露给别人不要在和人相处时表现的过于积极，学会适当伪装自己，有所保留 做人做事要低调 不要想着在别人面前出风头，不要打肿脸充胖子","categories":[],"tags":[]},{"title":"2020听歌列表","slug":"2020听歌列表","date":"2021-01-03T01:46:14.000Z","updated":"2022-01-08T14:50:26.479Z","comments":true,"path":"2021/01/03/2020听歌列表/","link":"","permalink":"http://yinzhm.gitee.io/2021/01/03/2020%E5%90%AC%E6%AD%8C%E5%88%97%E8%A1%A8/","excerpt":"","text":"2020国内歌单 var options = {\"narrow\":false,\"autoplay\":false,\"showlrc\":3,\"listmaxheight\":\"1500px\",\"music\":[{\"title\":\"永不失联的爱\",\"author\":\"周兴哲\",\"url\":\"http://music.163.com/song/media/outer/url?id=523250334.mp3\",\"pic\":\"http://p2.music.126.net/ACPwGpJZxmGKnM3rWilemA==/109951163083048605.jpg?param=300x300\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2020/ybslda.lrc\"},{\"title\":\"飞鸟和蝉\",\"author\":\"任然\",\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/music/fnhc.mp3\",\"pic\":\"https://y.gtimg.cn/music/photo_new/T002R300x300M000004C9Kg7275J7H_1.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/music/fnhc.lrc\"},{\"title\":\"句号\",\"author\":\"邓紫棋\",\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/music/jh.mp3\",\"pic\":\"https://y.gtimg.cn/music/photo_new/T002R300x300M0000049MVh824D7bM_1.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/music/jh.lrc\"},{\"title\":\"二零三\",\"author\":\"毛不易\",\"url\":\"http://music.163.com/song/media/outer/url?id=1407214788.mp3\",\"pic\":\"http://p1.music.126.net/XPPeIZu7wgcGXZ0666mfFg==/109951164640697307.jpg?param=300x300\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/music/203.lrc\"},{\"title\":\"赤伶\",\"author\":\"李玉刚\",\"url\":\"http://music.163.com/song/media/outer/url?id=1454730043.mp3\",\"pic\":\"http://p1.music.126.net/0el5yaTEo3KjeJjL3ZXxmg==/109951165054951989.jpg?param=300x300\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/music/cl.lrc\"},{\"title\":\"阿拉斯加海湾\",\"author\":\"蓝心羽\",\"url\":\"http://music.163.com/song/media/outer/url?id=1500569811.mp3\",\"pic\":\"http://p2.music.126.net/CbWwREaA22LmAv1oOtJt2w==/109951165518862422.jpg?param=130y130\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/music/alsjhw.lrc\"},{\"title\":\"一分一寸\",\"author\":\"阿YueYue\",\"url\":\"http://music.163.com/song/media/outer/url?id=1493083969.mp3\",\"pic\":\"http://p1.music.126.net/9W-qrrC0qV35YNVMcjWI0w==/109951165440845710.jpg?param=130y130\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/music/yfyc.lrc\"},{\"title\":\"我的悲伤是水做的\",\"author\":\"希萝\",\"url\":\"http://music.163.com/song/media/outer/url?id=1491356576.mp3\",\"pic\":\"http://p2.music.126.net/WTrmonATLJ7d9mTJq_iqbQ==/109951165424099549.jpg?param=130y130\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/music/wdbssszd.lrc\"},{\"title\":\"百利甜\",\"author\":\"魏晗\",\"url\":\"http://music.163.com/song/media/outer/url?id=1365893755.mp3\",\"pic\":\"http://p1.music.126.net/6rdyULsXSI3_14yoY_ZU5w==/109951164080022322.jpg?param=300x300\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/music/blt.lrc\"},{\"title\":\"丢了你\",\"author\":\"井胧\",\"url\":\"http://music.163.com/song/media/outer/url?id=1442508316.mp3\",\"pic\":\"http://p1.music.126.net/zYIadX_Prawn3nMTRA9tOQ==/109951164928052888.jpg?param=300x300\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/music/dln.lrc\"},{\"title\":\"是想你的声音啊\",\"author\":\"傲七爷\",\"url\":\"http://music.163.com/song/media/outer/url?id=1459950258.mp3\",\"pic\":\"http://p1.music.126.net/cIR63lyPGgQ4mAyuOTg8lA==/109951165109878587.jpg?param=300x300\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/music/sxndsya.lrc\"},{\"title\":\"吹灭小山河\",\"author\":\"国风堂,司南\",\"url\":\"http://music.163.com/song/media/outer/url?id=1412559986.mp3\",\"pic\":\"http://p1.music.126.net/taWBQliW8wLh_pqXElAeww==/109951164923015271.jpg?param=300x300\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/music/cmxsh.lrc\"},{\"title\":\"勇气\",\"author\":\"棉子\",\"url\":\"http://music.163.com/song/media/outer/url?id=1411358329.mp3\",\"pic\":\"http://p2.music.126.net/QcWNRX_0uhckImvF2nN1xA==/109951164573973377.jpg?param=300x300\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/music/yq.lrc\"},{\"title\":\"与我无关\",\"author\":\"阿冗\",\"url\":\"http://music.163.com/song/media/outer/url?id=1413585838.mp3\",\"pic\":\"http://p2.music.126.net/x-jReyGkM5OTKUEtTqXGoA==/109951164597332931.jpg?param=300x300\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/music/ywwg.lrc\"},{\"title\":\"嗜好\",\"author\":\"颜人中\",\"url\":\"http://music.163.com/song/media/outer/url?id=1391891631.mp3\",\"pic\":\"http://p1.music.126.net/J6HaJjtgv-yVVjyUm-h-AA==/109951164373633387.jpg?param=300x300\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/music/sh.lrc\"},{\"title\":\"横竖撇点折\",\"author\":\"泠鸢yousa\",\"url\":\"http://music.163.com/song/media/outer/url?id=1419023911.mp3\",\"pic\":\"http://p2.music.126.net/hauPmnxKqlnkASFvDqitEw==/109951164643900131.jpg?param=300x300\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/music/hspdz.lrc\"}]}; options.element = document.getElementById(\"aplayer-CjqJiwMH\"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); ## 2020国外歌单 var options = {\"narrow\":false,\"autoplay\":false,\"showlrc\":3,\"listmaxheight\":\"1500px\",\"music\":[{\"title\":\"夜に駆ける\",\"author\":\"YOASOBI\",\"url\":\"http://music.163.com/song/media/outer/url?id=1409311773.mp3\",\"pic\":\"http://p1.music.126.net/3xWlqwYmfwRFebeiONUpGg==/109951164546210608.jpg?param=300x300\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/music/ye.lrc\"},{\"title\":\"再会\",\"author\":\"LiSA,Uru\",\"url\":\"http://music.163.com/song/media/outer/url?id=1493364996.mp3\",\"pic\":\"http://p1.music.126.net/kKaU9hlQl6xLG9oeu6-PHg==/109951165444204103.jpg?param=300x300\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/music/zh.lrc\"},{\"title\":\"炎\",\"author\":\"LiSA\",\"url\":\"http://music.163.com/song/media/outer/url?id=1487550391.mp3\",\"pic\":\"http://p2.music.126.net/DLaT_uV5k9pgbbYn32FScA==/109951165393721639.jpg?param=300x300\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/music/yan.lrc\"},{\"title\":\"愛錠\",\"author\":\"LiSA\",\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/music/aiding.mp3\",\"pic\":\"http://p2.music.126.net/e54F_0fiwM8qj-7htJ2m9w==/109951165196968128.jpg?param=177y177\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/music/aiding.lrc\"},{\"title\":\"Augmentation\",\"author\":\"KMNZ,Moe Shop\",\"url\":\"http://music.163.com/song/media/outer/url?id=1410849559.mp3\",\"pic\":\"http://p2.music.126.net/COc0LR7HPjHBv2unUg5uGA==/109951164569231702.jpg?param=300x300\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/music/augmentation.lrc\"},{\"title\":\"LOST IN PARADISE\",\"author\":\"ALI,AKLO\",\"url\":\"http://music.163.com/song/media/outer/url?id=1483023596.mp3\",\"pic\":\"http://p1.music.126.net/4bh8IlOINz-f2eSiW18Bow==/109951165350833760.jpg?param=300x300\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/music/lostinparadise.lrc\"},{\"title\":\"Mr.VIRTUALIZER\",\"author\":\"HIMEHINA\",\"url\":\"http://music.163.com/song/media/outer/url?id=1475617323.mp3\",\"pic\":\"http://p1.music.126.net/BL0d1HbXJCpNw00O0q2MEg==/109951165287574564.jpg?param=300x300\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/music/mr.lrc\"},{\"title\":\"そして花になる\",\"author\":\"花譜\",\"url\":\"http://music.163.com/song/media/outer/url?id=1399849878.mp3\",\"pic\":\"http://p2.music.126.net/oO42TdpWe0WG-rGq41mVIQ==/109951164456169034.jpg?param=300x300\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/music/huapu.lrc\"},{\"title\":\"不可幸力\",\"author\":\"Vaundy\",\"url\":\"http://music.163.com/song/media/outer/url?id=1441993917.mp3\",\"pic\":\"http://p1.music.126.net/ShJ3sBiyVraBTnTwvyYMEw==/109951164922321443.jpg?param=300x300\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/music/bkxl.lrc\"},{\"title\":\"comethru\",\"author\":\"Jeremy Zucker,Bea Miller\",\"url\":\"http://music.163.com/song/media/outer/url?id=1351923466.mp3\",\"pic\":\"http://p2.music.126.net/mmMLF6_a1yDnzGO1LVyCeg==/109951163926564641.jpg?param=300x300\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/music/comethru.lrc\"}]}; options.element = document.getElementById(\"aplayer-GlvneEyV\"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);","categories":[{"name":"音乐","slug":"音乐","permalink":"http://yinzhm.gitee.io/categories/%E9%9F%B3%E4%B9%90/"}],"tags":[{"name":"音乐","slug":"音乐","permalink":"http://yinzhm.gitee.io/tags/%E9%9F%B3%E4%B9%90/"}]},{"title":"南京之行","slug":"南京之行","date":"2020-07-26T12:23:37.000Z","updated":"2021-02-14T13:48:21.975Z","comments":true,"path":"2020/07/26/南京之行/","link":"","permalink":"http://yinzhm.gitee.io/2020/07/26/%E5%8D%97%E4%BA%AC%E4%B9%8B%E8%A1%8C/","excerpt":"","text":"日期 旅游地 Day1 夫子庙、秦淮河 Day2 中山陵、明孝陵、玄武湖、1912酒吧一条街 Day3 新街口、总统府 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2020年7月24日周五我一上完班就立马冲出了公司，跟我同学坐动车去南京玩上三天，毕竟上班真的太无聊了，总该找点时间放松一下。到了之后首先我们去了夫子庙、秦淮河欣赏夜色，虽说处于疫情期间，不过在步行街上走的人还是挺多的。看到了人力车还是比较新奇的，就算是小时候在上海也已经见不到人力车了。在路上几乎走个十步就能看到一家老鸭粉丝汤店，我们随便找了家店试吃了下，不过感觉味道也就那样，跟在上海吃的也没啥两样。之后我们去了玄武湖公园玩了一天，走了2万多步，玄武湖中荷花绽放的景色还是不错的。去中山陵真的是艰难，光走过去就花了大概1个多小时，到达后还要走半个小时的阶梯才能上去，天气又很热，但从钟山往下看还是很壮观雄伟的。除此之外我们还去过1912酒吧一条街，不过我们两个都不会喝酒，所以也就看两眼就走了哈哈。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在南京出行还是挺方便的，到哪里都只需一辆共享单车和地铁就够了。虽然去了很多景点，但感觉南京不属于那种观赏性的旅游打卡地。不过美食还是不错的，牛肉锅贴好吃，阳春面也好吃，本来想买烤鸭回去的，结果买错了买的是盐水鸭，味道还行就是有点咸不太能接受。 [{\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/img/P00724-215116-01.jpeg\",\"alt\":\"\"},{\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/img/P00724-222623-01.jpeg\",\"alt\":\"\"},{\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/img/P00725-091450.jpg\",\"alt\":\"\"},{\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/img/P00725-091455.jpg\",\"alt\":\"\"},{\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/img/P00725-091501.jpg\",\"alt\":\"\"},{\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/img/P00724-221410-01.jpeg\",\"alt\":\"\"},{\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/img/P00724-221537.jpg\",\"alt\":\"\"},{\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/img/P00724-222157.jpg\",\"alt\":\"\"},{\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/img/P00724-223321-01.jpeg\",\"alt\":\"\"},{\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/img/P00724-223905-01-01.jpeg\",\"alt\":\"\"},{\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/img/P00725-101912.jpg\",\"alt\":\"\"},{\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/img/P00725-111041.jpg\",\"alt\":\"\"},{\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/img/P00725-111411.jpg\",\"alt\":\"\"},{\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/img/P00725-112231.jpg\",\"alt\":\"\"},{\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/img/P00725-132007.jpg\",\"alt\":\"\"},{\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/img/P00725-170038.jpg\",\"alt\":\"\"},{\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/img/P00725-170249.jpg\",\"alt\":\"\"},{\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/img/P00725-171121.jpg\",\"alt\":\"\"},{\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/img/P00725-172132.jpg\",\"alt\":\"\"},{\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/img/P00725-174426.jpg\",\"alt\":\"\"},{\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/img/P00725-202459.jpg\",\"alt\":\"\"},{\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/img/P00726-110506.jpg\",\"alt\":\"\"},{\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/img/P00726-112834.jpg\",\"alt\":\"\"},{\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/img/P00726-112924.jpg\",\"alt\":\"\"},{\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/img/P00726-113148.jpg\",\"alt\":\"\"},{\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets-2020@master/img/P00726-115019.jpg\",\"alt\":\"\"}] 加载更多","categories":[{"name":"相册","slug":"相册","permalink":"http://yinzhm.gitee.io/categories/%E7%9B%B8%E5%86%8C/"}],"tags":[]},{"title":"摄影知识总结","slug":"摄影知识","date":"2020-02-20T14:05:05.000Z","updated":"2023-03-29T07:52:09.000Z","comments":true,"path":"2020/02/20/摄影知识/","link":"","permalink":"http://yinzhm.gitee.io/2020/02/20/%E6%91%84%E5%BD%B1%E7%9F%A5%E8%AF%86/","excerpt":"","text":"光圈、快门、ISO值光圈 光圈的大小值直接影响到进光量和景深，光圈F值越小表示光圈越大。相同的ISO与快门条件下，光圈越大画面也就会越亮 光圈控制着进光量，就好比人的瞳孔，瞳孔放大，进光量越大 光圈与景深的关系 ：光圈越大，景深越浅（背景越模糊）。F/2.8大光圈，常用于营造背景模糊的浅景深；F/16小光圈，在拍摄主体与背景时都会比较清晰 快门 景深：拍摄照片时，照片中最近的物体和最远的物体之间，能清晰成像的部分，就是景深 快门速度：代表着曝光时间的长短，通常在光线充足的条件下，所需的曝光时间越短，光线不足的状况下，所需的曝光时间越长。通常长时间曝光需要搭配脚架来稳定相机，让影像不会产生晃动的残影 高速快门进入光线少，慢速快门进入光线多 高速快门适合抓拍精彩瞬间，慢速快门，也称为长曝光，适合拍摄轨迹效果，如车轨、瀑布、流水等 ISO ISO：相机感光度，感光数值越高接受的光量也就越多。在相同的光圈与快门条件下，画面会随着感亮度增加而明亮，相对的画面的噪声(颗粒感)也会增加，一般超过2000，会产生画面噪点，影响画质，需要降噪 ISO常用于夜间，由于光线暗淡，通过调高ISO值，使夜里画面更加清楚 感光度ISO大致分为：25、50、100、200、400、800、1600、3200、6400、12800。数值越小，感光度越低；数值越大，感光度越高。","categories":[],"tags":[{"name":"摄影","slug":"摄影","permalink":"http://yinzhm.gitee.io/tags/%E6%91%84%E5%BD%B1/"}]},{"title":"PS技巧","slug":"PS技巧","date":"2020-02-04T08:28:37.000Z","updated":"2021-01-03T13:38:53.841Z","comments":true,"path":"2020/02/04/PS技巧/","link":"","permalink":"http://yinzhm.gitee.io/2020/02/04/PS%E6%8A%80%E5%B7%A7/","excerpt":"","text":"基础操作1、新建图层：Ctrl + Shift + N2、图片转化为图层：Alt + 双击图片3、反选：Ctrl + Shift + I4、放大/缩小画笔：[ / ]。当失灵的状态下，按住ctrl+空格一般就好了5、取消选区：Ctrl + D6、撤销：Ctrl + Alt + Z7、旋转工具：R8、标尺：Ctrl + R9、自由变换：Ctrl + T10、全屏/窗口切换：F11、自动色调：Ctrl + Shift + L12、前景色/背景色切换：X13、前景色/背景色重置：D14、新建图层：Ctrl + Shift + N15、复制图层：Alt + 左键拖动到想要的位置 / Ctrl + J16、图层上下移：Ctrl + [ / ]17、取消选区：Ctrl + D18、重新选择选区：Ctrl + Shift + D19、羽化：Shift + F6 工具介绍1、选框工具M Shift + 鼠标：绘制正方形或其他正图形 Alt + 鼠标：由中心向四周绘制图形 Shift + Alt +鼠标：由中心向四周绘制正图形 2、套索工具L：绘制任意选区。Delete删除多余的节点，Esc取消绘制，双击或回车或按住Ctrl+左键点击进行快速交接。 套索工具：用来选择物体。按住鼠标沿对象边缘拖动至起点结束，松开鼠标即完成（如果拖动过程中松开鼠标它会自动闭合完成）。只能用于大致选区，不适于精细选取 多边形套索工具：可绘制以直线为边的多边形选区，按住Shift可绘制垂直、水平、45度直线。指向起点时光标下会有一个圆圈，单击闭合；如果不在起始点，双击闭合 磁性套索工具：根据物体的轮廓（沿着颜色的边缘自动产生节点）来进行选择。按住鼠标沿着对象移动时会自动形成节点。选择时可以根据需要调节频率，以适应增减节点。磁性套索可以通过Alt键，与套索工具进行快速切换 3、快速选择工具W 快速选择工具：可以根据需要调节画笔大小、硬度和间距。单击鼠标或拖动；按住Alt键减选区，按住Shift键加选区 魔棒工具：根据颜色的相似程度来进行选择。适合抠颜色单一的图像，比如纯色背景 4、移动工具V 跨文档移动图层时，移到新文档时按住Shift键可以按照原来的位置放在新文档图层中 按住Shift可以约束移动角度 方向键可以轻微移动图像，方向键+Shift可以增加移动步长 在其他工具状态下，按住Ctrl键可以变成移动工具 按Ctrl + Alt + 鼠标左键拖动可以进行复制图层 选中两个及以上图层，按Ctrl + G，就能快捷编组；或新建组，把图层拖拽进去 5、历史工具： 历史记录是不会被存储的，关闭文档后重新打开就没记录了 删除某一历史记录就会把它下面所有记录都删除 允许非线性历史记录删除某一步后不会删除其下面的所有步骤 还原多步：Ctrl+Alt+Z 前进多步：Ctrl+Shift+Z 历史记录画笔(Y)使用后回到历史记录面板中选则的历史源状态，可更改历史源 6、画笔工具B 画笔工具下(B)按住Shift可画直线，或连接两点画直线 按住Alt，拾取颜色 选择颜色：Shift+Alt+鼠标右键可选择色环中的颜色 改变画笔大小：”[]” / “]” 或Alt+鼠标右键水平移动 改变画笔硬度：Shift+ “[]” / “]”，或Alt+鼠标右键垂直移动 7、修复工具J修复工具（污点修复画笔工具、修复画笔工具、修补工具、红眼工具）用于修相片。 修复画笔：可以修掉不想要的图案，用Alt键先定义一块替代的图案区域，然后直接涂抹目标要去掉的图案。 污点修复画笔：可以修复污点，对大的图案进行连续涂抹使其消失。但是与周边过渡一般。选择类型的内容识别，效果最好。去照片水印可用污点修复画笔修复画笔。 修补工具：修补工具分为源和目标，先做选区然后拖动到目标区域。源让目标位置内容填充替换选区内容。目标为复制选区内容到目标位置，并和周围融合。可以先用其他选择工具建立选区，再用修补工具移动。也可用修补工具直接做选区 红眼工具：在光线较暗的环境下拍摄人物时，人眼的瞳孔会放大，让更多的光线通过，因此视网膜的血管就会在照片上产生泛红现象，红眼工具就可以去除这些现象。 内容感知移动工具：分为移动和扩展。做选区后移动可以把内容移动到制定位置，原位置自动替换周边环境。扩展模式是复制选中图像，自动与周边融合。 8、油漆桶工具G在编辑 - 填充中可以填充选中的图层区域（快捷键Shift + F5或Shift + Backspace） 9、自由变换Shift + T变换以参考点为中心进行转动。参考点可直接按住alt然后点击目标位置，参考点可移动到自由变换区外。变换加复制就是Ctrl + Alt + Shift + T。Alt + 鼠标拖动可以按参考点为中心等比例缩放。按住Shift旋转可以按15度每次旋转。 10、钢笔工具P 建立路径工具栏选择路径，或在路径面板上新建路径进行绘制。 路径是一种矢量的线，不是像素。 路径/直接选择工具A：黑色箭头(Ctrl)表示选择路径，白色箭头(Ctrl)表示选择锚点或控杆，Alt + 鼠标移动表示复制路径。钢笔状态下按Ctrl可变成直接选择工具，选中路径后可删除或添加锚点，移动锚点或片段。 按住Alt键可单独调节一边的控杆。 选择锚点后按住shift可锁定角度进行控杆长短调节。 直线点与曲线点转化：选择路径中的锚点后直接点击，可转换锚点性质。也可通过选择路径两边的对应控杆缩短到锚点，则该路径变成直线。 建立半曲线点：半曲线点指两个控杆可单独调节角度。在钢笔绘制路径时，当绘制完一个锚点后按住Alt点击该锚点，则该锚点只会有一个控杆，形成一个半曲线点，方便下一步路径转角。 11、操控变形编辑 - 操控变形，鼠标点击扎图钉扎好图钉后，选择一个图钉进行拖动，就可操控变形。图钉深度可决定移动到前一层还是后一层。 12、内容识别缩放改变图片尺寸但保护指定内容不变形。对要保持长宽的物体做一个选区，不需要精确，然后存入Alpha通道，然后编辑 - 内容识别缩放，在选项栏里选择保护 - Alpha1。然后可对图像进行拉伸，但是被保护的内容不会被拉伸。 13、仿制图章工具S 按Alt取样，然后在目标位置点击进行涂抹。 注意：要点击选中当前和下方图层。 仿制图章工具的不足是只能原样复制，不能和周边环境融合。 通道和蒙版通道通道最基本的作用是存储颜色信息，通道是8位的，有256个颜色，从黑到白256个位置，存储颜色信息即为颜色通道，存储选择信息就是alpha通道，黑白完全可以记录选取非选取。 新建Alpha通道：做好选区，右击存储选区或通道面板下点击将选区存储为通道 通道做选区的步骤： 挑选通道：选择一个认为能解决问题的通道（黑白关系+清晰轮廓+灰度关系+半透明关系） 复制通道：为了转成选区即Alpha通道 调节色阶：Ctrl + L ，为了让黑白或灰度最大化，已达到更准确的选区，也就是让黑白更明显；如果调节半透明的选区，则挑出更多灰度 载入选区：Ctrl + 点击通道 通过选区建立图层：Ctrl+J 剪贴蒙版：按Ctrl + Alt + G创建 或 图层 - 创建剪贴蒙版。还可以选中一个图层按住Alt然后鼠标移动到它和下一个图层的夹缝显示剪贴蒙版图标后点击即可，第一个图层就成了被剪贴蒙版。按Alt再点击缝就可以释放剪贴蒙版。选中图层建立被剪贴蒙版，可让该图层进入下一层的图层，上面图层的内容就只能在下面图层的内容里显示。剪贴蒙版还可针对多个图层全部进入一个图层进行操作，还是Ctrl + Alt + G。注意，组只能作为剪贴蒙版，不能做为被剪贴蒙版。蒙版 控制图层的选择范围即为图层蒙版，它是一个临时通道，具有通道的所有属性，用笔刷工具进行绘制。多数情况下，防止对原始素材进行破坏，图层蒙版最大的好处是只需要做一个遮挡，随时通过黑白两种颜色的调用显示或遮住，或通过灰颜色的介入半透明显示。 按住Alt点击蒙版缩略图，可以直接显示蒙版进行编辑，图层蒙版编辑状态下就是个临时Alpha通道，此时通道内也可见此蒙版。 不想用图层蒙版可以Shift点击或直接右击蒙版选择停用。 快速蒙版(Q)是临时Alpha通道，在选择菜单里有。快速蒙版用于选区初步建立后进行调节选区，黑色是减少选区，白色是增加选区。可用填充黑白等各种工具对快速蒙版进行操作。快速蒙版优势在于可与图层叠加显示，直接在类似图层上进行操作，而通道里看不到图层，调整没有快速蒙版方便。 色彩调整：图像 - 调整1、亮度/对比度：可使图像亮度加亮/变暗，颜色对比分明2、色阶：用直方图描述出的整张图片的明暗信息，修改色阶其实就是扩大照片的动态范围3、曲线：可以调整亮度、色阶、对比度、色调 高斯曲线/S曲线（暗部的更暗，亮部的更亮） 4、色相/饱和度：调整图像偏色和颜色鲜艳程度。最底下滑块有4个小三角，代表所选颜色范围。两端的浅灰色部分是容差值，即不跟随变化而变化。缩小容差值能使选择范围更精确。如果图像中有多个地方与需调节区域颜色相同时，利用选择工具大概选出范围，不用做精确选区。（重要）5、色彩平衡：调节图片冷暖色调6、匹配颜色（重要）：使两张或多张图片的颜色倾向一个色调，使得图片的色调统一7、通道混合器：可以用来调色，使用单色来得到高品质的细节丰富的灰度图（可以调节通道）。功能类似于黑白8、渐变/映射：可以用自己定义的渐变直接映射原来的色彩空间9、照片滤镜：相当于照相时在镜头前加滤镜产生的效果10、阴影/高光：专门对暗部和高光部分自动调整校正，用来修改逆光照片11、阈值：得到黑白图，用来提线稿，（阈值，色阶大于阈值变白，小于阈值变黑）。先做滤镜（其他-高反差保留，将高反差的地方保留，比如说明暗交界线，颜色分界线保留下来），再做阈值，可以得到细节较多的黑白图 选择并遮住功能 快捷键： Ctrl + Alt + R 快速选择工具：在画面上选择需要抠取的部分进行涂抹 智能半径（建议打开）：对半径的识别方式进行智能计算，识别图像上特殊的边缘，一般增大半径 移动边缘：在半径的基础上选区向内收或者向外扩 调整边缘画笔工具：在头发边缘涂抹，抠取出边缘头发 平滑可以消除锯齿，使得边缘变得柔和光滑（一般加5左右）。羽化可以使边缘从不透明到透明的过度。增强羽化适合抠比较柔和、梦幻的对象。对比度让边缘变得分明、清晰，和羽化相反 净化颜色可以去除边边角角的白边 输出设置：输出到新建带有图层蒙版的图层 选中修改后的蒙版拖动至回收站删除蒙版，这样可以保存透明层，然后点击锁定透明图层，用黑色画笔涂抹边缘，则可把半透明的未显示的毛发刷出来 头发边缘白边处理：Ctrl + J 复制图层，右键蒙版 - 应用图层蒙版，点击图层菜单 - 修边 - 移去白色杂边 头发边缘黑边处理：点击图层菜单 - 修边 - 去边（1像素） 头发周围细节处理：新建图层，右键创建剪贴蒙版，选择画笔工具，按住Alt取样正确的头发颜色，在头发边缘进行涂抹 Camera Raw滤镜 快捷方式：Ctrl + Shift + A Camera Raw的调整界面，左边就是调整面板，右上方是直方图，直方图下面，就是各种参数的调整面板。要想取消调整可以按Alt + 单击取消进行复位。 参数面板1、基本 调整曝光、高光、阴影、白色、黑色技巧（按住Alt再拖动滑块使画面纯黑/纯白，无杂色为最佳） 白平衡：色温、色调 曝光、对比度、高光、阴影、白色、黑色 清晰度、去除薄雾、自然饱和度、饱和度 2、色调曲线（参数模式 / 点模式） 曲线的横轴代表亮度（高光，亮调，暗调，投影），左侧为最暗（阴影），右侧为最亮（高光）。当曲线高于基准线时，此处就变亮；反之，低于基准线则变暗。 3、细节 锐化（使照片更加清晰） 减少杂色（降低由于曝光不足而强行提高亮度导致的噪点） 4、HSL调整 色相：适合于照片中颜色的微调，对某个颜色不太满意，想要使某个颜色偏色，就使用“色相”面板中的滑块来进行调整 饱和度：针对各个颜色来调整色彩浓淡的 明亮度：针对某个色彩来调整颜色深浅的 5、分离色调 将不同的颜色用于图像的亮部和暗部。比如我们要调整高光区域的颜色，就拖动上面的色相滑块来定义高光区域颜色，再调整饱和度滑块，来定义色彩浓淡。这个功能不同于一般的图像颜色校正，一般能起到给照片定义整体色调的作用。 6、镜头校正改善镜头拍摄照片存在的几何形变。 扭曲度：鼠标拖动滑块来控制照片的畸变是向内收缩还是向外扩张 去边：色相用来选择照片中出现的色差的颜色，用于精确选中色差的颜色并去除。数量代表去除的程度，数量越多去除的力度越大。 晕影：手动压暗或提亮照片四周曝光，比如可以修复暗角，使图像边缘角落变亮 7、效果平时拍摄时，由于雾霾或者逆光，导致照片灰度很大，可以使用这个工具进行调节，增加照片的通透感。 裁剪后晕影：作用是给照片添加亮角或暗角。 调整面板1、白平衡工具：单击图片中自己认为是中性灰的位置，它会自动设置图像的白平衡 2、目标调整工具 参数曲线：曲线的横轴代表亮度，左侧为最暗，右侧为最亮。当曲线高于基准线时，此处就变亮;反之，低于基准线则变暗。 色相：右侧界面自动跳转到HSL调整中的色相 饱和度：右侧界面自动跳转到HSL调整中的饱和度 明亮度：右侧界面自动跳转到HSL调整中的明亮度 贴入 - 图片背景替换贴入命令的用法是将拷贝的图像显示在选区内，选区以外的图像会自动出现蒙版。 先将要使用的背景图片进行复制 然后在需要更换背景的图片上选择选区 编辑-选择性粘贴-贴入（快捷键：Alt+Shift+Ctrl+V）便能以当前选择作为图层蒙版进行背景更换。 通透1、通透：通明透亮。通明透亮就是要解决光色的原始性和纯粹性。也就是说对光色原色的最少的干扰，画面就会产生最大的通透感。2、CMY是青（Cyan）、洋红或品红（Magenta）和黄（Yellow）三种颜色的简写，是相减混色模式，用这种方法产生的颜色之所以称为相减色，是因为它减少了为视觉系统识别颜色所需要的反射光。RGB是红（Red）、绿（Green）和蓝（Blue）三种颜色的简写，是相加混色模式，每种颜色分量越多，得到的颜色越亮，每种颜色的取值范围为0~255。HSL即色相、饱和度和亮度（Hue, Saturation, Lightness）。色相（H）是色彩的基本属性，就是平常所说的颜色名称，如红色、黄色等。饱和度（S）是指色彩的纯度，越高色彩越纯，低则逐渐变灰，取0-100%的数值。亮度（L），取0-100%。3、红绿蓝中蕴含青品黄，青品黄中也蕴含红绿蓝，红色的支持色是黄色和品红色，互补色是青色；绿色的支持色分别是青色和黄色，互补色是品红色；蓝色的支持色分别是青色和品红色，互补色是黄色。这就意味着要想拍出非常漂亮的晚霞火烧云，就需要在这个颜色中加黄色和品红色就可以了，同时要减少青色的干扰。同样，要想拍出非常漂亮的蓝天，只需要加品红色和青色，同时要减少黄色的干扰。如果要想拍出大草原的翠绿，只需要加青色和黄色，同时要减去品红色对它的干扰。4、加色模式与减色模式其实讲的就是通过色相的混合最后产生对颜色明度的影响。加色模式就是颜色越加明度越高，比如说红色加绿色加蓝色最后得到中间的就是白色，白色的明度显然是最高的100 ，而其他的明度肯定小于100。减色模式则反之，颜色越加明度越低，比如洋红加黄色加青色，最后得到的就是黑色，黑色的明度为0，肯定比起他的色彩颜色会更低。 应用1、衣服换色方案一 选择工具将衣服抠取出，Ctrl + J复制图层 或者 将衣服抠取出后创建蒙版 点击色相 / 饱和度，调整色相、饱和度，选择着色 或者 点击纯色，模式选为正片叠底 Ctrl + Alt + G创建剪贴蒙版 方案二 点击色相 / 饱和度，点击取样，获取颜色衣服 调整色相、饱和度、明度 2、混合剪贴法去杂边 挑选并复制适合的通道 调整色阶Ctrl + L，让需要的选区跟背景有非常强烈的黑白对比 载入选区Ctrl + 点击通道，反选Ctrl + Shift + I 点击回到RGB图层，获取选区后直接调整边缘，生成带蒙版的新图层 利用黑白画笔在蒙版上补充缺失的部分 选中蒙版，点击删除蒙版，保证图层有透明区域(应用图层点应用)，新建图层(可在图层上创作内容)，执行图层-创建剪贴蒙版(Ctrl + Alt + G)，即上一层的内容会落到下一层的形状中去，模式选择颜色 吸管工具吸取杂边周围颜色，再用画笔对杂边进行涂抹覆盖3、调整白平衡图像 - 调整 - 匹配颜色，点击中和 4、混合画笔磨皮 对人物皮肤颜色取样 选择混合器画笔工具，参数为潮湿11%，载入80%，混合80%，流量20% 使用画笔对人物皮肤进行涂抹 5、降噪滤镜 - 杂色 - 减少杂色 调色校准一张照片的五要素 正确的黑白场：它决定了色彩平衡的状态:在Camera Raw中调节曝光即定义黑白场时，按住Alt可以作为参数正常的监视器，黑色表示没有曝光，红色表示即将过爆，黄色表示已经有点过爆，白色表示曝光过度。 准确的色彩还原：即定义灰场白平衡，调节色温和色调将中性灰的值调准，或直接一键使用白平衡。白平衡吸管工具照片18%中性灰（#808080）位置，没有则去找类似的灰色位置 丰富且合理的层次(即有灰度值)：通过填充亮光来丰富暗部细节，调节暗部来丰富亮部细节 足够的清晰度(相机参数设计里调高锐化值；Raw格式里调高清晰度，降低对比度；输出之前做锐化) 适当的饱和度。","categories":[{"name":"Photoshop","slug":"Photoshop","permalink":"http://yinzhm.gitee.io/categories/Photoshop/"}],"tags":[{"name":"Photoshop","slug":"Photoshop","permalink":"http://yinzhm.gitee.io/tags/Photoshop/"}]},{"title":"重庆之行","slug":"重庆之行","date":"2020-01-10T01:41:51.000Z","updated":"2021-02-14T12:33:11.643Z","comments":true,"path":"2020/01/10/重庆之行/","link":"","permalink":"http://yinzhm.gitee.io/2020/01/10/%E9%87%8D%E5%BA%86%E4%B9%8B%E8%A1%8C/","excerpt":"","text":"日期 旅游地 Day1 国泰广场、洪崖洞、解放碑 Day2 山城步道、李子坝、抗战文化一条街、八一好吃街、鹅岭二厂、观音桥、朝天门 Day3 磁器口、渣滓洞、南山一棵树、长江索道 Day4 武隆天生三桥、武隆龙水峡地缝 Day5 涂鸦一条街、四川美术学院、梦幻城堡乐园 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2019年2月份的时候，我跟我的大学同学去了重庆五日游。去的时候坐的是廉价航空，真的是坐的我难受死了，不过这应该是我有记忆以来第一次坐飞机。重庆不愧是中国第一魔幻城市，让人摸不着方向。好吃好玩的地方有很多，洪崖洞（中国版的千与千寻）在晚上真的很漂亮，当然游客也是真的多；八一好吃街（吃货的天堂，健身爱好者的地狱）；鹅岭二厂（这里我倒是没觉得有啥特别的）；武隆天坑地缝（空气清新，自然景观奇特）；李子坝（可以看到轻轨穿过建筑的网红打卡景点）；南山一棵树（可以从最高点看到重庆的全景）；长江索道（乘坐索道横跨长江观江景）；磁器口古镇（各种特色小吃，看川剧）。当然了，来到重庆，怎么能不吃重庆火锅呢。有一说一，重庆的火锅微辣也是辣的我疯狂出汗。重庆给我的感觉很好，不同于上海的快节奏生活，这里很适合居住。重庆人也很热情，我们在寻找回民宿的路上还得到了热心市民的帮助。说到这不由得想起了重庆早上的重庆小面和红油抄手，真的怀念。 [{\"url\":\"https://s2.ax1x.com/2020/01/11/l5pEkR.jpg\",\"alt\":\"l5pEkR.jpg\"},{\"url\":\"https://s2.ax1x.com/2020/01/11/l5pk79.jpg\",\"alt\":\"l5pk79.jpg\"},{\"url\":\"https://s2.ax1x.com/2020/01/11/l5pmp6.jpg\",\"alt\":\"l5pmp6.jpg\"},{\"url\":\"https://s2.ax1x.com/2020/01/11/l5p0BQ.jpg\",\"alt\":\"l5p0BQ.jpg\"},{\"url\":\"https://s2.ax1x.com/2020/01/11/l5pZfx.jpg\",\"alt\":\"l5pZfx.jpg\"},{\"url\":\"https://s2.ax1x.com/2020/01/11/l5pl0H.jpg\",\"alt\":\"l5pl0H.jpg\"},{\"url\":\"https://s2.ax1x.com/2020/01/11/l5pKXD.jpg\",\"alt\":\"l5pKXD.jpg\"},{\"url\":\"https://s2.ax1x.com/2020/01/11/l5pu6O.jpg\",\"alt\":\"l5pu6O.jpg\"},{\"url\":\"https://s2.ax1x.com/2020/01/11/l5pg3V.jpg\",\"alt\":\"l5pg3V.jpg\"},{\"url\":\"https://s2.ax1x.com/2020/01/11/l5p8AA.jpg\",\"alt\":\"l5p8AA.jpg\"},{\"url\":\"https://s2.ax1x.com/2020/01/11/l5pB7j.jpg\",\"alt\":\"l5pB7j.jpg\"},{\"url\":\"https://s2.ax1x.com/2020/01/11/l5pyhq.jpg\",\"alt\":\"l5pyhq.jpg\"},{\"url\":\"https://s2.ax1x.com/2020/01/11/l5psNn.jpg\",\"alt\":\"l5psNn.jpg\"},{\"url\":\"https://s2.ax1x.com/2020/01/11/l5pVt1.jpg\",\"alt\":\"l5pVt1.jpg\"},{\"url\":\"https://s2.ax1x.com/2020/01/11/l5pGtI.jpg\",\"alt\":\"l5pGtI.jpg\"},{\"url\":\"https://s2.ax1x.com/2020/01/11/l5prAs.jpg\",\"alt\":\"l5prAs.jpg\"},{\"url\":\"https://s2.ax1x.com/2020/01/11/l5pajS.jpg\",\"alt\":\"l5pajS.jpg\"},{\"url\":\"https://s2.ax1x.com/2020/01/11/l5pUc8.jpg\",\"alt\":\"l5pUc8.jpg\"},{\"url\":\"https://s2.ax1x.com/2020/01/11/l5pt9P.jpg\",\"alt\":\"l5pt9P.jpg\"},{\"url\":\"https://s2.ax1x.com/2020/01/11/l5pJht.jpg\",\"alt\":\"l5pJht.jpg\"},{\"url\":\"https://s2.ax1x.com/2020/01/11/l5pn1K.jpg\",\"alt\":\"l5pn1K.jpg\"},{\"url\":\"https://s2.ax1x.com/2020/01/11/l5poNR.jpg\",\"alt\":\"l5poNR.jpg\"},{\"url\":\"https://s2.ax1x.com/2020/01/11/l5pIE9.jpg\",\"alt\":\"l5pIE9.jpg\"},{\"url\":\"https://s2.ax1x.com/2020/01/11/l5p4HJ.jpg\",\"alt\":\"l5p4HJ.jpg\"},{\"url\":\"https://s2.ax1x.com/2020/01/11/l5phB4.jpg\",\"alt\":\"l5phB4.jpg\"},{\"url\":\"https://s2.ax1x.com/2020/01/11/l5pfuF.jpg\",\"alt\":\"l5pfuF.jpg\"},{\"url\":\"https://s2.ax1x.com/2020/01/11/l5pRjU.jpg\",\"alt\":\"l5pRjU.jpg\"},{\"url\":\"https://s2.ax1x.com/2020/01/11/l5p2cT.jpg\",\"alt\":\"l5p2cT.jpg\"},{\"url\":\"https://s2.ax1x.com/2020/01/11/l5AfRs.jpg\",\"alt\":\"l5AfRs.jpg\"},{\"url\":\"https://s2.ax1x.com/2020/01/11/l5Ahzn.jpg\",\"alt\":\"l5Ahzn.jpg\"},{\"url\":\"https://s2.ax1x.com/2020/01/11/l5AcdS.jpg\",\"alt\":\"l5AcdS.jpg\"},{\"url\":\"https://s2.ax1x.com/2020/02/02/1tGWUH.jpg\",\"alt\":\"1tGWUH.jpg\"},{\"url\":\"https://s2.ax1x.com/2020/01/11/l5AgIg.jpg\",\"alt\":\"l5AgIg.jpg\"},{\"url\":\"https://s2.ax1x.com/2020/01/11/l5A5Mq.jpg\",\"alt\":\"l5A5Mq.jpg\"},{\"url\":\"https://s2.ax1x.com/2020/01/11/l5AoLV.jpg\",\"alt\":\"l5AoLV.jpg\"},{\"url\":\"https://s2.ax1x.com/2020/01/11/l5AHdU.jpg\",\"alt\":\"l5AHdU.jpg\"}] 加载更多","categories":[{"name":"相册","slug":"相册","permalink":"http://yinzhm.gitee.io/categories/%E7%9B%B8%E5%86%8C/"}],"tags":[]},{"title":"2019听歌列表","slug":"2019听歌列表","date":"2019-12-31T16:37:14.000Z","updated":"2021-01-03T13:31:28.704Z","comments":true,"path":"2020/01/01/2019听歌列表/","link":"","permalink":"http://yinzhm.gitee.io/2020/01/01/2019%E5%90%AC%E6%AD%8C%E5%88%97%E8%A1%A8/","excerpt":"","text":"2019国内歌单 var options = {\"narrow\":false,\"autoplay\":false,\"showlrc\":3,\"listmaxheight\":\"1500px\",\"music\":[{\"title\":\"第三人称\",\"author\":\"买辣椒也用券\",\"url\":\"http://music.163.com/song/media/outer/url?id=502043537.mp3\",\"pic\":\"http://p1.music.126.net/nOVxBaX0IG1PsV4WfSoodA==/109951164379891919.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/disanrenchen.lrc\"},{\"title\":\"嚣张\",\"author\":\"en\",\"url\":\"http://music.163.com/song/media/outer/url?id=1382596189.mp3\",\"pic\":\"http://p1.music.126.net/NhkuFBphLFaSmYMeW1-frQ==/109951164271814514.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/xiaozhang.lrc\"},{\"title\":\"嗜好\",\"author\":\"颜人中\",\"url\":\"http://music.163.com/song/media/outer/url?id=1391891631.mp3\",\"pic\":\"http://p2.music.126.net/J6HaJjtgv-yVVjyUm-h-AA==/109951164373633387.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/shihao.lrc\"},{\"title\":\"野狼disco\",\"author\":\"宝石gem\",\"url\":\"http://music.163.com/song/media/outer/url?id=1357785909.mp3\",\"pic\":\"http://p2.music.126.net/USRrIEfSNxJ4JnfKp4f6pA==/109951164470147956.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/yelangdisco.lrc\"},{\"title\":\"下山\",\"author\":\"要不要买菜\",\"url\":\"http://music.163.com/song/media/outer/url?id=1404885266.mp3\",\"pic\":\"http://p1.music.126.net/Aj4X1kpV-C2LLi-e_Xhgvg==/109951164499744148.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/xiashan.lrc\"},{\"title\":\"那女孩对我说\",\"author\":\"Uu\",\"url\":\"http://music.163.com/song/media/outer/url?id=1372796676.mp3\",\"pic\":\"http://p2.music.126.net/tXo6kGSy27gXlQzOI2O5BA==/109951164161042589.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/nanvhaiduiwoshuo.lrc\"},{\"title\":\"麻雀\",\"author\":\"李荣浩\",\"url\":\"http://music.163.com/song/media/outer/url?id=1407551413.mp3\",\"pic\":\"http://p1.music.126.net/TzlSVBiNtpRD2b7MT2Hi-w==/109951164527590793.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/maque.lrc\"},{\"title\":\"你的酒馆对我打了烊\",\"author\":\"陈雪凝\",\"url\":\"http://music.163.com/song/media/outer/url?id=1341964346.mp3\",\"pic\":\"http://p1.music.126.net/LiRR__0pJHSivqBHZzbMUw==/109951163816225567.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/nidejiuguan.lrc\"},{\"title\":\"浪子回头\",\"author\":\"茄子蛋\",\"url\":\"http://music.163.com/song/media/outer/url?id=516728102.mp3\",\"pic\":\"http://p1.music.126.net/emWwYFceRZ2plNWgnGUDfg==/109951163333175426.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/langzi.lrc\"},{\"title\":\"起风了\",\"author\":\"买辣椒也用券\",\"url\":\"http://music.163.com/song/media/outer/url?id=1330348068.mp3\",\"pic\":\"http://p1.music.126.net/diGAyEmpymX8G7JcnElncQ==/109951163699673355.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/qifengle.lrc\"},{\"title\":\"芒种\",\"author\":\"音阙诗听 / 赵方婧\",\"url\":\"http://music.163.com/song/media/outer/url?id=1369798757.mp3\",\"pic\":\"http://p1.music.126.net/7ZKMPIvPcwaK08ffDBTjJw==/109951164124664532.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/mangzhong.lrc\"},{\"title\":\"说好不哭\",\"author\":\"周杰伦\",\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/shbk.mp3\",\"pic\":\"http://y.gtimg.cn/music/photo_new/T002R300x300M000002gBTVk4JEE2T.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/shuohaobuku.lrc\"},{\"title\":\"这一生关于你的风景\",\"author\":\"枯木逢春\",\"url\":\"http://music.163.com/song/media/outer/url?id=1356350562.mp3\",\"pic\":\"http://p1.music.126.net/cPkQaIjsYNKqNUUSgnJztQ==/109951164096998306.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/zheyisheng.lrc\"},{\"title\":\"失眠飞行\",\"author\":\"接个吻，开一枪 / 沈以诚 / 薛明媛\",\"url\":\"http://music.163.com/song/media/outer/url?id=1365898499.mp3\",\"pic\":\"http://p2.music.126.net/Bq6Io8lpY1l2HsQ28QKFlw==/109951164083996255.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/shimianfeixing.lrc\"},{\"title\":\"记·念\",\"author\":\"雷雨心\",\"url\":\"http://music.163.com/song/media/outer/url?id=36229053.mp3\",\"pic\":\"http://p2.music.126.net/LWmhB3XX8szN3V9TU-A5UA==/3390893862255408.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/jinian.lrc\"},{\"title\":\"消愁\",\"author\":\"毛不易\",\"url\":\"http://music.163.com/song/media/outer/url?id=569200213.mp3\",\"pic\":\"http://p2.music.126.net/vmCcDvD1H04e9gm97xsCqg==/109951163350929740.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/xc.lrc\"},{\"title\":\"写给黄淮\",\"author\":\"解忧邵帅\",\"url\":\"http://music.163.com/song/media/outer/url?id=1334295185.mp3\",\"pic\":\"http://p1.music.126.net/CG8hLG4To_TZum0rIGk7WA==/109951163764772334.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/xghh.lrc\"},{\"title\":\"飞云之下\",\"author\":\"韩红 / 林俊杰\",\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/fyzx.mp3\",\"pic\":\"http://y.gtimg.cn/music/photo_new/T002R300x300M000000XAvOz4exGKL.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/fyzx.lrc\"},{\"title\":\"句号\",\"author\":\"邓紫棋\",\"url\":\"http://music.163.com/song/media/outer/url?id=1405283464.mp3\",\"pic\":\"http://p1.music.126.net/KTo5oSxH3CPA5PBTeFKDyA==/109951164581432409.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/jh.lrc\"},{\"title\":\"桥边姑娘\",\"author\":\"海伦\",\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/qbgn.mp3\",\"pic\":\"http://y.gtimg.cn/music/photo_new/T002R300x300M0000037Yq3H3RznaX.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/qbgn.lrc\"},{\"title\":\"多想在平庸的生活拥抱你\",\"author\":\"隔壁老樊\",\"url\":\"http://music.163.com/song/media/outer/url?id=1346104327.mp3\",\"pic\":\"http://p1.music.126.net/gNbAlXamNjhR2j3aOukNhg==/109951164232796511.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/dxz.lrc\"},{\"title\":\"四块五\",\"author\":\"隔壁老樊\",\"url\":\"http://music.163.com/song/media/outer/url?id=1365221826.mp3\",\"pic\":\"http://p1.music.126.net/gNbAlXamNjhR2j3aOukNhg==/109951164232796511.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/sikuaiwu.lrc\"},{\"title\":\"我的名字\",\"author\":\"焦迈奇\",\"url\":\"http://music.163.com/song/media/outer/url?id=554241732.mp3\",\"pic\":\"http://p2.music.126.net/a_rb8pgC5R_hO-lfm7acSw==/109951164019567772.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/wdmz.lrc\"},{\"title\":\"世间美好与你环环相扣\",\"author\":\"柏松\",\"url\":\"http://music.163.com/song/media/outer/url?id=1363948882.mp3\",\"pic\":\"http://p1.music.126.net/DK1_4sP_339o5rowMdPXdw==/109951164071024476.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/sjmhynhhxk.lrc\"},{\"title\":\"你的答案\",\"author\":\"阿冗\",\"url\":\"http://music.163.com/song/media/outer/url?id=1400256289.mp3\",\"pic\":\"http://p2.music.126.net/OlX-4S4L0Hdkyy_DQ27zag==/109951164459621658.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/nidedaan.lrc\"},{\"title\":\"故人泪\",\"author\":\"泠鸢yousa / KBShinya\",\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/grl.mp3\",\"pic\":\"http://p2.music.126.net/fxI_iAsaRU9M5ZGE-Pu7iw==/109951164479032071.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/grl.lrc\"},{\"title\":\"繁华唱遍\",\"author\":\"泠鸢yousa\",\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/fhcb.mp3\",\"pic\":\"http://p1.music.126.net/fxI_iAsaRU9M5ZGE-Pu7iw==/109951164479032071.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/fhcb.lrc\"}]}; options.element = document.getElementById(\"aplayer-wyVtLDYB\"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); ## 2019国外歌单 var options = {\"narrow\":false,\"autoplay\":false,\"showlrc\":3,\"listmaxheight\":\"1500px\",\"music\":[{\"title\":\"Lemon\",\"author\":\"米津玄師\",\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/lemon.mp3\",\"pic\":\"http://y.gtimg.cn/music/photo_new/T002R300x300M000002OR8wD3Lo3E5.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/lemon.lrc\"},{\"title\":\"Monochrome Syndrome\",\"author\":\"Aimer\",\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/monochrome_syndrome.mp3\",\"pic\":\"http://y.gtimg.cn/music/photo_new/T002R300x300M000001Hh0qx1b9jsi.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/monochrome_syndrome.lrc\"},{\"title\":\"STAND ALONE\",\"author\":\"Aimer\",\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/stand_alone.mp3\",\"pic\":\"http://y.gtimg.cn/music/photo_new/T002R300x300M000003puLVV1kBb4H.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/stand_alone.lrc\"},{\"title\":\"花びらたちのマーチ\",\"author\":\"Aimer\",\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/hana.mp3\",\"pic\":\"http://y.gtimg.cn/music/photo_new/T002R300x300M000001UdhE42Q0wYz.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/hana.lrc\"},{\"title\":\"Black Bird\",\"author\":\"Aimer\",\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/black_bird.mp3\",\"pic\":\"http://y.gtimg.cn/music/photo_new/T002R300x300M000002gK1XJ2balHR.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/black_bird.lrc\"},{\"title\":\"ADAMAS\",\"author\":\"LiSA\",\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/ADAMAS.mp3\",\"pic\":\"http://y.gtimg.cn/music/photo_new/T002R300x300M000001MakRW1tujG1.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/ADAMAS.lrc\"},{\"title\":\"unlasting\",\"author\":\"LiSA\",\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/unlasting.mp3\",\"pic\":\"http://y.gtimg.cn/music/photo_new/T002R300x300M000004T02kD1ybahm.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/unlasting.lrc\"},{\"title\":\"紅蓮華\",\"author\":\"LiSA\",\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/hlh.mp3\",\"pic\":\"http://y.gtimg.cn/music/photo_new/T002R300x300M000000UWQza1jUw3L.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/hlh.lrc\"},{\"title\":\"カワキヲアメク\",\"author\":\"美波\",\"url\":\"http://music.163.com/song/media/outer/url?id=1342950406.mp3\",\"pic\":\"http://p2.music.126.net/eonIqMlLxORgXDSzjabo2g==/109951163827366715.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/mb.lrc\"},{\"title\":\"チカっとチカ千花っ♡\",\"author\":\"小原好美\",\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/huiyedaxiaojie.mp3\",\"pic\":\"http://y.gtimg.cn/music/photo_new/T002R300x300M0000042CPhh30mHii.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/huiyedaxiaojie.lrc\"},{\"title\":\"白日\",\"author\":\"King Gnu\",\"url\":\"http://music.163.com/song/media/outer/url?id=1347630432.mp3\",\"pic\":\"http://p2.music.126.net/x8E0HerDrGxEIxPFvefCKA==/109951163881085053.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/bairi.lrc\"},{\"title\":\"Pretender\",\"author\":\"Official髭男dism\",\"url\":\"http://music.163.com/song/media/outer/url?id=1365924378.mp3\",\"pic\":\"http://p2.music.126.net/cExKIgR492rIdcSd4qLCkA==/109951164080309280.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/Pretender.lrc\"},{\"title\":\"SOLO\",\"author\":\"Jennie (제니)\",\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/solo.mp3\",\"pic\":\"http://y.gtimg.cn/music/photo_new/T002R300x300M000003EVHg43T062e.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/solo.lrc\"},{\"title\":\"Señorita\",\"author\":\"Shawn Mendes / Camila Cabello\",\"url\":\"http://music.163.com/song/media/outer/url?id=1373168742.mp3\",\"pic\":\"http://p2.music.126.net/eSrLKe5g3U8jX-lb629q6A==/109951164162885535.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/senorita.lrc\"},{\"title\":\"輪!Moon!dass!cry!\",\"author\":\"赤﨑千夏 / 戸松遥 / 豊崎愛生\",\"url\":\"http://music.163.com/song/media/outer/url?id=1379839469.mp3\",\"pic\":\"http://p1.music.126.net/1R8TI7qeWzmHPqTjSUFfzg==/109951164235841111.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/moon.lrc\"},{\"title\":\"インフェルノ\",\"author\":\"Mrs. GREEN APPLE\",\"url\":\"http://music.163.com/song/media/outer/url?id=1378624805.mp3\",\"pic\":\"http://p1.music.126.net/mqKEorxl-3pqDZv5dHmXwA==/109951164221348911.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/yyxfd1.lrc\"},{\"title\":\"Veil\",\"author\":\"須田景凪\",\"url\":\"http://music.163.com/song/media/outer/url?id=1375753706.mp3\",\"pic\":\"http://p1.music.126.net/aQioi1febxlYe8IQIy07UA==/109951164303072451.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/veil.lrc\"},{\"title\":\"瞬き\",\"author\":\"春茶\",\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/cc.mp3\",\"pic\":\"http://y.gtimg.cn/music/photo_new/T002R300x300M000003nr4dj46mInh.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/cc.lrc\"},{\"title\":\"Dance Monkey\",\"author\":\"Tones and I\",\"url\":\"http://music.163.com/song/media/outer/url?id=1364343491.mp3\",\"pic\":\"http://p1.music.126.net/p9Eie-x1qVgvX73W8y6KgQ==/109951164272074028.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/Dance_Monkey.lrc\"},{\"title\":\"It's Always The Little Things\",\"author\":\"郭顶 / Rachael Yamagata\",\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/it's_always_the_little_things.mp3\",\"pic\":\"http://y.gtimg.cn/music/photo_new/T002R300x300M000004dngBT1DjKfK.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/it's_always_the_little_things.lrc\"},{\"title\":\"Phoenix\",\"author\":\"Cailin Russo / Chrissy Costanza\",\"url\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/phoenix.mp3\",\"pic\":\"http://y.gtimg.cn/music/photo_new/T002R300x300M000004NHcSP4IIbSC.jpg\",\"lrc\":\"https://cdn.jsdelivr.net/gh/Gemini1996/assets@master/music/2019/phoenix.lrc\"}]}; options.element = document.getElementById(\"aplayer-yjwpRlbj\"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);","categories":[{"name":"音乐","slug":"音乐","permalink":"http://yinzhm.gitee.io/categories/%E9%9F%B3%E4%B9%90/"}],"tags":[{"name":"音乐","slug":"音乐","permalink":"http://yinzhm.gitee.io/tags/%E9%9F%B3%E4%B9%90/"}]},{"title":"人生的第一次10公里跑","slug":"人生的第一次10公里跑","date":"2019-02-06T14:19:02.000Z","updated":"2023-03-29T07:56:16.000Z","comments":true,"path":"2019/02/06/人生的第一次10公里跑/","link":"","permalink":"http://yinzhm.gitee.io/2019/02/06/%E4%BA%BA%E7%94%9F%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A110%E5%85%AC%E9%87%8C%E8%B7%91/","excerpt":"","text":"2019年的年初二是个难得一见的大晴天，一时兴起想要去尝试一下10公里跑orz。于是乎，我就坐在我妈的小电驴后面来到了新虹桥中心花园，在这个每天都是阴天的寒假里能有这么个好天气真的是不容易啊。虽然大家戏称在春节的时候上海是座空城，但是今天在公园里的人还是非常多的，可能大家都是出来晒太阳的8。可能是太久时间没跑了，跟着keep跑个3公里真的就已经不行了，后半程都是在跑跑走走，虽然keep训练是慢跑和快走结合，但还是觉得好累啊。跑完这10公里真的是相当不容易啊，跑了将近有1个半小时那么久。曾经认为跑个5公里就是自己的极限了，没想到今天还是坚持到了最后，完成了10公里的跑步之旅。人的潜力真的是靠逼出来的，“最困难之时，就是离成功不远之日”。跑的时候感觉累的不行，喘的不行，想要放弃了，但想到马上就能完成10公里这个小目标便还是能够咬咬牙坚持下去。去年看了一部新番叫做《强风吹拂》感触颇深，觉得非常好看，甚至我还买了小说去看。看了这部动画我相信不喜欢跑步的人也会有想去跑一跑的冲动吧！！！跑完10公里也算是人生中的小成就了，就在此记录一下不算好的10公里成绩吧，争取下次跑进1小时！！！","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yinzhm.gitee.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]},{"title":"HTTP的缓存机制","slug":"HTTP的缓存机制","date":"2019-01-04T14:39:51.000Z","updated":"2023-03-29T07:41:30.000Z","comments":true,"path":"2019/01/04/HTTP的缓存机制/","link":"","permalink":"http://yinzhm.gitee.io/2019/01/04/HTTP%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/","excerpt":"","text":"简介web缓存可以自动将资源副本保存到本地，减少了客户端与服务器之间的通信次数，加速页面加载，降低网络延迟。 强缓存和协商缓存1）浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如某个css文件，如果浏览器在加载它所在的网页时，这个css文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个css，连请求都不会发送到网页所在服务器；2）当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源；3）强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。4）当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。 强缓存1）当浏览器对某个资源的请求命中了强缓存时，返回的http状态为200，在chrome的开发者工具的network里面size会显示为from cache。2）强缓存是利用Expires或者Cache-Control这两个http response header实现的，它们都用来表示资源在客户端缓存的有效期。3）Expires: 是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT，它的缓存原理是： 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header加上Expires的header。浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）。浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较，如果请求时间在Expires指定的时间之前，就能命中缓存，否则就不行。如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header在重新加载的时候会被更新。 4）Cache-Control: Expires是较老的强缓存管理header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。所以在http1.1的时候，提出了一个新的header，就是Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：Cache-Control: max-age=315360000，它的缓存原理是： 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header加上Cache-Control的header。浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来。浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header在重新加载的时候会被更新。 5）Cache-Control描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更有效，安全，更灵活。6）这两个header可以只启用一个，也可以同时启用，当response header中，Expires和Cache-Control同时存在时，Cache-Control优先级高于Expires 关于协商缓存1）当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串2）协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的。3）【Last-Modified，If-Modified-Since】的控制缓存的原理是： 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间。浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值。服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header。浏览器收到304的响应后，就会从缓存中加载资源。如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。 4）【ETag、If-None-Match】: 【Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对header来管理协商缓存，这对header就是【ETag、If-None-Match】。它们的缓存管理的方式是： 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题。浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值。服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化浏览器收到304的响应后，就会从缓存中加载资源。 浏览器行为对缓存的影响1）如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会先检查是否命中强缓存，如果强缓存命中则直接读取缓存，如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，如果协商缓存命中，则告诉浏览器还是可以从缓存读取，否则才从服务器返回最新的资源。这是默认的处理方式2）以下行为可能改变缓存的默认处理方式 当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存。当f5刷新网页时，跳过强缓存，但是会检查协商缓存。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yinzhm.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://yinzhm.gitee.io/tags/HTTP/"}]},{"title":"HTTP状态码","slug":"HTTP状态码","date":"2019-01-01T02:18:21.000Z","updated":"2023-03-29T07:41:41.000Z","comments":true,"path":"2019/01/01/HTTP状态码/","link":"","permalink":"http://yinzhm.gitee.io/2019/01/01/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/","excerpt":"","text":"简介状态码让客户端知道请求结果，服务器是成功处理了请求，还是出现了错误，又或者是不处理。状态码会和原因短语成对出现，状态码由3位数字组成。 属性 类别 说明 1XX 信息 请求已被接受，正在处理中 2XX 成功 请求已处理成功 3XX 重定向 客户端需要附加操作才能完成请求 4XX 客户端错误 客户端发起的请求服务器无法处理 5XX 服务器错误 服务器在处理请求时发生错误或异常 “200 OK”表示请求正常处理完成。“204 No Content 表示请求处理成功，但是没有资源返回”“301 Moved Permanently”表示永久重定向，请求的网页已经永久移动到新位置“302 Moved”表示临时重定向。“304 Not Modified”表示自从上一次请求以来，页面的内容没有改变过。服务器返回此响应时，不会返回网页内容。“400 Bad Request”表示客户端请求有语法错误，不能被服务器所理解。“401 Unauthorized”表示请求未经授权。“403 Forbidden”表示对请求资源的访问被服务器拒绝了。“404 Not Found”表示服务器上无法找到请求的资源。“500 Internal Server Error”表示服务器端在执行请求时发生了错误。也有可能是Web应用存在的bug或某些临时的故障。“503 Server Unavailable”表示请求未完成，服务器临时过载或当机，一段时间后可能恢复。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yinzhm.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"状态码","slug":"状态码","permalink":"http://yinzhm.gitee.io/tags/%E7%8A%B6%E6%80%81%E7%A0%81/"},{"name":"HTTP","slug":"HTTP","permalink":"http://yinzhm.gitee.io/tags/HTTP/"}]},{"title":"图片放大镜效果实现","slug":"图片放大镜","date":"2018-12-31T12:10:09.000Z","updated":"2023-03-29T07:35:48.000Z","comments":true,"path":"2018/12/31/图片放大镜/","link":"","permalink":"http://yinzhm.gitee.io/2018/12/31/%E5%9B%BE%E7%89%87%E6%94%BE%E5%A4%A7%E9%95%9C/","excerpt":"","text":"html代码1234567891011121314&lt;div class=&quot;box&quot; id=&quot;box&quot;&gt; &lt;!--小层--&gt; &lt;div class=&quot;small&quot;&gt; &lt;img src=&quot;small.png&quot; width=&quot;350&quot; alt=&quot;&quot;/&gt; &lt;!--遮挡层--&gt; &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!--大层--&gt; &lt;div class=&quot;big&quot;&gt; &lt;!--大图--&gt; &lt;img src=&quot;big.jpg&quot; width=&quot;800&quot; alt=&quot;&quot;/&gt; &lt;/div&gt;&lt;/div&gt; css代码123456789101112131415161718192021222324252627282930.box &#123; width: 350px; height: 350px; margin: 100px; border: 1px solid #ccc; position: relative;&#125;.big &#123; width: 400px; height: 400px; position: absolute; top: 0; left: 360px; border: 1px solid #ccc; overflow: hidden; display: none;&#125;.mask &#123; width: 175px; height: 175px; background: rgba(255, 255, 0, 0.4); position: absolute; top: 0px; left: 0px; cursor: move; display: none;&#125;.small &#123; position: relative;&#125; JavaScript代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 获取需要的元素var box = document.getElementById(&quot;box&quot;);// 获取小图的divvar small = box.children[0];// 获取遮挡层var mask = small.children[1];// 获取大图的divvar big = box.children[1];// 获取大图var bigImg = big.children[0];// 鼠标进入时显示遮挡层和大图box.onmouseover = function () &#123; mask.style.display = &quot;block&quot;; big.style.display = &quot;block&quot;;&#125;;// 鼠标离开时隐藏遮挡层和大图box.onmouseout = function () &#123; mask.style.display = &quot;none&quot;; big.style.display = &quot;none&quot;;&#125;;// 鼠标的移动事件---鼠标是在小层上移动small.onmousemove = function (event) &#123; // 鼠标此时的可视区域的横坐标和纵坐标 // 设置鼠标在遮挡层的中间显示 // clientX表示鼠标离区域左边距离 var x = event.clientX - mask.offsetWidth / 2; var y = event.clientY - mask.offsetHeight / 2; // 解决margin100px造成的偏移问题 x = x - 100; y = y - 100; // 横坐标的最小值(左边界) x = x &lt; 0 ? 0 : x; // 纵坐标的最小值(上边界) y = y &lt; 0 ? 0 : y; // 横坐标的最大值(右边界) x = x &gt; small.offsetWidth - mask.offsetWidth ? small.offsetWidth - mask.offsetWidth : x; // 纵坐标的最大值(下边界) y = y &gt; small.offsetHeight - mask.offsetHeight ? small.offsetHeight - mask.offsetHeight : y; // 为遮挡层的left和top赋值 mask.style.left = x + &quot;px&quot;; mask.style.top = y + &quot;px&quot;; // 遮挡层的移动距离与大图的移动距离成正比 // 遮挡层的移动距离 / 大图的移动距离 = 遮挡层的最大移动距离 / 大图的最大移动距离 // 大图的横向的最大移动距离 var maxX = bigImg.offsetWidth - big.offsetWidth; // 大图的移动距离 = 遮挡层的移动距离 * 大图的最大移动距离 / 遮挡层的最大移动距离 // 大图的横向移动的坐标 var bigImgMoveX = x * maxX / (small.offsetWidth - mask.offsetWidth); // 大图的纵向移动的坐标 var bigImgMoveY = y * maxX / (small.offsetWidth - mask.offsetWidth); // 设置图片移动 bigImg.style.marginLeft = -bigImgMoveX + &quot;px&quot;; bigImg.style.marginTop = -bigImgMoveY + &quot;px&quot;;&#125;;","categories":[{"name":"前端","slug":"前端","permalink":"http://yinzhm.gitee.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[]},{"title":"图片跟随鼠标移动效果实现","slug":"图片跟随鼠标移动","date":"2018-12-31T05:57:15.000Z","updated":"2023-03-29T07:36:26.000Z","comments":true,"path":"2018/12/31/图片跟随鼠标移动/","link":"","permalink":"http://yinzhm.gitee.io/2018/12/31/%E5%9B%BE%E7%89%87%E8%B7%9F%E9%9A%8F%E9%BC%A0%E6%A0%87%E7%A7%BB%E5%8A%A8/","excerpt":"","text":"html代码1&lt;img src=&quot;1.jpg&quot; alt=&quot;&quot; id=&quot;img&quot; /&gt; css代码12345678910*&#123; margin: 0; padding: 0; &#125; body&#123; height: 2000px; &#125; img&#123; position: absolute; &#125; JavaScript代码123456789101112131415161718192021222324252627282930313233343536373839var move = &#123; // window.event和事件参数对象e的兼容 getEvent: function (event) &#123; return window.event || event; &#125;, // 可视区域的横坐标的兼容代码 getClientX: function (event) &#123; return this.getEvent(event).clientX; &#125;, // 可视区域的纵坐标的兼容代码 getClientY: function (event) &#123; return this.getEvent(event).clientY; &#125;, // 页面向左卷曲出去的横坐标 getScrollLeft: function () &#123; return window.pageXOffset || document.body.scrollLeft || document.documentElement.scrollLeft || 0; &#125;, // 页面向上卷曲出去的纵坐标 getScrollTop: function () &#123; return window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop || 0; &#125;, // 相对于页面的横坐标(pageX或者是clientX + scrollLeft) getPageX: function (event) &#123; return this.getEvent(event).pageX ? this.getEvent(event).pageX: this.getClientX(event) + this.getScrollLeft(); &#125;, // 相对于页面的纵坐标(pageY或者是clientY + scrollTop) getPageY: function (event) &#123; return this.getEvent(event).pageY ? this.getEvent(event).pageY: this.getClientY(event) + this.getScrollTop(); &#125;&#125;;document.onmousemove = function (event) &#123; document.getElementById(&quot;img&quot;).style.left = move.getPageX(event)+&quot;px&quot;; document.getElementById(&quot;img&quot;).style.top = move.getPageY(event)+&quot;px&quot;;&#125;;","categories":[{"name":"前端","slug":"前端","permalink":"http://yinzhm.gitee.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[]},{"title":"旋转木马效果实现","slug":"旋转木马","date":"2018-12-31T02:08:40.000Z","updated":"2023-03-29T07:37:37.000Z","comments":true,"path":"2018/12/31/旋转木马/","link":"","permalink":"http://yinzhm.gitee.io/2018/12/31/%E6%97%8B%E8%BD%AC%E6%9C%A8%E9%A9%AC/","excerpt":"","text":"html代码123456789101112131415&lt;div class=&quot;wrap&quot; id=&quot;wrap&quot;&gt; &lt;div class=&quot;slide&quot; id=&quot;slide&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;1.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;2.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;3.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;4.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;5.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;arrow&quot; id=&quot;arrow&quot;&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;prev&quot; id=&quot;arrLeft&quot;&gt;&lt;/a&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;next&quot; id=&quot;arrRight&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; css代码1234567891011121314151617181920212223242526272829303132.wrap&#123; width:1200px; margin:100px auto;&#125;.slide &#123; height:500px; position: relative;&#125;.slide li&#123; position: absolute; left:200px; top:0;&#125;.slide li img&#123; width:100%;&#125;.arrow&#123; opacity: 0;&#125;.prev,.next&#123; width:76px; height:112px; position: absolute; top:50%; margin-top:-56px; background: url(../images/prev.png) no-repeat; z-index: 99;&#125;.next&#123; right:0; background-image: url(../images/next.png) no-repeat;&#125; JavaScript代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133var config = [&#123; width: 400, top: 20, left: 50, opacity: 0.2, zIndex: 2 &#125;, &#123; width: 600, top: 70, left: 0, opacity: 0.8, zIndex: 3 &#125;,&#123; width: 800, top: 100, left: 200, opacity: 1, zIndex: 4 &#125;,&#123; width: 600, top: 70, left: 600, opacity: 0.8, zIndex: 3 &#125;,&#123; width: 400, top: 20, left: 750, opacity: 0.2, zIndex: 2 &#125;]; // 页面加载的事件 window.onload = function () &#123; // 假设所有的动画执行完毕 var flag = true; // 获取所有的列 var list = document.getElementById(&quot;slide&quot;).getElementsByTagName(&quot;li&quot;); // 图片散开 function assign() &#123; for (var i = 0; i &lt; list.length; i++) &#123; // 设置每个li,把宽,层级,透明度,left,top到达指定的目标位置 animate(list[i], config[i],function () &#123; flag = true; &#125;); &#125; &#125; assign(); // 右边按钮 document.getElementById(&quot;arrRight&quot;).onclick = function () &#123; if (flag)&#123; // 只有当动画执行完毕才能进行下一次动画 flag = false; // 把数组第一个元素放到最后 config.push(config.shift()); // 重新分配 assign(); &#125; &#125;; // 左边按钮 document.getElementById(&quot;arrLeft&quot;).onclick = function () &#123; if (flag)&#123; flag = false; // 把数组最后一个元素放到最前 config.unshift(config.pop()); assign(); &#125; &#125;; //鼠标进入,左右焦点的div显示 document.getElementById(&quot;slide&quot;).onmouseover = function () &#123; animate(document.getElementById(&quot;arrow&quot;), &#123;&quot;opacity&quot;: 1&#125;); &#125;; //鼠标离开,左右焦点的div隐藏 document.getElementById(&quot;slide&quot;).onmouseout = function () &#123; animate(document.getElementById(&quot;arrow&quot;), &#123;&quot;opacity&quot;: 0&#125;); &#125;; &#125;; // 获取元素的计算样式 function getAttrValue(element,attr) &#123; return element.currentStyle ? element.currentStyle[attr] : window.getComputedStyle(element,null)[attr] || 0; &#125; // 元素移动函数 function animate(element,json,fn) &#123; // 先清除计时器 clearInterval(element.timeId); element.timeId = setInterval(function () &#123; // 假设都达到了目标 var flag = true; for (var attr in json)&#123; // 判断属性是不是opacity if (attr == &quot;opacity&quot;)&#123; var current = getAttrValue(element,attr) * 100; // 每次移动的步数 var target = json[attr] * 100; var step = (target-current) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); current = current + step; element.style[attr] = current / 100; &#125; // 判断属性是不是zIndex else if (attr == &quot;zIndex&quot;)&#123; element.style[attr] = json[attr]; &#125; // 其他属性的设置 else &#123; // 获取当前的位置 // getAttrValue(element,attr)获取的是字符串类型 var current = parseInt(getAttrValue(element,attr)) || 0; var target = json[attr]; var step = (target-current) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); current = current + step; element.style[attr] = current + &quot;px&quot;; &#125; // 如果没到目标结果就为false if (current != target)&#123; flag = false; &#125; &#125; if (flag)&#123; clearInterval(element.timeId); // 如果用户传入了回调的函数，执行回调函数 if (fn)&#123; fn(); &#125; &#125; console.log(&quot;target:&quot; + target + &quot;current:&quot; + current + &quot;step:&quot; + step); &#125;,10); &#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://yinzhm.gitee.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[]},{"title":"轮播图效果实现","slug":"轮播图","date":"2018-12-29T13:47:37.000Z","updated":"2023-03-29T07:35:41.000Z","comments":true,"path":"2018/12/29/轮播图/","link":"","permalink":"http://yinzhm.gitee.io/2018/12/29/%E8%BD%AE%E6%92%AD%E5%9B%BE/","excerpt":"","text":"html代码12345678910111213141516&lt;div class=&quot;all&quot; id=&#x27;box&#x27;&gt; &lt;div class=&quot;screen&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=&quot;1.jpg&quot; width=&quot;500&quot; height=&quot;200&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;2.jpg&quot; width=&quot;500&quot; height=&quot;200&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;3.jpg&quot; width=&quot;500&quot; height=&quot;200&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;4.jpg&quot; width=&quot;500&quot; height=&quot;200&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;5.jpg&quot; width=&quot;500&quot; height=&quot;200&quot;/&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt;&lt;/ol&gt; &lt;/div&gt; &lt;div id=&quot;arr&quot;&gt; &lt;span id=&quot;left&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span id=&quot;right&quot;&gt;&amp;gt;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; css代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586* &#123; padding: 0; margin: 0; list-style: none; border: 0;&#125;.all &#123; width: 500px; height: 200px; padding: 7px; border: 1px solid #ccc; margin: 100px auto; position: relative;&#125;.screen &#123; width: 500px; height: 200px; overflow: hidden; position: relative;&#125;.screen li &#123; width: 500px; height: 200px; overflow: hidden; float: left;&#125;.screen ul &#123; position: absolute; left: 0; top: 0px; width: 3000px;&#125;.all ol &#123; position: absolute; right: 10px; bottom: 10px; line-height: 20px; text-align: center;&#125;.all ol li &#123; float: left; width: 20px; height: 20px; background: #fff; border: 1px solid #ccc; margin-left: 10px; cursor: pointer;&#125;.all ol li.current &#123; background: #DB192A;&#125;#arr &#123; display: none;&#125;#arr span &#123; width: 40px; height: 40px; position: absolute; left: 5px; top: 50%; margin-top: -20px; background: #000; cursor: pointer; line-height: 40px; text-align: center; font-weight: bold; font-family: &#x27;黑体&#x27;; font-size: 30px; color: #fff; opacity: 0.3; border: 1px solid #fff;&#125;#arr #right &#123; right: 5px; left: auto;&#125; JavaScript代码获取相关元素12345678910111213141516// 获取最外层的divlet box = document.getElementById(&quot;box&quot;);// 获取相框let screen = box.children[0];// 获取ullet ulObj = screen.children[0];// 获取ul中的所有的lilet list = ulObj.children;// 获取ollet olObj = screen.children[1];// 焦点的divlet arr = document.getElementById(&quot;arr&quot;);// 获取相框的宽度let imgWidth = screen.offsetWidth;// 全局变量，图片索引值let pic = 0; 动态创建按钮，设置按钮相关操作123456789101112131415161718192021222324// 根据li个数创建小按钮for (let i = 0; i &lt; list.length; i++) &#123; // 创建li标签,加入到ol中 let liObj = document.createElement(&quot;li&quot;); olObj.appendChild(liObj); // 按钮上显示的数字 liObj.innerHTML = (i + 1); // 在每个ol中的li标签上添加一个自定义属性,存储索引值 liObj.setAttribute(&quot;index&quot;, i); // 注册鼠标进入事件 liObj.onmouseover = function () &#123; // 先清除所有的ol中的li的背景颜色 for (let j = 0; j &lt; olObj.children.length; j++) &#123; olObj.children[j].removeAttribute(&quot;class&quot;); &#125; // 设置当前鼠标进来的li的背景颜色 this.className = &quot;current&quot;; // 获取鼠标进入的li的当前索引值 pic = this.getAttribute(&quot;index&quot;); // 移动ul animate(ulObj, -pic * imgWidth); &#125;;&#125; 初始设置12345// 设置ol中第一个li有背景颜色olObj.children[0].className = &quot;current&quot;;// 克隆一个ul中第一个li,加入到ul中的最后// cloneNode()传递给它的参数是true，它将递归复制当前节点的所有子孙节点。ulObj.appendChild(ulObj.children[0].cloneNode(true)); 设置左右按钮12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 右边按钮document.getElementById(&quot;right&quot;).onclick = clickHandle;// 向右跳转动画function clickHandle() &#123; // 如果pic的值是ul中li的个数-1的值,此时页面显示克隆的图片,而用户会认为这是第一个图 // 所以,如果用户再次点击按钮,用户看到的是第二个图片 if (pic === list.length - 1) &#123; // 从第6个图,跳转到第一个图 // 先设置索引pic=0 pic = 0; // 把ul的位置还原成开始的默认位置 ulObj.style.left = 0 + &quot;px&quot;; &#125; // 设置pic加1,此时用户就会看到第二个图片了 pic++; // pic从0的值加1之后,pic的值是1,然后ul移动出去一个图片 animate(ulObj, -pic * imgWidth); // 如果pic==5说明,此时显示第6个图(内容是第一张图片),第一个小按钮有颜色 if (pic == list.length - 1) &#123; // 第五个按钮颜色干掉 olObj.children[olObj.children.length - 1].className = &quot;&quot;; // 第一个按钮设置颜色 olObj.children[0].className = &quot;current&quot;; &#125; else &#123; // 干掉所有的小按钮的背景颜色 for (let i = 0; i &lt; olObj.children.length; i++) &#123; olObj.children[i].removeAttribute(&quot;class&quot;); &#125; // 当前的pic索引对应的按钮设置颜色 olObj.children[pic].className = &quot;current&quot;; &#125;&#125;; // 左边按钮document.getElementById(&quot;left&quot;).onclick = function () &#123; // 如果此时在第一张图片迅速跳到第六张图 if (pic == 0) &#123; pic = 5; ulObj.style.left = -pic * imgWidth + &quot;px&quot;; &#125; pic--; animate(ulObj, -pic * imgWidth); // 设置按钮的颜色---所有的按钮干掉颜色 for (let i = 0; i &lt; olObj.children.length; i++) &#123; olObj.children[i].removeAttribute(&quot;class&quot;); &#125; // 当前的pic索引对应的按钮设置颜色 olObj.children[pic].className = &quot;current&quot;;&#125;; 自动播放12345678910111213let timeId = setInterval(clickHandle,1000); // 鼠标进入，显示左右焦点的div box.onmouseover = function () &#123; arr.style.display = &quot;block&quot;; // 鼠标进入废掉之前的定时器 clearInterval(timeId); &#125;; // 鼠标离开，隐藏左右焦点的div box.onmouseout = function () &#123; arr.style.display = &quot;none&quot;; // 鼠标离开自动播放 timeId = setInterval(clickHandle,1000); &#125;; 移动动画的函数1234567891011121314151617181920212223// 设置任意的一个元素,移动到指定的目标位置function animate(element, target) &#123; // 先清除定时器 clearInterval(element.timeId); // 定时器的id值存储到对象的一个属性中 element.timeId = setInterval(function () &#123; // 获取元素的当前的位置 let current = element.offsetLeft; // 每次移动的距离 step = current &lt; target ? 10 : -10; // 从当前位置移动到目标位置 current += step; // 比较离目标位置的距离与每次移动的距离 if (Math.abs(current - target) &gt; Math.abs(step)) &#123; element.style.left = current + &quot;px&quot;; &#125; else &#123; // 清理定时器 clearInterval(element.timeId); // 离目标的距离小于每次移动的距离时，直接到达目标 element.style.left = target + &quot;px&quot;; &#125; &#125;, 10);&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://yinzhm.gitee.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[]}],"categories":[{"name":"数据分析","slug":"数据分析","permalink":"http://yinzhm.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"读后感","slug":"读后感","permalink":"http://yinzhm.gitee.io/categories/%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"name":"运营","slug":"运营","permalink":"http://yinzhm.gitee.io/categories/%E8%BF%90%E8%90%A5/"},{"name":"音乐","slug":"音乐","permalink":"http://yinzhm.gitee.io/categories/%E9%9F%B3%E4%B9%90/"},{"name":"相册","slug":"相册","permalink":"http://yinzhm.gitee.io/categories/%E7%9B%B8%E5%86%8C/"},{"name":"Photoshop","slug":"Photoshop","permalink":"http://yinzhm.gitee.io/categories/Photoshop/"},{"name":"随笔","slug":"随笔","permalink":"http://yinzhm.gitee.io/categories/%E9%9A%8F%E7%AC%94/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://yinzhm.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"前端","slug":"前端","permalink":"http://yinzhm.gitee.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"数据分析","slug":"数据分析","permalink":"http://yinzhm.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yinzhm.gitee.io/tags/MySQL/"},{"name":"EXCEL","slug":"EXCEL","permalink":"http://yinzhm.gitee.io/tags/EXCEL/"},{"name":"读后感","slug":"读后感","permalink":"http://yinzhm.gitee.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"name":"Tableau","slug":"Tableau","permalink":"http://yinzhm.gitee.io/tags/Tableau/"},{"name":"心理学","slug":"心理学","permalink":"http://yinzhm.gitee.io/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"},{"name":"运营","slug":"运营","permalink":"http://yinzhm.gitee.io/tags/%E8%BF%90%E8%90%A5/"},{"name":"音乐","slug":"音乐","permalink":"http://yinzhm.gitee.io/tags/%E9%9F%B3%E4%B9%90/"},{"name":"摄影","slug":"摄影","permalink":"http://yinzhm.gitee.io/tags/%E6%91%84%E5%BD%B1/"},{"name":"Photoshop","slug":"Photoshop","permalink":"http://yinzhm.gitee.io/tags/Photoshop/"},{"name":"HTTP","slug":"HTTP","permalink":"http://yinzhm.gitee.io/tags/HTTP/"},{"name":"状态码","slug":"状态码","permalink":"http://yinzhm.gitee.io/tags/%E7%8A%B6%E6%80%81%E7%A0%81/"}]}